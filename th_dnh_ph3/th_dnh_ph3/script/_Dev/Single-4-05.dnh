#TouhouDanmakufu[Single]
#ScriptVersion[3]
#Title["Automaton \"Sky Snake\""]
#Text["..."] 
#BGM["./bgm/bgm - Bhava-Agra As Seen Through a Child's Mind.mp3"]
#System["./system/Default_System.txt"]
#Background["./system/Background_Stars.txt"]

#include "./Index.txt"




let fog;

let timer = 30;

@Event
{
	alternative(GetEventType())
	case(EV_REQUEST_LIFE)
	{
		SetScriptResult(2000);
	}
	case(EV_REQUEST_SPELL_SCORE){
        SetScriptResult(5000000);
    }
	 //case(EV_REQUEST_IS_DURABLE_SPELL) {
		// SetScriptResult(true);
	 //}
	case(EV_REQUEST_TIMER) { SetScriptResult(timer*60); } //4500
}
@Initialize
{
	SetCommonData("CurrentSC","Automaton \"Sky Snake\"");
	SetCommonData("Difficulty","Easy");
	
	boss = spawnBoss();
	
	ObjEnemy_SetDamageRate(boss,0,0);
	SetShotAutoDeleteClip(32,32,32,32);
	
	EnemyName(boss, "Andi", 255, 180, 255);
	
	MainTask;
	

}
@MainLoop
{

	if(ObjEnemy_GetInfo(boss, INFO_LIFE) <= 0 && !finishing)
	{
		finishing = true;
		TBreakSpell([]);
	}
	else {
		SetBossHitbox(boss,ex,ey);
	}
	frame++;
	yield;
}


task MainTask {
	
	ObjEnemy_SetDamageRate(boss,0,0);
	//ObjMove_SetDestAtFrame(boss, rand(cx+60, cx-60), rand(cy-120, cy-90), 60);
	ObjMove_SetDestAtFrame(boss, cx, cy-120, 60);
	
	SetSpellCard;
	MCircNextAlpha = 80;
	Obj_SetValue(objSpellCircle,"MaxAlpha",64);
	
	ObjEnemyBossScene_StartSpell(objScene);
	ObjEnemyBossScene_SetSpellTimer(objScene,timer*60); //5760
	//TAfterImageBoss(boss,[255,255,255],1,1,15,3,BLEND_ADD_ARGB,0);
	//SE_Play(nyaa,60);
	//SetCaution;
	
	//SetBossBlur(true);

	wait(90);
	
	ObjEnemy_SetDamageRate(boss,24,8);


	
	frame = 0;
	
//	TShoot;
//	TBigShots;
	//Tmovement(cx-60,cx+60, cy,cy-60, 60,240, []); //[MOVE_PLAYERBIAS,2,0]
	Tmovement(30,sx-30, 30,cy+90, 60,240, [MOVE_NEAR,150,MOVE_FAR,50,MOVE_PNLSPACE,50,MOVE_MAXSPEED,1.5,MOVE_SMOOTH,10]); //[MOVE_PLAYERBIAS,2,0]

	//CallFan("Bright",1);
	//Aura (boss,255,0,200);
	Aura (boss,180,180,255);
	TFog;
	
	//Oval;
//	Diamond;
	
	// ShapedLaser([ [0,0],[60,0],[90,30],[30,60],[30,30], [0,0] ],30,60, [255,128,0,128]);

	// let arr = [];
	// //loop(10){ arr = arr ~ [ [rand(0,sx),rand(0,sy)] ]; }
	// ascent(i in 0..10){ 
		// arr = arr ~ [ [cx+rand(50,100)*cos(36*i), cy+rand(50,100)*sin(36*i)]  ];
	// }
	// ShapedLaser(arr,30,60, [255,128,0,128]);
	
	
	wait(180); 
	TShoot;
	loop(3){ TTiles(randint(0,xN-1),randint(0,yN/2),true); }
	//	TBigShots;
	
	
	//Sphere;
	
}


let gap = 30; //30
let xgap = gap; let ygap = gap;
let xN = ceil(sx/xgap)+1; let yN = ceil(sy/ygap)+1;
let xoff = absolute(xgap*xN-sx)/2; let yoff = absolute(ygap*yN-sy)/2;


//Grid of shots
task TShoot {
	let seobj = ObjSound_Create;
	let shot;
	

	//let types = [758]; let nt = length(types);
	
	
	
//	let spd = 0.75;
//	let ang = 45;
//	let mainspd = spd*cos(ang);
//	let driftspd= spd*sin(ang);
	
	let mainspd =  0.75; 
	let driftspd = 0;
	
	let type = 758; //212
	
	
	let del = gap/mainspd;
	
	while(!Obj_IsDeleted(boss)) {
		//Vertical shots, created across X
		ascent(i in 0..xN-1){
			//down and right
			shot = CreateShotB1(xgap*i-xoff,  -yoff, driftspd, mainspd, type,0);
			//WrapA1(shot,-1,[LFT,RGT]);
			//up and left
			shot = CreateShotB1(xgap*i-xoff,sy+xoff,-driftspd,-mainspd, type,0);
			//WrapA1(shot,-1,[RGT,LFT]);
		}
		//Horizontal shots, created across Y
		ascent(i in 0..yN-1){
			//right and up
			shot = CreateShotB1( -xoff, ygap*i-yoff, mainspd,-driftspd, type,0);
			//WrapA1(shot,-1,[TOP,BTM]);
			//left and down
			shot = CreateShotB1(sx+xoff,ygap*i-yoff,-mainspd, driftspd, type,0);
			//WrapA1(shot,-1,[BTM,TOP]);
		}
		//SE_PlayA2(se_chime,40,seobj,30);
		wait(del);
		
	//	let x0 = xgap*randint(0,xN-1)-xoff; let x1 = x0 + gap;
	//	let y0 = ygap*randint(0,yN-1)-yoff; let y1 = y0 + gap;
	//	SquareLaser(x0,y0,x1,y1, 30,60,[255,0,255], 5);
	//	SE_Play(se_laser,100);
		
		
	}
}


let board = [];
loop(xN+1){
	let row = [];
	loop(yN+1){
		row = row ~ [0];
	}
	board = board ~ [[row]];
}

function GetBoardPos(x,y){
	let row = board[x];
	if(length(row)>y && Obj_GetType(row[y]) ==-1){ return row[y]; } else { return -1; }
}
function SetBoardPos(x,y,val){
	let row = board[x];
	if(length(row)>y && Obj_GetType(row[y]) ==-1){ 
		row[y] = val; 
		return 0;
	} 
	else { return -1; }
}


task TTiles(spawnx, spawny, isHoming) {
	let las; let x0; let x1; let y0; let y1;
	let del = 30; let dur = 120; let tiledelay = 30; //30,60,60
	
	let lastX = spawnx; //round(xN/2);  //round(ex/xgap); 
	let lastY = spawny; //round(yN/2);  //round(ey/ygap);
	let nextX; let nextY; let lastdir = 1; let nextdir=1;
	
	let ok; let count;
	
	while(!Obj_IsDeleted(boss)){

		ok=false; count=0;
		while(!ok){
			ok=true;
			if(!isHoming || count>2){ 
				nextdir = (4+ lastdir + sign(randint(-3,3)/3))%4;	
			} else {
				let ang = angleFrom( xgap*lastX-xoff-xgap/2, ygap*lastY-yoff-ygap/2 );
				if(      (nextdir*90-ang)%180 < 0) { nextdir = (lastdir+1)%4; }
				else if( (nextdir*90-ang)%180 > 0) { nextdir = (lastdir-1)%4; }
				else {    nextdir = lastdir; }
				//nextdir = round( angleFrom( xgap*lastX-xoff-xgap/2, ygap*lastY-yoff-ygap/2 ) / 90 );
			}
			nextX = lastX + sign(nextdir-1)*((nextdir+1)%2);
			nextY = lastY + sign(nextdir-2)*((nextdir+0)%2);
			if(nextX>xN-1){nextX=0;}else if(nextX<0){nextX=xN-1;}
			if(nextY>yN-1){nextY=0;}else if(nextY<0){nextY=yN-1;}
			
		//	WriteLog("Board position " ~ ToString((GetBoardPos(nextX,nextY))) ~ ";     type " ~ ToString(Obj_GetType((GetBoardPos(nextX,nextY)))));
		
			if( (GetBoardPos(nextX,nextY) <= 0) && (count < 10) ){ ok = false; count++; }
		}
		
		lastX = nextX; lastY = nextY; lastdir = nextdir;
		
		x0 = xgap*nextX-xoff; x1 = x0 + gap;
		y0 = ygap*nextY-yoff; y1 = y0 + gap;
		
		las = SquareLaser(x0,y0,x1,y1, del,240,[255,255,255], 5);
		
		Obj_SetValue(las,"BoardPos",[nextX,nextY]);
		SetBoardPos(nextX,nextY,6);

		TColorChange(las,tiledelay,dur);
		SE_Play(se_kira02,100);
		
	//	x0 = xgap*randint(0,xN-1)-xoff; x1 = x0 + gap;
	//	y0 = ygap*randint(0,yN-1)-yoff; y1 = y0 + gap;
	//	SquareLaser(x0,y0,x1,y1, 30,60,[255,0,255], 5);
	//	//SE_Play(se_laser,100);
	//	SE_Play(se_kira02,100);
		
		wait(tiledelay);
	}
}



task TColorChange(las,step,dur) {
	let color; 
	let colors = [ [255,255,255],[255,128,128],[255,200,128],[255,255,100],[140,255,128],[128,130,255],[200,128,255],[255,128,255] ];
	let pos = Obj_GetValue(las,"BoardPos"); let x=pos[0]; let y=pos[1];
	ascent(i in 0..8) {
		if(!Obj_IsDeleted(las)){
			//ObjShot_SetGraphic(las,1002+i);
		//	color = GetShotDataInfoA1(1002+i,TARGET_ENEMY,INFO_DELAY_COLOR);
		//	ObjRender_SetColor(las,color[0],color[1],color[2]);
			color = colors[i%8];
			ObjRender_SetColor(las,color[0],color[1],color[2]);
			//ObjRender_SetAlpha(las,255-40*i);
			//SetBoardPos(x,y,6-i);
			wait(step);
		}
		else{return;}
	}
	ObjShot_FadeDelete(las);
	SetBoardPos(x,y,0);
}







task TBigShots {
	let shot; //let ang;
	
	let x; let y; let dx; let dy;
	let dir=1;
	
	let types = [292,296,298]; let nt = length(types);
	
	while(!Obj_IsDeleted(boss)) {
		wait(30);
		SetAttackPose(45);
		wait(30);
		
	
		
		//random bezier curves
		//let arrx = [tern(randbool,0,sx)]; loop(5){arrx = arrx~[rand(0,sy)];} arrx = arrx~[tern(randbool,0,sx)];
		//let arry = [tern(randbool,0,sy)]; loop(5){arry = arry~[rand(0,sy)];} arry = arry~[tern(randbool,0,sy)];
		
		let startx    = GetSwordTipX; 
		let controlx  = GetQuadraticBezierPoint(0,ex,sx,rand(0,1));
		let control2x = px;
		let endx      = cx-(ex-cx);
		
		let starty    = GetSwordTipY;
		let controly  = swdy*2/3;
		let control2y = swdy*1/3;
		let endy      = 0; 			//let endy = tern(randbool,0,sy);
		
		let N = 30; //50
		ascent(i in 0..N) {
			
			x = GetCubicBezierPoint(startx,controlx,control2x,endx,i/N);
			y = GetCubicBezierPoint(starty,controly,control2y,endy,i/N);
			dx = rand(-1,1);
			dy = rand(0,1);
			
			if(Distance(x,y,px,py)>30){
				shot = CreateShotB2(x,y,0,0,  dx*0.1,dy*0.1,  dx,dy,  734,25); //15	//712
			}else{
				WarnShotB2(x,y,712,0,15);
			}
		}
		
		SE_Play(se_anchor,100);
		SE_Play(se_thunder,100);
		
		GlowCircle(startx,starty,[255,255,0,255],0,4,30);
		GlowCircle(endx,endy,    [255,255,0,255],4,-3.5,30);
		
		ConcentrationA4Invert(boss,"HEXAGON",3,50,[255,0,200]);	
		dir*=-1;
		
		wait(60);
	}
	
	
}



// task ReAim(shot, del, mspd, scl) {
	// let dA;
	// while(!Obj_IsDeleted(shot)){
		// dA = (GetAngleToPlayer(shot)-ObjMove_GetAngle(shot))%180;
		// if( dA < 91 && dA > 89 ) {
			// //ObjMove_SetAngle(shot,GetAngleToPlayer(shot));
			// ObjMove_AddPatternA2(shot,0, 0,GetAngleToPlayer(shot), 0.075*scl,0, mspd*scl);
			// return;
		// }
		// yield;
	// }
// }






task TFog {
	
	let targ = CreateShotA1(ex,ey,0,0,0,0); 
	ObjShot_SetSpellResist(targ,true);
	ObjShot_SetAutoDelete(targ,false);
	
	// fog = NightBlindA1(600,100,240,  0,255,30);
	// ObjRender_SetColor(fog,255,128,255);
	// ObjRender_SetBlendType(fog,BLEND_ALPHA);
	// Obj_SetValue(fog,"Target",targ);
	
	// fog = NightBlindA1(600,200,240,  0,64,30);
	// ObjRender_SetColor(fog,200,200,200);
	// ObjRender_SetBlendType(fog,BLEND_ALPHA);
	// Obj_SetValue(fog,"Target",targ);
	// Obj_SetValue(fog,"RotSpeed",5);
	// Obj_SetValue(fog,"Check",false);
	
	//"Clouds"
	fog = NightBlindA1(600,250,240,  0,255,30);
	ObjRender_SetColor(fog,255,255,255);
	ObjRender_SetBlendType(fog,BLEND_ALPHA);
	Obj_SetValue(fog,"Target",boss);
	Obj_SetValue(fog,"RotSpeed",3);
	Obj_SetValue(fog,"Check",false);
	
	while(!Obj_IsDeleted(boss)){
		ObjMove_SetDestAtFrame(targ,ex,ey,60);
		yield;
	}
	
	
	
}







// task Diamond() {
	// //let scl = 50; 
	// let N = 10; //36
	
	// let shot; let pt; let x; let y; let z;
	// let a = 0;
	// let points; let point; let ang; let mag;
	// while(!Obj_IsDeleted(boss)){
		
		// points = GetShape2(px,py,50,a,5,N);
		// ascent(i in 0..length(points)/4) {
			// //point = points[i];
			// //WriteLog(point);
			// ang = points[i*4+3]; 
			// mag = points[i*4+2];
			// CreateShotA1(points[i*4+0]*50+px,points[i*4+1]*50+py,mag,ang, 212, 10);
		// }
	// //	ShootShape(px, py, -0.5, a, 3, N, 212, 15);
		
		// // ascent(i in 0..N){
			// // ascent(j in 0..4) {
				// // alternative(j)
				// // //left
				// // case(0){ pt = rotate( i/scl/N, i*scl/N, 0,0, a); }
				// // //top
				// // case(1){ pt = rotate( i*scl/N,i/scl/N,  0,0, a); }
				// // //right
				// // case(2){ pt = rotate(-i/scl/N, i*scl/N, 0,0, a); }
				// // //bottom
				// // case(3){ pt = rotate( i*scl/N,-i/scl/N, 0,0, a); }
				// // x = pt[0]; y = pt[1];
				// // shot = CreateShotB1(ex+scl*x,ey+scl*y, 1.5*x,1.5*y, 212,10);
				// // //shot = CreateShotA1(ex+10*x,ex+10*y, 1.5*x, a, 212, 10);
			// // }
		// // }
		// SE_Play(se_shot,70);
		// a+=10; 	//a%=360/N;
		// //a=rand(rand(20,30),rand(50,70))*rand(1,9);
		// wait(30);
	
		// FireWedgeA1(ex,ey,rand(0,360),2,620,5,	10,6,5, 20,10);
	
		
		// wait(30);
		
		
	 // }
	
// }






// task Sphere {
	// let N = 24; //24 //number of "rings"
	// let M = 12; //12 //number of shots per "ring"
	// let dI = 360/N; let dJ = 180/M;
	
	// let shot; let shot2;
	// let xf; let yf; let zf;
	// let xb; let yb; let zb;
	
	// let point;
	// let x0 = cx; let y0 = cy; let z0 = 0;
	// let rad=100;
	// let shots = [];
	// ascent(i in 0..N){
		// ascent(j in 0..M){
			// point = GetSpherePoint(i*dI,j*dJ,rad);
			// xf = point[0]; yf = point[1]; zf = point[2];
			
			// shot = CreateShotA1(x0+xf,y0+yf,0,0,212,30);
			// ObjShot_SetSpellResist(shot,true);
			// shots = shots ~ [shot];
			
			// shot2 = CreateShotA1(x0+xf,y0+yf,0,0,210,30);
			// ObjShot_SetSpellResist(shot2,true);
			// ObjRender_SetAlpha(shot2,128);
			// ObjShot_SetIntersectionEnable(shot2,false);
			// shots = shots ~ [shot2];
		// }
	// }
	
	// let ind;
	// while(!Obj_IsDeleted(boss)){
		// ascent(i in 0..(N*M/2)){
		
			// shot  = shots[i];
			// shot2 = shots[i+1];
			
			// point = rotate3D(ObjRender_GetX(shot),ObjRender_GetY(shot),ObjRender_GetZ(shot), x0,y0,z0, 10,10,10);
			// //point = rotate(ObjRender_GetX(shot),ObjRender_GetY(shot), x0,y0, 10);
			// xf = point[0]; yf = point[1]; zf = point[2];
			// ObjMove_SetPosition(shot,xf,yf);
			
			// point = rotate3D(ObjRender_GetX(shot2),ObjRender_GetY(shot2),ObjRender_GetZ(shot2), x0,y0,z0, -10,-10,-10);
			// xb = point[0]; yb = point[1]; zb = point[2];
			// ObjMove_SetPosition(shot2,xb,yb);
			
			// //ObjRender_SetPosition(shot2,x,py,0);
			
		// //	Obj_SetVisible(tern(z>=0,shot,shot2),true);
		// //	Obj_SetVisible(tern(z>=0,shot2,shot),false);
			
			// if(zf>=0){
				// //Show bullet, hide effect
				// ObjMove_SetPosition(shot,xf,yf);
				// ObjMove_SetPosition(shot2,-100,-100);
				// ObjShot_SetIntersectionEnable(shot2,true);
			// }else{
				// //Show effect, hide bullet
				// ObjMove_SetPosition(shot2,xb,yb);
				// ObjMove_SetPosition(shot,-100,-100);
				// ObjShot_SetIntersectionEnable(shot2,false);
			// }
			
			// // shot = shots[12*i+j+1];
			
			// // point = rotate3D(ObjRender_GetX(shot),ObjRender_GetY(shot),ObjRender_GetZ(shot), x0,y0,z0, 1,1,1);
			// // x = point[0]; y = point[1]; z = point[2];
			// // ObjRender_SetPosition(shot,x,y,z);
			
		// }
		// //SE_Play(nyaa,30);
		// yield;
	// }
	
	
	
// }