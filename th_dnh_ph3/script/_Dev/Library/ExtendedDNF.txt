
//MISC



function ObjEnemy_GetLife(enemy){return ObjEnemy_GetInfo(enemy,INFO_LIFE);}





//////////////////////////////////////////////////////////////////
// Render Object Functions
//////////////////////////////////////////////////////////////////






//Andi - COLOR/ALPHA FUNCTIONS
//Set an object's alpha or RGB, depending on blend type.
//Efficient. Always use this to ensure alpha is accessible by other functions.
function OR_SetAlpha(obj, alpha){
	Obj_SetValue(obj, "Alpha", alpha); Obj_SetValue(obj, "A", alpha);
	let C; let R; let G; let B; let A;
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ADD_RGB,BLEND_SUBTRACT,BLEND_MULTIPLY,BLEND_SHADOW){
		C = Obj_GetValueD(obj,"Color",[255,255,255]);
		R = Obj_GetValueD(obj,"R",C[0]);
		G = Obj_GetValueD(obj,"G",C[1]);
		B = Obj_GetValueD(obj,"B",C[2]);
		A = alpha/255;
		Obj_SetValue(obj,"Color",[R,G,B,alpha]);
	}
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ALPHA)   {ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_ARGB){ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_RGB) {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SUBTRACT){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_MULTIPLY){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SHADOW)  {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	others{ObjRender_SetAlpha(obj, alpha);}
}
function ObjRender_SetTrueAlpha(obj,alpha){ OR_SetAlpha(obj,alpha); }
//Set color such that it is accessible by other functions.
//Efficient. Always use one of these. 
function OR_SetColor(obj,r,g,b){
	ObjRender_SetColor(obj,r,g,b);
	Obj_SetValue(obj,"R",r);
	Obj_SetValue(obj,"G",g);
	Obj_SetValue(obj,"B",b);
	Obj_SetValue(obj,"Color",[r,g,b]);
}
function OR_SetColorRGB(obj,r,g,b){ OR_SetColor(obj,r,g,b); }
function OR_SetColorRGBA(obj,r,g,b,a){
	OR_SetColor(obj,r,g,b);
	OR_SetAlpha(obj,a);
	Obj_SetValue(obj,"Color",[r,g,b,a]);
}
function ObjRender_SetTrueColor(obj,r,g,b){ OR_SetColor(obj,r,g,b); }

//Attempt to compensate for the lack of such functions.
//Efficient as long as value was properly stored, or after the first time.
function OR_GetAlpha(obj){
	if(Obj_IsValueExists(obj,"Alpha")){return Obj_GetValue(obj,"Alpha");}
	else{
		let C = Obj_GetValueD(obj,"Color",[255,255,255]);
		if(length(C) > 3){ Obj_SetValue(obj,"Alpha",C[3]); return C[3]; }
		let A = Obj_GetValueD(obj,"A",0);
		if(A>0){ Obj_SetValue(obj,"Alpha",A); return A;}
		let R = Obj_GetValueD(obj,"R",C[0]); 
		let G = Obj_GetValueD(obj,"G",C[1]); 
		let B = Obj_GetValueD(obj,"B",C[2]);
		A = max(R,max(G,B)); //Use the largest RGB value
		Obj_SetValue(obj,"Alpha",A); Obj_SetValue(obj,"A",A);
		Obj_SetValue(obj,"Color",[R,G,B,A]);
		return A;
	}
}
function OR_GetColor(obj){ return Obj_GetValueD(obj,"Color",[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]); }
function OR_GetColorRGB(obj){return Obj_GetValueD(obj,"Color",[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);}
function OR_GetColorRGBA(obj){
	let C = Obj_GetValueD(obj,"Color",[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);
	let A = OR_GetAlpha(obj);
	return C ~ [A];
}
function ObjRender_GetAlpha(obj){return OR_GetAlpha(obj);}

function OR_AddAlpha(obj,dA){
	OR_SetAlpha(obj,OR_GetAlpha(obj)+dA);
}
task OR_SetAlphaAtFrame(obj,a1,time){
	let a0   = ObjRender_GetAlpha(obj);
	let dA   = (a1-a0)/time;
	ascent(i in 0..time){
		OR_SetAlpha(obj,a0+dA*i);
		yield;
	}
}

function OR_AddScaleXYZ(obj,dX,dY,dZ){ ObjRender_SetScaleXYZ(obj,ObjRender_GetScaleX(obj)+dX,ObjRender_GetScaleY(obj)+dY,ObjRender_GetScaleZ(obj)+dZ); }
task OR_SetScaleAtFrame(obj,sx1,sy1,time){
	let sx0   = ObjRender_GetScaleX(obj);
	let sy0   = ObjRender_GetScaleY(obj);
	let dsx   = (sx1-sx0)/time;
	let dsy   = (sy1-sy0)/time;
	ascent(i in 0..time){
		ObjRender_SetScaleXYZ(obj,sx0+dsx*i,sy0+dsy*i,1);
		yield;
	}
}





task Obj_FadeDelete(obj) {
	let a0   = Obj_GetValueD(obj,"Alpha",255);
	let time = Obj_GetValueD(obj,"FadeTime",60);
	let dA   = a0/time;
	descent(i in 0..time){
		OR_SetAlpha(obj,dA*i);
		yield;
	}
	Obj_Delete(obj);
}
// task Obj_FadeDeleteRGB(obj) {
	// let c0 = Obj_GetValueD(obj,"Color",[255,255,255]);
	// let time = Obj_GetValueD(obj,"FadeTime",60);
	// let r0=c0[0]; let g0=c0[1]; let b0=c0[2];
	// let dR = r0/time; let dG = g0/time; let dB = b0/time;
	// descent(i in 0..time){
		// ObjRender_SetColor(obj,dR*i,dG*i,dB*i);
		// yield;
	// }
	// Obj_Delete(obj);
// }



/////////////////////////////////////////////////////////////////
// Shot Functions
/////////////////////////////////////////////////////////////////



function PrepareShotA1(x,y,s,a,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	ObjMove_SetPosition(shot,x,y);
	ObjMove_SetSpeed(shot,s);
	ObjMove_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,graph);
	return shot;
}
function PrepareShotA2(x,y,s,a,acc,mspd,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	ObjMove_SetPosition(shot,x,y);
	ObjMove_SetSpeed(shot,s);
	ObjMove_SetAngle(shot,a);
	ObjMove_SetAcceleration(shot,acc);
	ObjMove_SetMaxSpeed(shot,mspd);
	ObjShot_SetGraphic(shot,graph);
	Obj_SetValue(shot,"Acceleration",acc); Obj_SetValue(shot,"MaxSpeed",mspd);
	return shot;
}



//if a shot is too close to the player, don't create it after all
//30 is a good radius
function CheckShot(shot,r){
	if(getdistance(ObjMove_GetX(shot),ObjMove_GetY(shot),px,py) <= r){
		let shot2 = CreateShotA1(ObjMove_GetX(shot),ObjMove_GetY(shot),0,0,ObjShot_GetImageID(shot),10);
		ObjRender_SetAlpha(shot2,128);
		ObjShot_SetDeleteFrame(shot2,0);
		ObjShot_SetDeleteFrame(shot,0);
	}
}


////////////////////////////////////////////////////////////////////
// Shot Object Functions
////////////////////////////////////////////////////////////////////

//Andi - Copy a shot as best as I could manage
//Things without getters need to be noted in the shot's dictionary to be used
function CopyShot(shot){
	if(Obj_IsDeleted(shot)){return NULL;}
		
	let x = ObjMove_GetX(shot);
	let y = ObjMove_GetY(shot);
	let spd = ObjMove_GetSpeed(shot);
	let ang = ObjMove_GetAngle(shot);
	let graph = ObjShot_GetImageID(shot);
	
	let acc  = Obj_GetValueD(shot,"Acceleration",0);
	let angv = Obj_GetValueD(shot,"AngularVelocity",0);
	let mspd = Obj_GetValueD(shot,"MaxSpeed",9999);
	
	let spellresist = ObjShot_IsSpellResist(shot);
	let intersect = Obj_GetValueD(shot,"IsIntersectionEnable",true);
	let scalexyz = [ObjRender_GetScaleX(shot),ObjRender_GetScaleY(shot),ObjRender_GetScaleZ(shot)];
	let blendtype = ObjRender_GetBlendType(shot);
	// let color = Obj_GetValueD(shot,"Color",[255,255,255]);
	let color = OR_GetColor(shot);
	// let alpha = Obj_GetValueD(shot,"Alpha",255);
	let alpha = OR_GetAlpha(shot);
	
	let length=NULL; let width=NULL; let dur=NULL; let del=0;
	
	let cpy=NULL; 
	if(Obj_GetType(shot)==OBJ_SHOT){
		cpy = CreateShotA1(x,y,spd,ang,graph,0);
	}else{
		length = ObjLaser_GetLength(shot);
		width = Obj_GetValueD(shot,"Width",15);
		dur = Obj_GetValueD(shot,"Duration",30);
		del = Obj_GetValueD(shot,"Delay",tern(Obj_GetType(shot)==OBJ_STRAIGHT_LASER, 15, 0));
		if(Obj_GetType(shot)==OBJ_LOOSE_LASER){ cpy = CreateLooseLaserA1(x,y,spd,ang, length, width, graph, del); }else
		if(Obj_GetType(shot)==OBJ_STRAIGHT_LASER){ cpy = CreateStraightLaserA1(x,y,ang,length,width, dur, graph, del); }else
		if(Obj_GetType(shot)==OBJ_CURVE_LASER){ cpy = CreateCurveLaserA1(x,y,spd,ang, length, width, graph, del); }
	}
	
	OM_AddPatternA3(shot,0,spd,ang,acc,angv,mspd,graph);
	
	// ObjMove_SetAcceleration(cpy,acc);
	// ObjMove_SetAngularVelocity(cpy,angv);
	// ObjMove_SetMaxSpeed(cpy,mspd);
	
	ObjRender_SetBlendType(cpy, blendtype);
	OR_SetColor(cpy,color[0],color[1],color[2]);
	OR_SetAlpha(cpy,alpha);
	ObjRender_SetScaleXYZ(cpy, scalexyz[0],scalexyz[1],scalexyz[2]);
	
	ObjShot_SetSpellResist(cpy,spellresist);
	ObjShot_SetIntersectionEnable(cpy,intersect);	
	Obj_SetRenderPriority(cpy,Obj_GetRenderPriority(shot));
	
	
	// Obj_SetValue(cpy,"Acceleration",acc);
	// Obj_SetValue(cpy,"AngularVelocity",angv);
	// Obj_SetValue(cpy,"MaxSpeed",mspd);
	// Obj_SetValue(cpy,"Alpha",alpha);
	// Obj_SetValue(cpy,"Color",color); 
	Obj_SetValue(cpy,"IsIntersectionEnable",intersect);
	
	return cpy;
}




function OS_GetDelayColor(shot) {
	if(isnull(shot)){return [0,0,0];}
	return GetShotDataInfoA1(ObjShot_GetImageID(shot),TARGET_ENEMY,INFO_DELAY_COLOR);
}

function OS_GetCollisionRadius(shot) {
	if(isnull(shot)){return 0;}
	return GetShotDataInfoA1(max(1,ObjShot_GetImageID(shot)),TARGET_ENEMY,INFO_COLLISION);
}



//////////////////////////////////////////////////////////////////////
// Move Object Functions
//////////////////////////////////////////////////////////////////////



//for moving shit what don't do ObjMove
task Obj_AddPatternA1(obj,fr,s,a){
	wait(fr);
	Obj_SetValue(obj,"Speed",s);
	Obj_SetValue(obj,"Angle",a);
	ObjRender_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Speed",s)==s && Obj_GetValueD(obj,"Angle",a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
	}
}
task Obj_AddPatternA2(obj,fr,s,a,acc,mspd){
	wait(fr);
	Obj_SetValue(obj,"Speed",s);
	Obj_SetValue(obj,"Angle",a);
	Obj_SetValue(obj,"Acceleration",acc);
	Obj_SetValue(obj,"MaxSpeed",mspd);
	let isDecel = (acc<0);
	ObjRender_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Speed",s)==s && Obj_GetValueD(obj,"Angle",a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
		s+=acc;
		alternative(isDecel)
		case(true) {s=max(s,mspd);}
		case(false){s=min(s,mspd);}
		Obj_SetValue(obj,"Speed",s);
		dx = s*cos(a); dy = s*sin(a);
	}
}



task OM_SetAngularAcceleration(obj,anga){
	Obj_SetValue(obj,"AngularAcceleration",anga);
	let angv = Obj_GetValueD(obj,"AngularVelocity",0);
	let mangv = Obj_GetValueD(obj,"MaxAngularVelocity",0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"AngularAcceleration",0)==anga ){
		angv = Obj_GetValueD(obj,"AngularVelocity",0);
		mangv = Obj_GetValueD(obj,"MaxAngularVelocity",0);
		if( (|angv|) < (|mangv|) || sign(mangv-angv) == sign(anga) ){
			angv += anga;
			ObjMove_SetAngularVelocity(obj,angv);
			Obj_SetValue(obj,"AngularVelocity",angv);
		}else{
			ObjMove_SetAngularVelocity(obj,mangv);
			Obj_SetValue(obj,"AngularVelocity",mangv);
			return;
		}
		yield;
	}
}
function OM_SetMaxAngularVelocity(obj,mangv){ Obj_SetValue(obj,"MaxAngularVelocity",mangv); }


task OM_SetJerk(obj,jerk){
	Obj_SetValue(obj,"Jerk",jerk);
	let acc = Obj_GetValueD(obj,"Acceleration",0);
	let macc = Obj_GetValueD(obj,"MaxAcceleration",0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Acceleration",0)==acc ){
		acc = Obj_GetValueD(obj,"Acceleration",0);
		macc = Obj_GetValueD(obj,"MaxAcceleration",0);
		// if( (|acc|) < (|macc|) || sign(macc-acc) == sign(jerk) ){
		// if( inrange(acc,0,(|macc|)*sign(jerk)) ){
		// if( inrange(acc,99-99*sign(jerk),(|macc|)*sign(jerk)) ){
		// if( (|acc+999|) < (|macc+999|) || sign(macc-acc) == sign(jerk) ){
		if( isapproaching(acc,jerk,macc) ){
			acc += jerk;
			ObjMove_SetAcceleration(obj,acc);
			Obj_SetValue(obj,"Acceleration",acc);
		}else{
			ObjMove_SetAcceleration(obj,macc);
			Obj_SetValue(obj,"Acceleration",macc);
			return;
		}
		yield;
	}
}
function OM_SetMaxAcceleration(obj,macc){ Obj_SetValue(obj,"MaxAcceleration",macc); }









task OR_SetAngularVelocity(obj,da){
	Obj_SetValue(obj,"RenderAngularVelocity",da);
	if(da==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocity",0)==da){
		ObjRender_SetAngleZ(obj,ObjRender_GetAngleZ(obj)+da);
		yield;
	}
}
task OR_SetAngularVelocityXYZ(obj,dxa,dya,dza){
	Obj_SetValue(obj,"RenderAngularVelocityXYZ",[dxa,dya,dza]);
	if(dxa==0&&dya==0&&dza==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocityXYZ",[0,0,0])==[dxa,dya,dza]){
		ObjRender_SetAngleXYZ(obj,ObjRender_GetAngleX(obj)+dxa,ObjRender_GetAngleY(obj)+dya,ObjRender_GetAngleZ(obj)+dza);
		yield;
	}
}




function OM_SetSpeed(obj,val){
	ObjMove_SetSpeed(obj,val);
	Obj_SetValue(obj,"Speed",val);
}
function OM_GetSpeed(obj){return ObjMove_GetSpeed(obj);}
function OM_SetAngle(obj,val){
	ObjMove_SetAngle(obj,val);
	Obj_SetValue(obj,"Angle",val);
}
function OM_GetAngle(obj){return ObjMove_GetAngle(obj);}
function OM_SetAcceleration(obj,val){
	ObjMove_SetAcceleration(obj,val);
	Obj_SetValue(obj,"Acceleration",val);
}
function OM_GetAcceleration(obj){return Obj_GetValueD(obj,"Acceleration",0);}
function OM_SetMaxSpeed(obj,val){
	ObjMove_SetMaxSpeed(obj,val);
	Obj_SetValue(obj,"MaxSpeed",val);
}
function OM_GetMaxSpeed(obj){return Obj_GetValueD(obj,"MaxSpeed",99);}
function OM_SetAngularVelocity(obj,val){
	ObjMove_SetAngularVelocity(obj,val);
	Obj_SetValue(obj,"AngularVelocity",val);
}
function OM_GetAngularVelocity(obj){return Obj_GetValueD(obj,"AngularVelocity",0);}





//Add pattern and store parameters in the object's dictionary
function OM_AddPatternA1(obj,del,spd,ang){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	ObjMove_AddPatternA1(obj,del,spd,ang);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,"Speed",spd);
		Obj_SetValue(obj,"Angle",ang);
	}
}

function OM_AddPatternA2(obj,del,spd,ang,acc,angv,mspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,"Speed",spd);
		Obj_SetValue(obj,"Angle",ang);
		Obj_SetValue(obj,"Acceleration",acc);
		Obj_SetValue(obj,"AngularVelocity",angv);
		Obj_SetValue(obj,"MaxSpeed",mspd);
	}
}

function OM_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternGraphic",graph);
	ObjMove_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,"Speed",spd);
		Obj_SetValue(obj,"Angle",ang);
		Obj_SetValue(obj,"Acceleration",acc);
		Obj_SetValue(obj,"AngularVelocity",angv);
		Obj_SetValue(obj,"MaxSpeed",mspd);
		Obj_SetValue(obj,"Graphic",graph);
	}
}






function OM_AddPatternA5(obj,del,spd,ang,acc,angv,mspd,jerk,macc,anga,mangv){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternJerk",jerk);
	Obj_SetValue(obj,"PatternMaxAcceleration",macc);
	Obj_SetValue(obj,"PatternAngularAcceleration",anga);
	Obj_SetValue(obj,"PatternMaxAngularVelocity",mangv);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,"Speed",spd);
		Obj_SetValue(obj,"Angle",ang);
		Obj_SetValue(obj,"Acceleration",acc);
		Obj_SetValue(obj,"AngularVelocity",angv);
		Obj_SetValue(obj,"MaxSpeed",mspd);
		Obj_SetValue(obj,"Jerk",jerk);
		Obj_SetValue(obj,"MaxAcceleration",macc);
		Obj_SetValue(obj,"AngularAcceleration",anga);
		Obj_SetValue(obj,"MaxAngularVelocity",mangv);
		OM_SetJerk(obj,jerk);
		OM_SetAngularAcceleration(obj,anga);
	}
}




function OM_AddPatternB1(obj,del,xspd,yspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	ObjMove_AddPatternB1(obj,del,xspd,yspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,"UseXYSystem",true);
		Obj_SetValue(obj,"UseSASystem",false);
		Obj_SetValue(obj,"XSpeed",xspd);
		Obj_SetValue(obj,"YSpeed",yspd);
	}
}
function OM_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	Obj_SetValue(obj,"PatternXAcceleration",xacc);
	Obj_SetValue(obj,"PatternYAcceleration",yacc);
	Obj_SetValue(obj,"PatternXMaxSpeed",xmspd);
	Obj_SetValue(obj,"PatternYMaxSpeed",ymspd);
	ObjMove_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,"UseXYSystem",true);
		Obj_SetValue(obj,"UseSASystem",false);
		Obj_SetValue(obj,"XSpeed",xspd);
		Obj_SetValue(obj,"YSpeed",yspd);
		Obj_SetValue(obj,"XAcceleration",xacc);
		Obj_SetValue(obj,"YAcceleration",yacc);
		Obj_SetValue(obj,"XMaxSpeed",xmspd);
		Obj_SetValue(obj,"YMaxSpeed",ymspd);
	}
}







task OM_Still(obj,time){
	ObjMove_SetAcceleration(obj,0);
	let s0 = ObjMove_GetSpeed(obj);
	let dS = s0/time;
	descent(i in 0..time){
		ObjMove_SetSpeed(obj,dS*i);
		yield;
	}
	ObjMove_SetAngularVelocity(obj,0);
}
function ObjMove_Still(obj,time){OM_Still(obj,time);}













//////////////////////////////////////////////////////////////////
// Laser Object Functions
//////////////////////////////////////////////////////////////////

task ObjStLaser_SetAngularVelocity(las,angv){
	Obj_SetValue(las,"AngularVelocity",angv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularVelocity",angv)==angv){
		ObjStLaser_SetAngle(las,ObjStLaser_GetAngle(las)+angv);
		yield;
	}
}
task ObjStLaser_SetAngularAcceleration(las,anga){
	Obj_SetValue(las,"AngularAcceleration",anga);
	let angv = Obj_GetValueD(las,"AngularVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularAcceleration",0)==anga ){
		angv = Obj_GetValueD(las,"AngularVelocity",0);
		if( (|angv|) < (|Obj_GetValueD(las,"MaxAngularVelocity",3)|) ){
			ObjStLaser_SetAngularVelocity(las,angv+anga);
			Obj_SetValue(las,"AngularVelocity",angv+anga);
		}
		yield;
	}
}
function ObjStLaser_SetMaxAngularVelocity(las,mangv){OM_SetMaxAngularVelocity(las,mangv);}

function ObjStLaser_SetTipPosition(las,x,y){
	let x0 = ObjMove_GetX(las);	let y0 = ObjMove_GetY(las);
	let len = getdistance(x0,y0,x,y);
	let ang = getangle(x0,y0,x,y);
	ObjLaser_SetLength(las,len);
	ObjStLaser_SetAngle(las,ang);
}

task ObjLaser_SetExtendVelocity(las,extv){
	Obj_SetValue(las,"ExtendVelocity",extv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendVelocity",0)==extv && Obj_GetValueD(las,"MaxExtendLength",0)>=ObjLaser_GetLength(las)){
		ObjLaser_SetLength(las,ObjLaser_GetLength(las)+extv);
		yield;
	}
}
task ObjLaser_SetExtendAcceleration(las,exta){
	Obj_SetValue(las,"ExtendAcceleration",exta);
	let extv = Obj_GetValueD(las,"ExtendVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendAcceleration",0)==exta ){
		extv = Obj_GetValueD(las,"ExtendVelocity",0);
		if( (|extv|) < (|Obj_GetValueD(las,"MaxExtendVelocity",2)|) ){
			ObjLaser_SetExtendVelocity(las,extv+exta);
			Obj_SetValue(las,"ExtendVelocity",extv+exta);
		}
		yield;
	}
}
function ObjLaser_SetMaxExtendVelocity(las,mextv){
	Obj_SetValue(las,"MaxExtendVelocity",mextv);
}
function ObjLaser_SetMaxExtendLength(las,mextl){
	Obj_SetValue(las,"MaxExtendLength",mextl);
}

task ObjLaser_SetExpandVelocity(las,expv){
	Obj_SetValue(las,"ExpandVelocity",expv); let width;
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandVelocity",0)==expv){
		width = Obj_GetValueD(las,"Width",15);
		if(width < Obj_GetValueD(las,"MaxExpandWidth",50)) {
			ObjLaser_SetRenderWidth(las,width+expv);
			ObjLaser_SetIntersectionWidth(las,(width+expv)/3);
			Obj_SetValue(las,"Width",width+expv);
		}
		yield;
	}
}
task ObjLaser_SetExpandAcceleration(las,expa){
	Obj_SetValue(las,"ExpandAcceleration",expa);
	let expv = Obj_GetValueD(las,"ExpandVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandAcceleration",0)==expa ){
		expv = Obj_GetValueD(las,"ExpandVelocity",0);
		if( (|expv|) < (|Obj_GetValueD(las,"MaxExpandVelocity",3)|) ){
			ObjLaser_SetExpandVelocity(las,expv+expa);
		}
		yield;
	}
}
function ObjLaser_SetMaxExpandVelocity(las,mexpv){
	Obj_SetValue(las,"MaxExpandVelocity",mexpv);
}
function ObjLaser_SetMaxExpandWidth(las,mexpw){
	Obj_SetValue(las,"MaxExpandWidth",mexpw);
}



//////////////////////////////////////////////////////////////////
// Intersection Functions
//////////////////////////////////////////////////////////////////





//Determine if two line segments intersect
function IsIntersected_Line_Line(ax0,ay0,ax1,ay1,  bx0,by0,bx1,by1) {
	//Convert vector 1 to equation - A*x + B*y + C
	let e_a1 = ay1-ay0;
	let e_b1 = ax0-ax1;
	let e_c1 = (ax1*ay0) - (ax0*ay1);
	
	//Plug endpoints of vector 2 into that equation
	let e_d1 = (e_a1*bx0) + (e_b1*by0) + e_c1;
	let e_d2 = (e_a1*bx1) + (e_b1*by1) + e_c1;
	
	//If d1 and d2 have the same sign, they are both on same side of first line
	//and therefore the lines cannot intersect
	//0 is a special case
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Since we were treating vector 1 an an infinite line, 
	//we need to repeat that check treating vector 2 as an infinite line instead
	
	//Convert to equation
	let e_a2 = by1-by0;
	let e_b2 = bx0-bx1;
	let e_c2 = (bx1*by0) - (bx0*by1);
	//Plug in endpoints of vector 1
	e_d1 = (e_a2*ax0) + (e_b2*ay0) + e_c2;
	e_d2 = (e_a2*ax1) + (e_b2*ay1) + e_c2;
	//Check if they're on the same side of vector 1
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Check if they're colinear, i.e. intersecting at way too many points
	//Technically this should be its own case but I don't really care
	//It's not exactly a collision and it's unlikely to ever come up anyway
	if( (e_a1*e_b2)-(e_a2*e_b1) < 0.001 ) {
		return false;
	}
	
	//Well, we've eliminated all the other possibilities I can think of
	//So we'll assume they intersect
	return true;
}

//Find point at which two line segments intersect
function GetIntersection_Line_Line(x0,y0,x1,y1,  x2,y2,x3,y3) {
	//Convert vector 1 to equation - 
	//A*x + B*y + C
	let a1 = y1-y0;
	let b1 = x0-x1;
	let c1 = (x1*y0) - (x0*y1);
	//Convert vector 2 to equation - 
	//A*x + B*y + C
	let a2 = y3-y2;
	let b2 = x2-x3;
	let c2 = (x3*y2) - (x2*y3);
	
	//  a1x*a2x + b1y*a2x - c1*a2x = 0
	//  a2x*a1x + b2y*a1x - c2*a1x = 0
	
	//   b1y*a2x - b2y*a1x   =  c1*a2x - c2*a1x
	//   yx( b1*a2 ) - yx(b2*a1)   =  x(c1*a2) - x(c2*a1)
	//   (c1*a2 - c2*a1)/(b1*a2 - b2*a1) = y
	
	let x = (c1*b2-c2*b1)/(a1*b2-a2*b1);
	let y = (c1*a2 - c2*a1)/(b1*a2 - b2*a1);
	
	if(min(x0,x1)<=x && x <= max(x0,x1) && min(y0,y1)<=y && y <= max(y0,y1)) {
		return [x,y];
	}else{
		return [NULL,NULL];
	}
}
