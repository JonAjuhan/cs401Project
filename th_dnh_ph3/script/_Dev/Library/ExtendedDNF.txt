

let FLAG_CHECKINFO = "Check";
let FLAG_DUMMY = "IsDummy";
let FLAG_XYMOVE = "UseXYSystem";
let FLAG_INTERSECTION = "IsIntersectionEnable";
let FLAG_SPELLRESIST = "IsSpellResist";
let SHOT_GRAPHIC = "Graphic";


let MOVE_POS = "Position";
let MOVE_X = "MoveX";
let MOVE_Y = "MoveY";
let MOVE_SPEED = "Speed";
let MOVE_ACCEL = "Acceleration";
let MOVE_MAXSPEED = "MaxSpeed";
let MOVE_JERK = "Jerk";
let MOVE_MAXACCEL = "MaxAcceleration";

let MOVE_ANGLE = "Angle";
let MOVE_ANGV = "AngularVelocity";
let MOVE_ANGACCEL = "AngularAcceleration";
let MOVE_MAXANGV = "MaxAngularVelocity";

let MOVE_XSPEED = "XSpeed";
let MOVE_YSPEED = "YSpeed";
let MOVE_XACCEL = "XAcceleration";
let MOVE_YACCEL = "YAcceleration";
let MOVE_XMAXSPEED = "XMaxSpeed";
let MOVE_YMAXSPEED = "YMaxSpeed";

let RENDER_ALPHA = "Alpha";
let RENDER_COLOR = "Color";
let RENDER_RCOL = "R";
let RENDER_GCOL = "G";
let RENDER_BCOL = "B";

let RENDER_POS = "RenderPosition";
let RENDER_X = "RenderX";
let RENDER_Y = "RenderY";
let RENDER_ANGLE = "AngleZ";
let RENDER_ANGLEX = "AngleX";
let RENDER_ANGLEY = "AngleY";
let RENDER_SCALE = "Scale"; //"overall" scale
let RENDER_SCALEX = "ScaleX";
let RENDER_SCALEY = "ScaleY";

let RENDER_PRIORITY = "RenderPriority";

let MOVE_Z = "MoveZ"; //experimental

let COL_RADIUS = "CollisionRadius";

//////////////////////////////////////////////////////////////////////////////
//Higher-order functions for generalizing functions to operate on any property
//////////////////////////////////////////////////////////////////////////////

function O_SetProperty(obj,k,v){
	if(O_GetType(v)==OBJ_NUMBER && v==NO_CHANGE){O_SetProperty(obj,k,O_GetProperty(obj,k));return;}
	alternative(k)
	case(FLAG_INTERSECTION){ Obj_SetValue(obj,FLAG_INTERSECTION,v); if(O_GetType(obj)==OBJ_SHOT){ObjShot_SetIntersectionEnable(obj,v);} }
	case(FLAG_SPELLRESIST){ Obj_SetValue(obj,FLAG_SPELLRESIST,v); if(O_GetType(obj)==OBJ_SHOT){ObjShot_SetSpellResist(obj,v);} }
	case(MOVE_POS){ if(O_GetType(v)==OBJ_ARRAY&&length(v)>1){ObjMove_SetX(obj,v[0]); ObjMove_SetY(obj,v[1]);} }
	case(MOVE_X){ ObjMove_SetX(obj,v); }
	case(MOVE_Y){ ObjMove_SetY(obj,v); }
	case(MOVE_SPEED){       OM_SetSpeed(obj,v); }
	case(MOVE_ACCEL){       OM_SetAcceleration(obj,v); }
	case(MOVE_MAXSPEED){    OM_SetMaxSpeed(obj,v); }
	case(MOVE_JERK){        OM_SetJerk(obj,v); }
	case(MOVE_MAXACCEL){    OM_SetMaxAcceleration(obj,v); }
	case(MOVE_ANGLE){       OM_SetAngle(obj,v); }
	case(MOVE_ANGV){        OM_SetAngularVelocity(obj,v); }
	case(MOVE_ANGACCEL){    OM_SetAngularAcceleration(obj,v); }
	case(MOVE_MAXANGV){     OM_SetMaxAngularVelocity(obj,v); }
	case(MOVE_XSPEED){      OM_SetSpeedX(obj,v); }
	case(MOVE_YSPEED){      OM_SetSpeedY(obj,v); }
	// case(MOVE_XACCEL){}
	// case(MOVE_YACCEL){}
	case(RENDER_ALPHA){     OR_SetAlpha(obj,v); }
	case(RENDER_COLOR){     OR_SetColor(obj,v[0],v[1],v[2]); }
	case(RENDER_RCOL){ let c = OR_GetColor(obj); OR_SetColor(obj,v   ,c[1],c[2]); }
	case(RENDER_GCOL){ let c = OR_GetColor(obj); OR_SetColor(obj,c[0],v   ,c[2]); }
	case(RENDER_BCOL){ let c = OR_GetColor(obj); OR_SetColor(obj,c[0],c[1],v   ); }
	case(RENDER_SCALE){     OR_SetScale(obj,v); }
	case(RENDER_SCALEX){    OR_SetScaleX(obj,v); }
	case(RENDER_SCALEY){    OR_SetScaleY(obj,v); }
	case(RENDER_ANGLE){  ObjRender_SetAngleZ(obj,v); } //todo
	case(RENDER_ANGLEX){ ObjRender_SetAngleX(obj,v); } //todo
	case(RENDER_ANGLEY){ ObjRender_SetAngleY(obj,v); } //todo
	case(RENDER_PRIORITY){ O_SetRenderPriorityI(obj,v); }
	case(MOVE_Z){ OM_SetZ(obj,v); }
}
function O_GetProperty(obj,k){
	let v;
	alternative(k)
	case(FLAG_INTERSECTION){ v = Obj_GetValueD(obj,FLAG_INTERSECTION,v); }
	case(FLAG_SPELLRESIST){ v = Obj_GetValueD(obj,FLAG_INTERSECTION,v); }
	case(MOVE_POS){ v = [ObjMove_GetX(obj), ObjMove_GetY(obj)]; }
	case(MOVE_X){ v = ObjMove_GetX(obj); }
	case(MOVE_Y){ v = ObjMove_GetY(obj); }
	case(MOVE_SPEED){        v = OM_GetSpeed(obj); }
	case(MOVE_ACCEL){        v = OM_GetAcceleration(obj); }
	case(MOVE_MAXSPEED){     v = OM_GetMaxSpeed(obj); }
	case(MOVE_JERK){         v = OM_GetJerk(obj); }
	case(MOVE_MAXACCEL){     v = OM_GetMaxAcceleration(obj); }
	case(MOVE_ANGLE){        v = OM_GetAngle(obj); }
	case(MOVE_ANGV){         v = OM_GetAngularVelocity(obj); }
	case(MOVE_ANGACCEL){     v = OM_GetAngularAcceleration(obj); }
	case(MOVE_MAXANGV){      v = OM_GetMaxAngularVelocity(obj); }
	case(MOVE_XSPEED){       v = OM_GetSpeedX(obj); }
	case(MOVE_YSPEED){       v = OM_GetSpeedY(obj); }
	// case(MOVE_XACCEL){}
	// case(MOVE_YACCEL){}
	case(RENDER_ALPHA){      v = OR_GetAlpha(obj); }
	case(RENDER_COLOR){      v = OR_GetColor(obj); }
	case(RENDER_RCOL){       v = OR_GetColor(obj)[0]; }
	case(RENDER_GCOL){       v = OR_GetColor(obj)[1]; }
	case(RENDER_BCOL){       v = OR_GetColor(obj)[2]; }
	case(RENDER_SCALE){      v = OR_GetScale(obj); }
	case(RENDER_SCALEX){     v = OR_GetScaleX(obj); }
	case(RENDER_SCALEY){     v = OR_GetScaleY(obj); }
	case(RENDER_ANGLE){  v = ObjRender_GetAngleZ(obj); }
	case(RENDER_ANGLEX){ v = ObjRender_GetAngleX(obj); }
	case(RENDER_ANGLEY){ v = ObjRender_GetAngleY(obj); }
	case(RENDER_PRIORITY){   v = O_GetRenderPriorityI(obj); }
	case(MOVE_Z){ v = OM_GetZ(obj); }
	others{v=NULL;}
	
	return v;
}

let PROP_VALUE = 0;     let PROP_RVALUE = 10;
let PROP_SPEED = 1;     let PROP_RSPEED = 11;
let PROP_ACCEL = 2;     let PROP_RACCEL = 12;
let PROP_MAXSPEED = 3;  let PROP_RMAXSPEED = 13;
let PROP_JERK = 4;      let PROP_RJERK = 14;
let PROP_MAXACCEL = 5;  let PROP_RMAXACCEL = 15;

//Given the name of a property, get the name of another property in that "set" of properties
//e.g. GetRelatedProperty(MOVE_ANGLE,PROP_ACCEL) returns MOVE_ANGACCEL
function GetRelatedProperty(key,relation){
	let rels;
	alternative(key)
	case(MOVE_POS,MOVE_SPEED,MOVE_ACCEL,MOVE_MAXSPEED,MOVE_JERK,MOVE_MAXACCEL){
		rels = [MOVE_POS,MOVE_SPEED,MOVE_ACCEL,MOVE_MAXSPEED,MOVE_JERK,MOVE_MAXACCEL];
	}
	case(MOVE_ANGLE,MOVE_ANGV,MOVE_ANGACCEL,MOVE_MAXANGV){
		rels = [MOVE_ANGLE,MOVE_ANGV,MOVE_ANGACCEL,MOVE_MAXANGV];
	}
	case(MOVE_X,MOVE_XSPEED,MOVE_XACCEL,MOVE_XMAXSPEED){ rels = [MOVE_X,MOVE_XSPEED,MOVE_XACCEL,MOVE_XMAXSPEED]; }
	case(MOVE_Y,MOVE_YSPEED,MOVE_YACCEL,MOVE_YMAXSPEED){ rels = [MOVE_Y,MOVE_YSPEED,MOVE_YACCEL,MOVE_YMAXSPEED]; }
	others{ rels=[]; }
	
	if(relation < length(rels) && relation >= 0){
		return rels[relation];
	}else if((|relation|)-PROP_RVALUE < length(rels) && (|relation|)-PROP_RVALUE > 0){
		let i=0; while(i<length(rels) && rels[i]!=key){i++;}
		let off = ((|relation|)-10)*sign(relation);
		if(0<=i+off&&i+off<length(rels)){
			return rels[i+off];
		}else{return key~itoa(relation);}
	}else{
		return "";
	}
}
//Get the names of any properties which are components of the given property.
function GetSubProperty(key,index){
	let rels;
	alternative(key)
	case(MOVE_POS){ rels = [MOVE_X,MOVE_Y]; }
	case(RENDER_POS){ rels = [RENDER_X,RENDER_Y]; }
	case(RENDER_COLOR){ rels = [RENDER_RCOL,RENDER_GCOL,RENDER_BCOL,RENDER_ALPHA]; }
	others{ rels=[]; }
	
	if(index < length(rels)){
		return rels[index];
	}else{
		return "";
	}
}
//Check if a property is stored as an array.
function Prop_IsArray(k){
	alternative(k)
	case(MOVE_POS,RENDER_POS,RENDER_COLOR){return true;}
	others{return false;}
}

function OProp_CheckNoChange(obj,k,v){ //fucky atm
	if(v>NO_CHANGE){ return v;}
	else{
		return O_GetProperty(obj,k);
	}
}


//---------------------

task O_AddPropertyPatternA1(obj,del,k_val,s){
	wait(del);
	let v = O_GetProperty(obj,k_val);
	let k_spd = GetRelatedProperty(k_val,PROP_RSPEED);
	s=OProp_CheckNoChange(obj,k_spd,s);
	O_SetProperty(obj,k_spd,s);
	while(!Obj_IsDeleted(obj) && O_GetProperty(obj,k_val)==v){
		v+=s;
		O_SetProperty(obj,k_val,v);
		yield;
	}
}
task O_AddPropertyPatternA2(obj,del,k_val,s,a,ms){
	wait(del);
	let v = O_GetProperty(obj,k_val);
	let k_spd = GetRelatedProperty(k_val,PROP_RSPEED);   if(k_spd!=""){ s =OProp_CheckNoChange(obj,k_spd,s); }
	let k_acc = GetRelatedProperty(k_val,PROP_RACCEL);   if(k_acc!=""){ a =OProp_CheckNoChange(obj,k_acc,a); }
	let k_msp = GetRelatedProperty(k_val,PROP_MAXSPEED); if(k_msp!=""){ ms=OProp_CheckNoChange(obj,k_msp,ms); }
	O_SetProperty(obj,k_msp,ms);
	while(!Obj_IsDeleted(obj) && O_GetProperty(obj,k_val)==v){
		s+=a;
		if(s*a > ms*a && ms!=0){ s=ms; break; }
		v+=s;
		O_SetProperty(obj,k_val,v);
		O_SetProperty(obj,k_spd,s);
		yield;
	}
	O_SetProperty(obj,k_val,v);
	O_SetProperty(obj,k_spd,s);
}


task O_SetPropertyAtFrame(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtFrame(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(t in 0..frame){
		O_SetProperty(obj,k,v0+dv*t);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtDelay(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtDelay(obj,GetSubProperty(k,i),v[i],frame);}return;}
	wait(frame);
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtAccel(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtAccel(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(i in 0..frame){
		let t = i/frame;
		let vt = (v * t^2) + (v0 * (1-t^2));
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtDecel(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtDecel(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(i in 0..frame){
		let t = i/frame;		
		let u = 1-(1-t^2)*(1-t^2);
		let vt = v*u + v0*(1-u);
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtWeight(obj,k,v,frame,weight){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtWeight(obj,GetSubProperty(k,i),v[i],frame,weight);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	let isaccel = weight<0; if(isaccel){weight=(|weight|);}
	weight=weight^0.75;
	ascent(i in 0..frame){
		let t = i/frame;
		let m; let vt;
		if(!isaccel){
			m = 1 - (1-t)^(0.5*(weight^0.5));
			vt = v*m + v0*(1-m);
		}else{
			m = t^weight;
			vt = v0+dv*i*m;
		}
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}



//////////////////////////////////////////////////////////////////
//Object Functions
//////////////////////////////////////////////////////////////////

//Primitive types
let OBJ_INT = 9;
let OBJ_REAL = 2; let OBJ_NUMBER = 2;
let OBJ_BOOL = 2+10;
let OBJ_CHAR = -1;
let OBJ_ARRAY = 10;
let OBJ_STRING = 10+1;

function O_GetType(obj){
	alternative(Obj_GetType(obj))
	case(OBJ_INT){return OBJ_NUMBER;}
	case(OBJ_REAL){
		if(ToString(obj)=="true"||ToString(obj)=="false"){return OBJ_BOOL;}
		else{ return OBJ_NUMBER; }
	}
	case(OBJ_ARRAY){
		if(length(obj) > 0){
			let contents = O_GetType(obj[0]); //recursive
			if(contents==OBJ_CHAR){return OBJ_STRING;}
			else{return OBJ_ARRAY;}
		}else{return OBJ_ARRAY;}
	}
	case(OBJ_CHAR){return OBJ_CHAR;}
	case(OBJ_SHOT){return OBJ_SHOT;} //106
	case(OBJ_ENEMY,OBJ_ENEMY_BOSS){return OBJ_ENEMY;}
	others{return Obj_GetType(obj);}
}





//MISC

function ObjEnemy_GetLife(enemy){ return ObjEnemy_GetInfo(enemy,INFO_LIFE); }

let TYPE_ENEMY = 9000; let TYPE_FAM = 9001; let TYPE_DIE = 8000;
function DeleteEnemyAll(enetype,deletetype){
	let enems = GetAllEnemyID;
	ascent(i in 0..length(enems)){
		let ene = enems[i];
		if(Obj_GetType(ene)!=OBJ_ENEMY_BOSS || enetype==TYPE_ALL){
			if(enetype!=TYPE_FAM || Obj_GetValueD(ene,"IsFam",false)){
				alternative(deletetype)
				case(TYPE_IMMEDIATE){ Obj_Delete(ene); }
				case(TYPE_DIE){ ObjEnemy_SetLife(ene,0); }
				case(TYPE_FADE){ Obj_FadeDelete(ene); }
				case(TYPE_ITEM){
					// ItemExplode(ObjMove_GetX(ene),ObjMove_GetY(ene),trunc(ObjEnemy_GetLife(ene)/50));
					let x = ObjMove_GetX(ene); let y = ObjMove_GetY(ene);
					let n = trunc(ObjEnemy_GetLife(ene)/50);
					let r = max(48, 48*(360/n)/120);
					loop(n){
						let a = rand(0,360);
						let d = rand(r/2,r);
						NotifyEvent(GetCommonData("ItemScriptID",NULL),EV_SPAWN_ITEM,
						  [I_CANCEL,x,y,x+d*cos(a),y+d*sin(a),0]);
					}
					
					ObjEnemy_SetLife(ene,0);
				}
			}
		}
	}
}


//////////////////////////////////////////////////////////////////
// Render Object Functions
//////////////////////////////////////////////////////////////////






//Andi - COLOR/ALPHA FUNCTIONS
//Set an object's alpha or RGB, depending on blend type.
//Efficient. Always use this to ensure alpha is accessible by other functions.
function OR_SetAlpha(obj, alpha){
	Obj_SetValue(obj, RENDER_ALPHA, alpha);
	let C; let R; let G; let B; let A;
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ADD_RGB,BLEND_SUBTRACT,BLEND_MULTIPLY,BLEND_SHADOW){
		C = Obj_GetValueD(obj,RENDER_COLOR,[255,255,255]);
		R = Obj_GetValueD(obj,"R",C[0]);
		G = Obj_GetValueD(obj,"G",C[1]);
		B = Obj_GetValueD(obj,"B",C[2]);
		A = alpha/255;
		Obj_SetValue(obj,RENDER_COLOR,[R,G,B,alpha]);
	}
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ALPHA)   {ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_ARGB){ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_RGB) {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SUBTRACT){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_MULTIPLY){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SHADOW)  {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	others{ObjRender_SetAlpha(obj, alpha);}
}
function ObjRender_SetTrueAlpha(obj,alpha){ OR_SetAlpha(obj,alpha); }
//Set color such that it is accessible by other functions.
//Efficient. Always use one of these. 
function OR_SetColor(obj,r,g,b){
	ObjRender_SetColor(obj,r,g,b);
	Obj_SetValue(obj,"R",r);
	Obj_SetValue(obj,"G",g);
	Obj_SetValue(obj,"B",b);
	Obj_SetValue(obj,RENDER_COLOR,[r,g,b]);
}
function OR_SetColorRGB(obj,r,g,b){ OR_SetColor(obj,r,g,b); }
function OR_SetColorRGBA(obj,r,g,b,a){
	OR_SetColor(obj,r,g,b);
	OR_SetAlpha(obj,a);
	Obj_SetValue(obj,RENDER_COLOR,[r,g,b,a]);
}
function ObjRender_SetTrueColor(obj,r,g,b){ OR_SetColor(obj,r,g,b); }

//Attempt to compensate for the lack of such functions.
//Efficient as long as value was properly stored, or after the first time.
function OR_GetAlpha(obj){
	if(Obj_IsValueExists(obj,RENDER_ALPHA)){return Obj_GetValue(obj,RENDER_ALPHA);}
	else{
		let C = Obj_GetValueD(obj,RENDER_COLOR,[255,255,255]);
		if(length(C) > 3){ Obj_SetValue(obj,RENDER_ALPHA,C[3]); return C[3]; }
		let A = Obj_GetValueD(obj,RENDER_ALPHA,-1);
		if(A!=-1){ return A;}
		let R = Obj_GetValueD(obj,"R",C[0]); 
		let G = Obj_GetValueD(obj,"G",C[1]); 
		let B = Obj_GetValueD(obj,"B",C[2]);
		A = max(R,max(G,B)); //Use the largest RGB value
		Obj_SetValue(obj,RENDER_ALPHA,A); Obj_SetValue(obj,"A",A);
		Obj_SetValue(obj,RENDER_COLOR,[R,G,B,A]);
		return A;
	}
}
function OR_GetColor(obj){ return Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]); }
function OR_GetColorRGB(obj){return Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);}
function OR_GetColorRGBA(obj){
	let C = Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);
	let A = OR_GetAlpha(obj);
	return C ~ [A];
}
function ObjRender_GetAlpha(obj){return OR_GetAlpha(obj);}

function OR_AddAlpha(obj,dA){
	OR_SetAlpha(obj,OR_GetAlpha(obj)+dA);
}
task OR_SetAlphaAtFrame(obj,a1,time){
	let a0   = ObjRender_GetAlpha(obj);
	let dA   = (a1-a0)/time;
	ascent(i in 0..time){
		OR_SetAlpha(obj,a0+dA*i);
		yield;
	}
}

function OR_AddScaleXYZ(obj,dX,dY,dZ){ ObjRender_SetScaleXYZ(obj,ObjRender_GetScaleX(obj)+dX,ObjRender_GetScaleY(obj)+dY,ObjRender_GetScaleZ(obj)+dZ); }
task OR_SetScaleAtFrame(obj,sx1,sy1,time){
	let sx0   = ObjRender_GetScaleX(obj);
	let sy0   = ObjRender_GetScaleY(obj);
	let dsx   = (sx1-sx0)/time;
	let dsy   = (sy1-sy0)/time;
	ascent(i in 0..time){
		ObjRender_SetScaleXYZ(obj,sx0+dsx*i,sy0+dsy*i,1);
		yield;
	}
}

//set "overall" scale - needs testing
function OR_SetScale(obj,scale){
	let sclx = ObjRender_GetScaleX(obj);
	let scly = ObjRender_GetScaleY(obj);
	let ratio = (|sclx/scly|);
	ObjRender_SetScaleXYZ(obj,scale*ratio*sign(sclx),scale/ratio*sign(scly),ObjRender_GetScaleZ(obj));
	Obj_SetValue(obj,RENDER_SCALE,scale);
	return scale;
}
function OR_GetScale(obj){
	let scale = Obj_GetValueD(obj,RENDER_SCALE,NULL);
	if(scale==NULL){
		let sclx = OR_GetScaleX(obj);
		let scly = OR_GetScaleY(obj);
		scale = ((|sclx|)+(|scly|))/2;
	}
	return scale;
}
function OR_SetScaleX(obj,scalex){
	ObjRender_SetScaleX(obj,scalex);
	Obj_SetValue(obj,RENDER_SCALEX,scalex);
}
function OR_GetScaleX(obj){return Obj_GetValueD(obj,RENDER_SCALEX,ObjRender_GetScaleX(obj));}

function OR_SetScaleY(obj,scaley){
	ObjRender_SetScaleY(obj,scaley);
	Obj_SetValue(obj,RENDER_SCALEY,scaley);
}
function OR_GetScaleY(obj){return Obj_GetValueD(obj,RENDER_SCALEY,ObjRender_GetScaleY(obj));}


function OR_GetX(obj){return ObjRender_GetX(obj);}
function OR_GetY(obj){return ObjRender_GetY(obj);}
function OR_SetX(obj,v){ObjRender_SetX(obj,v);}
function OR_SetY(obj,v){ObjRender_SetY(obj,v);}



task Obj_FadeDelete(obj) {
	let a0   = Obj_GetValueD(obj,RENDER_ALPHA,255);
	let time = Obj_GetValueD(obj,"FadeTime",60);
	let dA   = a0/time;
	descent(i in 0..time){
		OR_SetAlpha(obj,dA*i);
		yield;
	}
	Obj_Delete(obj);
}


function O_SetRenderPriorityI(obj,v){
	Obj_SetRenderPriorityI(obj,v);
	Obj_SetValue(obj,RENDER_PRIORITY,v);
}
function O_GetRenderPriorityI(obj){
	if(Obj_IsValueExists(obj,RENDER_PRIORITY)){
		return Obj_GetValue(obj,RENDER_PRIORITY);
	}else{
		return Obj_GetRenderPriorityI(obj);
	}
}

function O_SetRenderPriority(obj,v){
	Obj_SetRenderPriority(obj,v);
	Obj_SetValue(obj,RENDER_PRIORITY,v*100);
}
function O_GetRenderPriority(obj){
	if(Obj_IsValueExists(obj,RENDER_PRIORITY)){
		return Obj_GetValue(obj,RENDER_PRIORITY)/100;
	}else{
		return Obj_GetRenderPriority(obj);
	}
}




/////////////////////////////////////////////////////////////////
// Shot Functions
/////////////////////////////////////////////////////////////////



function PrepareShotA1(x,y,s,a,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	ObjMove_SetPosition(shot,x,y);
	ObjMove_SetSpeed(shot,s);
	ObjMove_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,graph);
	return shot;
}
function PrepareShotA2(x,y,s,a,acc,mspd,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	ObjMove_SetPosition(shot,x,y);
	ObjMove_SetSpeed(shot,s);
	ObjMove_SetAngle(shot,a);
	ObjMove_SetAcceleration(shot,acc);
	ObjMove_SetMaxSpeed(shot,mspd);
	ObjShot_SetGraphic(shot,graph);
	Obj_SetValue(shot,"Acceleration",acc); Obj_SetValue(shot,"MaxSpeed",mspd);
	return shot;
}



//if a shot is too close to the player, don't create it after all
//30 is a good radius
function CheckShot(shot,r){
	if(getdistance(ObjMove_GetX(shot),ObjMove_GetY(shot),px,py) <= r){
		let shot2 = CreateShotA1(ObjMove_GetX(shot),ObjMove_GetY(shot),0,0,ObjShot_GetImageID(shot),10);
		ObjRender_SetAlpha(shot2,128);
		ObjShot_SetDeleteFrame(shot2,0);
		ObjShot_SetDeleteFrame(shot,0);
	}
}


////////////////////////////////////////////////////////////////////
// Shot Object Functions
////////////////////////////////////////////////////////////////////

//Andi - Copy a shot as best as I could manage
//Things without getters need to be noted in the shot's dictionary to be used
function CopyShot(shot){
	if(Obj_IsDeleted(shot)){return NULL;}
		
	let x = ObjMove_GetX(shot);
	let y = ObjMove_GetY(shot);
	let spd = ObjMove_GetSpeed(shot);
	let ang = ObjMove_GetAngle(shot);
	let graph = ObjShot_GetImageID(shot);
	
	let acc  = O_GetProperty(shot,MOVE_ACCEL);
	let angv = O_GetProperty(shot,MOVE_ANGV);
	let mspd = Obj_GetValueD(shot,MOVE_MAXSPEED,9999);
	
	let spellresist = ObjShot_IsSpellResist(shot);
	let intersect = Obj_GetValueD(shot,FLAG_INTERSECTION,true);
	let scalexyz = [ObjRender_GetScaleX(shot),ObjRender_GetScaleY(shot),ObjRender_GetScaleZ(shot)];
	let blendtype = ObjRender_GetBlendType(shot);
	let color = OR_GetColor(shot);
	let alpha = OR_GetAlpha(shot);	
	
	let cpy=NULL; 
	if(Obj_GetType(shot)==OBJ_SHOT){
		cpy = CreateShotA1(x,y,spd,ang,graph,0);
	}else{
		let length = ObjLaser_GetLength(shot);
		let width = Obj_GetValueD(shot,"Width",15);
		let dur = Obj_GetValueD(shot,"Duration",30);
		let del = Obj_GetValueD(shot,"Delay",tern(Obj_GetType(shot)==OBJ_STRAIGHT_LASER, 15, 0));
		if(Obj_GetType(shot)==OBJ_LOOSE_LASER){ cpy = CreateLooseLaserA1(x,y,spd,ang, length, width, graph, del); }else
		if(Obj_GetType(shot)==OBJ_STRAIGHT_LASER){ cpy = CreateStraightLaserA1(x,y,ang,length,width, dur, graph, del); }else
		if(Obj_GetType(shot)==OBJ_CURVE_LASER){ cpy = CreateCurveLaserA1(x,y,spd,ang, length, width, graph, del); }
	}
	
	OM_AddPatternA3(shot,0,spd,ang,acc,angv,mspd,graph);
		
	ObjRender_SetBlendType(cpy, blendtype);
	OR_SetColor(cpy,color[0],color[1],color[2]);
	OR_SetAlpha(cpy,alpha);
	ObjRender_SetScaleXYZ(cpy, scalexyz[0],scalexyz[1],scalexyz[2]);
	
	ObjShot_SetSpellResist(cpy,spellresist);
	ObjShot_SetIntersectionEnable(cpy,intersect);	
	Obj_SetRenderPriority(cpy,Obj_GetRenderPriority(shot));
		
	Obj_SetValue(cpy,FLAG_INTERSECTION,intersect);
	
	return cpy;
}

function ObjShot_Delete(shot){ObjShot_SetDeleteFrame(shot,0);}



function OS_GetDelayColor(shot) {
	if(isnull(shot)){return [0,0,0];}
	return GetShotDataInfoA1(ObjShot_GetImageID(shot),TARGET_ENEMY,INFO_DELAY_COLOR);
}

function OS_GetCollisionRadius(shot) {
	if(isnull(shot)){return 0;}
	let base = GetShotDataInfoA1(max(1,ObjShot_GetImageID(shot)),TARGET_ENEMY,INFO_COLLISION);
	let scl = OR_GetScale(shot);
	return base*scl;
}



//////////////////////////////////////////////////////////////////////
// Move Object Functions
//////////////////////////////////////////////////////////////////////



//for moving shit what don't do ObjMove
task Obj_AddPatternA1(obj,fr,s,a){
	wait(fr);
	Obj_SetValue(obj,"Speed",s);
	Obj_SetValue(obj,"Angle",a);
	ObjRender_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Speed",s)==s && Obj_GetValueD(obj,"Angle",a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
	}
}
task Obj_AddPatternA2(obj,fr,s,a,acc,mspd){
	wait(fr);
	Obj_SetValue(obj,"Speed",s);
	Obj_SetValue(obj,"Angle",a);
	Obj_SetValue(obj,"Acceleration",acc);
	Obj_SetValue(obj,"MaxSpeed",mspd);
	let isDecel = (acc<0);
	ObjRender_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Speed",s)==s && Obj_GetValueD(obj,"Angle",a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
		s+=acc;
		alternative(isDecel)
		case(true) {s=max(s,mspd);}
		case(false){s=min(s,mspd);}
		Obj_SetValue(obj,"Speed",s);
		dx = s*cos(a); dy = s*sin(a);
	}
}





task OM_SetAngularAcceleration(obj,anga){
	Obj_SetValue(obj,MOVE_ANGACCEL,anga);
	let angv = Obj_GetValueD(obj,MOVE_ANGV,0);
	let mangv = Obj_GetValueD(obj,MOVE_MAXANGV,0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,MOVE_ANGACCEL,0)==anga ){
		angv = Obj_GetValueD(obj,MOVE_ANGV,0);
		mangv = Obj_GetValueD(obj,MOVE_MAXANGV,0);
		if( (|angv|) < (|mangv|) || sign(mangv-angv) == sign(anga) ){
			angv += anga;
			ObjMove_SetAngularVelocity(obj,angv);
			Obj_SetValue(obj,MOVE_MAXANGV,angv);
		}else{
			ObjMove_SetAngularVelocity(obj,mangv);
			Obj_SetValue(obj,MOVE_ANGV,mangv);
			return;
		}
		yield;
	}
}
function OM_SetMaxAngularVelocity(obj,mangv){ Obj_SetValue(obj,MOVE_MAXANGV,mangv); }
function OM_GetAngularAcceleration(obj){ Obj_GetValueD(obj,MOVE_ANGACCEL,0); }
function OM_GetMaxAngularVelocity(obj){ Obj_GetValueD(obj,MOVE_MAXANGV,0); }


task OM_SetJerk(obj,jerk){
	Obj_SetValue(obj,MOVE_JERK,jerk);
	let acc = Obj_GetValueD(obj,MOVE_ACCEL,0);
	let macc = Obj_GetValueD(obj,MOVE_MAXACCEL,0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,MOVE_ACCEL,0)==acc ){
		acc = Obj_GetValueD(obj,MOVE_ACCEL,0);
		macc = Obj_GetValueD(obj,MOVE_MAXACCEL,0);
		// if( (|acc|) < (|macc|) || sign(macc-acc) == sign(jerk) ){
		// if( inrange(acc,0,(|macc|)*sign(jerk)) ){
		// if( inrange(acc,99-99*sign(jerk),(|macc|)*sign(jerk)) ){
		// if( (|acc+999|) < (|macc+999|) || sign(macc-acc) == sign(jerk) ){
		if( isapproaching(acc,jerk,macc) ){
			acc += jerk;
			ObjMove_SetAcceleration(obj,acc);
			Obj_SetValue(obj,MOVE_ACCEL,acc);
		}else{
			ObjMove_SetAcceleration(obj,macc);
			Obj_SetValue(obj,MOVE_ACCEL,macc);
			return;
		}
		yield;
	}
}
function OM_SetMaxAcceleration(obj,macc){ Obj_SetValue(obj,MOVE_MAXACCEL,macc); }

function OM_GetJerk(obj){ return Obj_GetValueD(obj,MOVE_JERK,0); }
function OM_GetMaxAcceleration(obj){ return Obj_GetValueD(obj,MOVE_MAXACCEL,9999); }







task OR_SetAngularVelocity(obj,da){
	Obj_SetValue(obj,"RenderAngularVelocity",da);
	if(da==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocity",0)==da){
		ObjRender_SetAngleZ(obj,ObjRender_GetAngleZ(obj)+da);
		yield;
	}
}
task OR_SetAngularVelocityXYZ(obj,dxa,dya,dza){
	Obj_SetValue(obj,"RenderAngularVelocityXYZ",[dxa,dya,dza]);
	if(dxa==0&&dya==0&&dza==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocityXYZ",[0,0,0])==[dxa,dya,dza]){
		ObjRender_SetAngleXYZ(obj,ObjRender_GetAngleX(obj)+dxa,ObjRender_GetAngleY(obj)+dya,ObjRender_GetAngleZ(obj)+dza);
		yield;
	}
}




function OM_SetSpeed(obj,val){
	ObjMove_SetSpeed(obj,val);
	Obj_SetValue(obj,MOVE_SPEED,val);
	Obj_SetValue(obj,FLAG_XYMOVE,false);
}
function OM_GetSpeed(obj){let s = ObjMove_GetSpeed(obj); if(s==0){s=Obj_GetValueD(obj,MOVE_SPEED,0);return s;} }
function OM_SetAngle(obj,val){
	ObjMove_SetAngle(obj,val);
	Obj_SetValue(obj,MOVE_ANGLE,val);
	Obj_SetValue(obj,FLAG_XYMOVE,false);
}
function OM_GetAngle(obj){return ObjMove_GetAngle(obj);}
function OM_SetAcceleration(obj,val){
	ObjMove_SetAcceleration(obj,val);
	Obj_SetValue(obj,MOVE_ACCEL,val);
}
function OM_GetAcceleration(obj){return Obj_GetValueD(obj,MOVE_ACCEL,0);}
function OM_SetMaxSpeed(obj,val){
	ObjMove_SetMaxSpeed(obj,val);
	Obj_SetValue(obj,MOVE_MAXSPEED,val);
}
function OM_GetMaxSpeed(obj){return Obj_GetValueD(obj,MOVE_MAXSPEED,99);}
function OM_SetAngularVelocity(obj,val){
	ObjMove_SetAngularVelocity(obj,val);
	Obj_SetValue(obj,MOVE_ANGV,val);
}
function OM_GetAngularVelocity(obj){return Obj_GetValueD(obj,MOVE_ANGV,0);}





//Add pattern and store parameters in the object's dictionary
function OM_AddPatternA1(obj,del,spd,ang){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	ObjMove_AddPatternA1(obj,del,spd,ang);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
	}
}

function OM_AddPatternA2(obj,del,spd,ang,acc,angv,mspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
	}
}

function OM_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternGraphic",graph);
	ObjMove_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
		Obj_SetValue(obj,SHOT_GRAPHIC,graph);
	}
}






function OM_AddPatternA5(obj,del,spd,ang,acc,angv,mspd,jerk,macc,anga,mangv){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternJerk",jerk);
	Obj_SetValue(obj,"PatternMaxAcceleration",macc);
	Obj_SetValue(obj,"PatternAngularAcceleration",anga);
	Obj_SetValue(obj,"PatternMaxAngularVelocity",mangv);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
		Obj_SetValue(obj,MOVE_JERK,jerk);
		Obj_SetValue(obj,MOVE_MAXACCEL,macc);
		Obj_SetValue(obj,MOVE_ANGACCEL,anga);
		Obj_SetValue(obj,MOVE_MAXANGV,mangv);
		OM_SetJerk(obj,jerk);
		OM_SetAngularAcceleration(obj,anga);
	}
}




function OM_AddPatternB1(obj,del,xspd,yspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	ObjMove_AddPatternB1(obj,del,xspd,yspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,FLAG_XYMOVE,true);
		Obj_SetValue(obj,MOVE_XSPEED,xspd);
		Obj_SetValue(obj,MOVE_YSPEED,yspd);
	}
}
function OM_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	Obj_SetValue(obj,"PatternXAcceleration",xacc);
	Obj_SetValue(obj,"PatternYAcceleration",yacc);
	Obj_SetValue(obj,"PatternXMaxSpeed",xmspd);
	Obj_SetValue(obj,"PatternYMaxSpeed",ymspd);
	ObjMove_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,FLAG_XYMOVE,true);
		Obj_SetValue(obj,MOVE_XSPEED,xspd);
		Obj_SetValue(obj,MOVE_YSPEED,yspd);
		Obj_SetValue(obj,MOVE_XACCEL,xacc);
		Obj_SetValue(obj,MOVE_YACCEL,yacc);
		Obj_SetValue(obj,MOVE_XMAXSPEED,xmspd);
		Obj_SetValue(obj,MOVE_YMAXSPEED,ymspd);
	}
}


function OM_GetX(obj){return ObjMove_GetX(obj);}
function OM_GetY(obj){return ObjMove_GetY(obj);}
function OM_GetA(obj){return ObjMove_GetAngle(obj);}
function OM_SetX(obj,v){ObjMove_SetX(obj,v);}
function OM_SetY(obj,v){ObjMove_SetY(obj,v);}
function OM_SetA(obj){return ObjMove_GetAngle(obj);}

function OM_SetSpeedX(obj,s){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_XSPEED,s);
	// ObjMove_AddPatternB1(obj,0,s,OM_GetSpeedY(obj));
	ObjMove_AddPatternB1(obj,0,s,NO_CHANGE);
}
function OM_SetSpeedY(obj,s){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_YSPEED,s);
	// ObjMove_AddPatternB1(obj,0,OM_GetSpeedX(obj),s);
	ObjMove_AddPatternB1(obj,0,NO_CHANGE,s);
}
function OM_GetSpeedX(obj){return Obj_GetValueD(obj,MOVE_XSPEED,OM_GetSpeed(obj)*cos(ObjMove_GetAngle(obj)));}
function OM_GetSpeedY(obj){return Obj_GetValueD(obj,MOVE_YSPEED,OM_GetSpeed(obj)*sin(ObjMove_GetAngle(obj)));}




task OM_Still(obj,time){
	ObjMove_SetAcceleration(obj,0);
	let s0 = ObjMove_GetSpeed(obj);
	let dS = s0/time;
	descent(i in 0..time){
		ObjMove_SetSpeed(obj,dS*i);
		yield;
	}
	ObjMove_SetAngularVelocity(obj,0);
}
function ObjMove_Still(obj,time){OM_Still(obj,time);}










//Simulate 3D position for 2D objects
//Z=0: normal plane; Z=100: fully receded; Z=-100: fully proceded
//Intentionally don't store new values, so "true" ones remain stored
let sz=400;
function OM_SetZ(obj,z){
	Obj_SetValue(obj,MOVE_Z,z);
	let t = z/sz; //-1..0..1 //t=0 when normal, t->1 in bg, t->-1 in fg
	let c = OR_GetColor(obj);
	let r = c[0]/2+128; let g = c[1]/2+128; let b = c[2]/2+128;
	let Sx = Obj_GetValueD(obj,RENDER_SCALEX,1);
	let Sy = Obj_GetValueD(obj,RENDER_SCALEY,1);
	let A = OR_GetAlpha(obj);
	
	let pri = O_GetRenderPriorityI(obj);
	if(!Obj_IsValueExists(obj,RENDER_PRIORITY)){
		Obj_SetValue(obj,RENDER_PRIORITY,pri);
	}
	Obj_SetRenderPriorityI(obj,pri-10*t);
	
	ObjRender_SetColor(obj, r-r/2*t, g-g/2*t, b-b/2*t );
	// ObjRender_SetColor(obj, r-r/2*(|t|), g-g/2*(|t|), b-b/2*(|t|) );
	if(z>=0){
		ObjRender_SetAlpha(obj, A-A/2*(|t|));
		ObjRender_SetScaleXYZ(obj,Sx*(|1-t|),Sy*(|1-t|),1);
	}else{
		// ObjRender_SetAlpha(obj, A-A*2*(|t|)^0.5);
		// ObjRender_SetScaleXYZ(obj,Sx*(1+(|t|)^0.25),Sy*(1+(|t|)^0.25),1);
		ObjRender_SetAlpha(obj, A-A*5*(|t/10|)^0.5);
		ObjRender_SetScaleXYZ(obj,Sx*(1+(|t|)^0.25),Sy*(1+(|t|)^0.25),1);
	}
	
	
	// let collide = (|z|) <= OC_GetIntersectionRadius(obj);
	if(O_GetType(obj)==OBJ_SHOT){
		let collide = ( Obj_GetValueD(obj,FLAG_INTERSECTION,true) && ((|z|)<=OC_GetIntersectionRadius(obj)) );
		ObjShot_SetIntersectionEnable(obj,collide);
	}else{ 
		OC_SetIntersectionEnable(obj, (|z|)<=OC_GetIntersectionRadius(obj) );
	}
	
}

function OM_GetZ(obj){
	return Obj_GetValueD(obj,MOVE_Z,0);
}









//////////////////////////////////////////////////////////////////
// Laser Object Functions
//////////////////////////////////////////////////////////////////

task ObjStLaser_SetAngularVelocity(las,angv){
	Obj_SetValue(las,"AngularVelocity",angv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularVelocity",angv)==angv){
		ObjStLaser_SetAngle(las,ObjStLaser_GetAngle(las)+angv);
		yield;
	}
}
task ObjStLaser_SetAngularAcceleration(las,anga){
	Obj_SetValue(las,"AngularAcceleration",anga);
	let angv = Obj_GetValueD(las,"AngularVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularAcceleration",0)==anga ){
		angv = Obj_GetValueD(las,"AngularVelocity",0);
		if( (|angv|) < (|Obj_GetValueD(las,"MaxAngularVelocity",3)|) ){
			ObjStLaser_SetAngularVelocity(las,angv+anga);
			Obj_SetValue(las,"AngularVelocity",angv+anga);
		}
		yield;
	}
}
function ObjStLaser_SetMaxAngularVelocity(las,mangv){OM_SetMaxAngularVelocity(las,mangv);}

function ObjStLaser_SetTipPosition(las,x,y){
	let x0 = ObjMove_GetX(las);	let y0 = ObjMove_GetY(las);
	let len = getdistance(x0,y0,x,y);
	let ang = getangle(x0,y0,x,y);
	ObjLaser_SetLength(las,len);
	ObjStLaser_SetAngle(las,ang);
}

task ObjLaser_SetExtendVelocity(las,extv){
	Obj_SetValue(las,"ExtendVelocity",extv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendVelocity",0)==extv && Obj_GetValueD(las,"MaxExtendLength",0)>=ObjLaser_GetLength(las)){
		ObjLaser_SetLength(las,ObjLaser_GetLength(las)+extv);
		yield;
	}
}
task ObjLaser_SetExtendAcceleration(las,exta){
	Obj_SetValue(las,"ExtendAcceleration",exta);
	let extv = Obj_GetValueD(las,"ExtendVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendAcceleration",0)==exta ){
		extv = Obj_GetValueD(las,"ExtendVelocity",0);
		if( (|extv|) < (|Obj_GetValueD(las,"MaxExtendVelocity",2)|) ){
			ObjLaser_SetExtendVelocity(las,extv+exta);
			Obj_SetValue(las,"ExtendVelocity",extv+exta);
		}
		yield;
	}
}
function ObjLaser_SetMaxExtendVelocity(las,mextv){
	Obj_SetValue(las,"MaxExtendVelocity",mextv);
}
function ObjLaser_SetMaxExtendLength(las,mextl){
	Obj_SetValue(las,"MaxExtendLength",mextl);
}

task ObjLaser_SetExpandVelocity(las,expv){
	Obj_SetValue(las,"ExpandVelocity",expv); let width;
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandVelocity",0)==expv){
		width = Obj_GetValueD(las,"Width",15);
		if(width < Obj_GetValueD(las,"MaxExpandWidth",50)) {
			ObjLaser_SetRenderWidth(las,width+expv);
			ObjLaser_SetIntersectionWidth(las,(width+expv)/3);
			Obj_SetValue(las,"Width",width+expv);
		}
		yield;
	}
}
task ObjLaser_SetExpandAcceleration(las,expa){
	Obj_SetValue(las,"ExpandAcceleration",expa);
	let expv = Obj_GetValueD(las,"ExpandVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandAcceleration",0)==expa ){
		expv = Obj_GetValueD(las,"ExpandVelocity",0);
		if( (|expv|) < (|Obj_GetValueD(las,"MaxExpandVelocity",3)|) ){
			ObjLaser_SetExpandVelocity(las,expv+expa);
		}
		yield;
	}
}
function ObjLaser_SetMaxExpandVelocity(las,mexpv){
	Obj_SetValue(las,"MaxExpandVelocity",mexpv);
}
function ObjLaser_SetMaxExpandWidth(las,mexpw){
	Obj_SetValue(las,"MaxExpandWidth",mexpw);
}



//////////////////////////////////////////////////////////////////
// Intersection Functions
//////////////////////////////////////////////////////////////////





//Determine if two line segments intersect
function IsIntersected_Line_Line(ax0,ay0,ax1,ay1,  bx0,by0,bx1,by1) {
	//Convert vector 1 to equation - A*x + B*y + C
	let e_a1 = ay1-ay0;
	let e_b1 = ax0-ax1;
	let e_c1 = (ax1*ay0) - (ax0*ay1);
	
	//Plug endpoints of vector 2 into that equation
	let e_d1 = (e_a1*bx0) + (e_b1*by0) + e_c1;
	let e_d2 = (e_a1*bx1) + (e_b1*by1) + e_c1;
	
	//If d1 and d2 have the same sign, they are both on same side of first line
	//and therefore the lines cannot intersect
	//0 is a special case
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Since we were treating vector 1 an an infinite line, 
	//we need to repeat that check treating vector 2 as an infinite line instead
	
	//Convert to equation
	let e_a2 = by1-by0;
	let e_b2 = bx0-bx1;
	let e_c2 = (bx1*by0) - (bx0*by1);
	//Plug in endpoints of vector 1
	e_d1 = (e_a2*ax0) + (e_b2*ay0) + e_c2;
	e_d2 = (e_a2*ax1) + (e_b2*ay1) + e_c2;
	//Check if they're on the same side of vector 1
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Check if they're colinear, i.e. intersecting at way too many points
	//Technically this should be its own case but I don't really care
	//It's not exactly a collision and it's unlikely to ever come up anyway
	if( (e_a1*e_b2)-(e_a2*e_b1) < 0.001 ) {
		return false;
	}
	
	//Well, we've eliminated all the other possibilities I can think of
	//So we'll assume they intersect
	return true;
}

//Find point at which two line segments intersect
function GetIntersection_Line_Line(x0,y0,x1,y1,  x2,y2,x3,y3) {
	//Convert vector 1 to equation - 
	//A*x + B*y + C
	let a1 = y1-y0;
	let b1 = x0-x1;
	let c1 = (x1*y0) - (x0*y1);
	//Convert vector 2 to equation - 
	//A*x + B*y + C
	let a2 = y3-y2;
	let b2 = x2-x3;
	let c2 = (x3*y2) - (x2*y3);
	
	//  a1x*a2x + b1y*a2x - c1*a2x = 0
	//  a2x*a1x + b2y*a1x - c2*a1x = 0
	
	//   b1y*a2x - b2y*a1x   =  c1*a2x - c2*a1x
	//   yx( b1*a2 ) - yx(b2*a1)   =  x(c1*a2) - x(c2*a1)
	//   (c1*a2 - c2*a1)/(b1*a2 - b2*a1) = y
	
	let x = (c1*b2-c2*b1)/(a1*b2-a2*b1);
	let y = (c1*a2 - c2*a1)/(b1*a2 - b2*a1);
	
	if(min(x0,x1)<=x && x <= max(x0,x1) && min(y0,y1)<=y && y <= max(y0,y1)) {
		return [x,y];
	}else{
		return [NULL,NULL];
	}
}

//////////////////////////////////////////////////////////////////
//Collision Object Functions
//////////////////////////////////////////////////////////////////

function OC_GetIntersectionRadius(obj){
	// if(!OC_IsIntersectionEnable(obj)){return 0;}
	if(Obj_IsValueExists(obj,COL_RADIUS)){
		return Obj_GetValue(obj,COL_RADIUS);
	}
	alternative(O_GetType(obj))
	case(OBJ_SHOT){return OS_GetCollisionRadius(obj);}
	case(OBJ_ENEMY){return 10;}
	others{return 0;}
}
function OC_SetIntersectionRadius(obj,v){
	if(O_GetType(obj)==OBJ_SHOT){
		let base = OS_GetCollisionRadius(obj)/OR_GetScale(obj);
		OR_SetScale(obj,v/base);
	}
	Obj_SetValue(obj,COL_RADIUS,v);
}

function OC_SetIntersectionEnable(obj,intersect){
	Obj_SetValue(obj,FLAG_INTERSECTION,intersect); 
	if(O_GetType(obj)==OBJ_SHOT){
		ObjShot_SetIntersectionEnable(obj,intersect);
	}
}
function OC_IsIntersectionEnable(obj){
	if(Obj_IsValueExists(obj,FLAG_INTERSECTION)){return Obj_GetValue(obj,FLAG_INTERSECTION);}
	else{
		alternative(O_GetType(obj))
		case(OBJ_SHOT){return !( Obj_GetValueD(obj,FLAG_DUMMY,false) || (ObjShot_GetImageID(obj)==0) );}
		case(OBJ_ENEMY){return true;}
		others{return false;}
	}
}