#include "./Resources.txt"
#include "./../shot/AllStarShot_Const_Andi.txt"
#include "./../system/ItemConst.txt"
#include "./TypeFunctions.txt"

let FLAG_CHECK = "Check";                                       let FLAG_CHECKINFO = FLAG_CHECK;
let FLAG_DUMMY = "IsDummy";
let FLAG_XYMOVE = "UseXYSystem";
let FLAG_INTERSECTION = "IsIntersectionEnable";
let FLAG_SPELLRESIST = "IsSpellResist";
let FLAG_DELAYLASER = "IsDelayLaser";
let FLAG_FREEZE = "IsFrozen";

let FLAG_BOSS = "IsBoss";
let CHARACTER_COLOR = "ThemeColor"; //the color "associated" with the character an obj represents
let BOSS_INDEX = "BossIndex";

let META_SUBTYPE = "Subtype";
let MOD_FRAME = "LastSetAtFrame";


let MOVE_POS = "Position";
let MOVE_X = "MoveX";
let MOVE_Y = "MoveY";
let MOVE_SPEED = "Speed";
let MOVE_ACCEL = "Acceleration";
let MOVE_MAXSPEED = "MaxSpeed";
let MOVE_JERK = "Jerk";
let MOVE_MAXACCEL = "MaxAcceleration";

let MOVE_ANGLE = "Angle";
let MOVE_ANGV = "AngularVelocity";
let MOVE_ANGACCEL = "AngularAcceleration";
let MOVE_MAXANGV = "MaxAngularVelocity";

let MOVE_XSPEED = "XSpeed";
let MOVE_YSPEED = "YSpeed";
let MOVE_XACCEL = "XAcceleration";
let MOVE_YACCEL = "YAcceleration";
let MOVE_XMAXSPEED = "XMaxSpeed";
let MOVE_YMAXSPEED = "YMaxSpeed";

let RENDER_ALPHA = "Alpha";
let RENDER_COLOR = "Color";
let RENDER_RCOL = "R";
let RENDER_GCOL = "G";
let RENDER_BCOL = "B";

let RENDER_POS = "RenderPosition";
let RENDER_X = "RenderX";
let RENDER_Y = "RenderY";
let RENDER_Z = "RenderZ";
let RENDER_ANGLE = "AngleZ";
let RENDER_ANGLEX = "AngleX";
let RENDER_ANGLEY = "AngleY";
let RENDER_ANGLEZ = "AngleZ";
let RENDER_SCALE = "Scale"; //"overall" scale
let RENDER_SCALEX = "ScaleX";
let RENDER_SCALEY = "ScaleY";
let RENDER_SCALEZ = "ScaleZ";
let RENDER_SCALEXYZ = "ScaleXYZ"; //tells to use indiv SCALEX/etc

let RENDER_PRIORITY = "RenderPriority";

let MOVE_Z = "MoveZ"; //experimental

let SHOT_GRAPHIC = "Graphic";
let SHOT_DELETEFRAME = "DeleteFrame";
let LASER_RWIDTH = "LaserRenderWidth";
let LASER_IWIDTH = "LaserIntersectionWidth"; let LASER_CWIDTH = LASER_IWIDTH;

let COL_RADIUS = "CollisionRadius";
let COL_SCALE = "CollisionScale";

//////////////////////////////////////////////////////////////////////////////
//Higher-order functions for generalizing functions to operate on any property
//////////////////////////////////////////////////////////////////////////////

function O_SetProperty(obj,k,v){
	// if(typeof(v)==TYPE_CHAR && ToString(v)==ToString(NO_CHANGE)){ O_SetProperty(obj,k,O_GetProperty(obj,k));return;}
	if(Obj_GetType(v)==Obj_GetType(NO_CHANGE) && v==NO_CHANGE){ O_SetProperty(obj,k,O_GetProperty(obj,k));return;}
	alternative(k)
	case(FLAG_INTERSECTION){ Obj_SetValue(obj,FLAG_INTERSECTION,v); if(O_GetType(obj)==OBJ_SHOT){ObjShot_SetIntersectionEnable(obj,v);} }
	case(FLAG_SPELLRESIST){ Obj_SetValue(obj,FLAG_SPELLRESIST,v); if(O_GetType(obj)==OBJ_SHOT){ObjShot_SetSpellResist(obj,v);} }
	case(MOVE_POS){ OM_SetX(obj,v[0]); OM_SetY(obj,v[1]); } //todo?
	case(MOVE_X){   OM_SetX(obj,v); }
	case(MOVE_Y){   OM_SetY(obj,v); }
	case(MOVE_SPEED){       OM_SetSpeed(obj,v); }
	case(MOVE_ACCEL){       OM_SetAcceleration(obj,v); }
	case(MOVE_MAXSPEED){    OM_SetMaxSpeed(obj,v); }
	case(MOVE_JERK){        OM_SetJerk(obj,v); }
	case(MOVE_MAXACCEL){    OM_SetMaxAcceleration(obj,v); }
	case(MOVE_ANGLE){       OM_SetAngle(obj,v); }
	case(MOVE_ANGV){        OM_SetAngularVelocity(obj,v); }
	case(MOVE_ANGACCEL){    OM_SetAngularAcceleration(obj,v); }
	case(MOVE_MAXANGV){     OM_SetMaxAngularVelocity(obj,v); }
	case(MOVE_XSPEED){      OM_SetSpeedX(obj,v); }
	case(MOVE_YSPEED){      OM_SetSpeedY(obj,v); }
	case(MOVE_XACCEL){    OM_SetAccelerationX(obj,v); }
	case(MOVE_YACCEL){    OM_SetAccelerationY(obj,v); }
	case(MOVE_XMAXSPEED){ OM_SetMaxSpeedX(obj,v); }
	case(MOVE_YMAXSPEED){ OM_SetMaxSpeedY(obj,v); }
	case(RENDER_ALPHA){     OR_SetAlpha(obj,v); }
	case(RENDER_COLOR){     OR_SetColor(obj,v[0],v[1],v[2]); }
	case(RENDER_RCOL){ let c=OR_GetColor(obj); OR_SetColor(obj,v   ,c[1],c[2]); }
	case(RENDER_GCOL){ let c=OR_GetColor(obj); OR_SetColor(obj,c[0],v   ,c[2]); }
	case(RENDER_BCOL){ let c=OR_GetColor(obj); OR_SetColor(obj,c[0],c[1],v   ); }
	case(RENDER_SCALE){     OR_SetScale(obj,v); }
	case(RENDER_SCALEX){    OR_SetScaleX(obj,v); }
	case(RENDER_SCALEY){    OR_SetScaleY(obj,v); }
	case(RENDER_SCALEXYZ){  OR_SetScaleXYZ(obj,v[0],v[1],v[2]); }
	case(RENDER_ANGLE){  OR_SetAngleZ(obj,v); }
	case(RENDER_ANGLEX){ OR_SetAngleX(obj,v); }
	case(RENDER_ANGLEY){ OR_SetAngleY(obj,v); }
	case(COL_RADIUS){ OC_SetIntersectionRadius(obj,v); }
	case(COL_SCALE){  OS_SetScaleXYZ(obj,v,v,1); } //todo?
	case(MOVE_Z){ OM_SetZ(obj,v); }
	case(RENDER_PRIORITY){ O_SetRenderPriorityI(obj,v); }
	others{ Obj_SetValue(obj,k,v); }
}
function O_GetProperty(obj,k){
	let v;
	alternative(k)
	case(FLAG_INTERSECTION){ v = Obj_GetValueD(obj,FLAG_INTERSECTION,true); }
	case(FLAG_SPELLRESIST){ v = Obj_GetValueD(obj,FLAG_SPELLRESIST,false); }
	case(MOVE_POS){ v = [OM_GetX(obj), OM_GetY(obj)]; }
	case(MOVE_X){   v = OM_GetX(obj); }
	case(MOVE_Y){   v = OM_GetY(obj); }
	case(MOVE_SPEED){        v = OM_GetSpeed(obj); }
	case(MOVE_ACCEL){        v = OM_GetAcceleration(obj); }
	case(MOVE_MAXSPEED){     v = OM_GetMaxSpeed(obj); }
	case(MOVE_JERK){         v = OM_GetJerk(obj); }
	case(MOVE_MAXACCEL){     v = OM_GetMaxAcceleration(obj); }
	case(MOVE_ANGLE){        v = OM_GetAngle(obj); }
	case(MOVE_ANGV){         v = OM_GetAngularVelocity(obj); }
	case(MOVE_ANGACCEL){     v = OM_GetAngularAcceleration(obj); }
	case(MOVE_MAXANGV){      v = OM_GetMaxAngularVelocity(obj); }
	case(MOVE_XSPEED){       v = OM_GetSpeedX(obj); }
	case(MOVE_YSPEED){       v = OM_GetSpeedY(obj); }
	case(MOVE_XACCEL){       v = OM_GetAccelerationX(obj); }
	case(MOVE_YACCEL){       v = OM_GetAccelerationY(obj); }
	case(MOVE_XMAXSPEED){    v = OM_GetMaxSpeedX(obj); }
	case(MOVE_YMAXSPEED){    v = OM_GetMaxSpeedY(obj); }
	case(RENDER_ALPHA){      v = OR_GetAlpha(obj); }
	case(RENDER_COLOR){      v = OR_GetColor(obj); }
	case(RENDER_RCOL){       v = OR_GetColor(obj)[0]; }
	case(RENDER_GCOL){       v = OR_GetColor(obj)[1]; }
	case(RENDER_BCOL){       v = OR_GetColor(obj)[2]; }
	case(RENDER_SCALE){      v = OR_GetScale(obj); }
	case(RENDER_SCALEX){     v = OR_GetScaleX(obj); }
	case(RENDER_SCALEY){     v = OR_GetScaleY(obj); }
	case(RENDER_ANGLE){      v = OR_GetAngleZ(obj); }
	case(RENDER_ANGLEX){     v = OR_GetAngleX(obj); }
	case(RENDER_ANGLEY){     v = OR_GetAngleY(obj); }
	case(COL_RADIUS){        v = OC_GetIntersectionRadius(obj); }
	case(COL_SCALE){ v = Obj_GetValueD(obj,COL_SCALE,OR_GetScale(obj)); } //todo
	case(MOVE_Z){ v = OM_GetZ(obj); }
	case(RENDER_PRIORITY){   v = O_GetRenderPriorityI(obj); }
	others{v=Obj_GetValueD(obj,k,NULL);}
	
	return v;
}

task O_SetPattern(obj,k,v,t){
	let n = 0;
	while(Obj_IsValueExists(obj,"Pattern"~k~itoa(n))){n++;}
	Obj_SetValue(obj,"Pattern"~k~itoa(n),v);
	Obj_SetValue(obj,"PatternFrame"~k~itoa(n),frame+t);
	Obj_SetValue(obj,"NumPatterns",Obj_GetValueD(obj,"NumPatterns",0)+1);
	if(t<=0){ return; }
	loop(t){yield;}
	O_SetProperty(obj,k,v);
	Obj_DeleteValue(obj,"Pattern"~k~itoa(n));
	Obj_DeleteValue(obj,"PatternFrame"~k~itoa(n));
	Obj_SetValue(obj,"NumPatterns",Obj_GetValueD(obj,"NumPatterns",0)-1);
}
function O_GetPattern(obj,k){
	let pats = [];
	let n = Obj_GetValueD(obj,"NumPatterns",0);
	let i = 0;
	while(i < n){
		if(Obj_IsValueExists(obj,"Pattern"~k~itoa(i))){
			let pat = Obj_GetValue(obj, "Pattern"~k~itoa(i));
			let t = Obj_GetValueD(obj, "PatternFrame"~k~itoa(i), NULL);
			pats = pats ~ [ [pat,t] ];
		}
		i++;
	}
	return pats;
}


function O_SetProperties(obj,k,v){
	ascent(i in 0..length(k)){
		O_SetProperty(obj,k[i],v[i]);
	}
}




let PROP_VALUE = 0;     let PROP_RVALUE = 10;
let PROP_SPEED = 1;     let PROP_RSPEED = 11;
let PROP_ACCEL = 2;     let PROP_RACCEL = 12;
let PROP_MAXSPEED = 3;  let PROP_RMAXSPEED = 13;
let PROP_JERK = 4;      let PROP_RJERK = 14;
let PROP_MAXACCEL = 5;  let PROP_RMAXACCEL = 15;

//Given the name of a property, get the name of another property in that "set" of properties
//e.g. GetRelatedProperty(MOVE_ANGLE,PROP_ACCEL) returns MOVE_ANGACCEL
function GetRelatedProperty(key,relation){
	let rels;
	alternative(key)
	case(MOVE_POS,MOVE_SPEED,MOVE_ACCEL,MOVE_MAXSPEED,MOVE_JERK,MOVE_MAXACCEL){
		rels = [MOVE_POS,MOVE_SPEED,MOVE_ACCEL,MOVE_MAXSPEED,MOVE_JERK,MOVE_MAXACCEL];
	}
	case(MOVE_ANGLE,MOVE_ANGV,MOVE_ANGACCEL,MOVE_MAXANGV){
		rels = [MOVE_ANGLE,MOVE_ANGV,MOVE_ANGACCEL,MOVE_MAXANGV];
	}
	case(MOVE_X,MOVE_XSPEED,MOVE_XACCEL,MOVE_XMAXSPEED){ rels = [MOVE_X,MOVE_XSPEED,MOVE_XACCEL,MOVE_XMAXSPEED]; }
	case(MOVE_Y,MOVE_YSPEED,MOVE_YACCEL,MOVE_YMAXSPEED){ rels = [MOVE_Y,MOVE_YSPEED,MOVE_YACCEL,MOVE_YMAXSPEED]; }
	others{ rels=[]; }
	
	if(relation < length(rels) && relation >= 0){
		return rels[relation];
	}else if((|relation|)-PROP_RVALUE < length(rels) && (|relation|)-PROP_RVALUE > 0){
		let i=0; while(i<length(rels) && rels[i]!=key){i++;}
		let off = ((|relation|)-10)*sign(relation);
		if(0<=i+off&&i+off<length(rels)){
			return rels[i+off];
		}else{return key~itoa(relation);}
	}else{
		return "";
	}
}
//Get the names of any properties which are components of the given property.
function GetSubProperty(key,index){
	let rels;
	alternative(key)
	case(MOVE_POS){ rels = [MOVE_X,MOVE_Y]; }
	case(RENDER_POS){ rels = [RENDER_X,RENDER_Y]; }
	case(RENDER_COLOR){ rels = [RENDER_RCOL,RENDER_GCOL,RENDER_BCOL,RENDER_ALPHA]; }
	others{ rels=[]; }
	
	if(index < length(rels)){
		return rels[index];
	}else{
		return "";
	}
}
//Check if a property is stored as an array.
function Prop_IsArray(k){
	alternative(k)
	case(MOVE_POS,RENDER_POS,RENDER_COLOR){return true;}
	others{return false;}
}

function OProp_CheckNoChange(obj,k,v){ //fucky atm
	if(v>NO_CHANGE){ return v;}
	else{
		return O_GetProperty(obj,k);
	}
}


//---------------------

task O_AddPropertyPatternA1(obj,del,k_val,s){
	wait(del);
	let v = O_GetProperty(obj,k_val);
	let k_spd = GetRelatedProperty(k_val,PROP_RSPEED);
	s=OProp_CheckNoChange(obj,k_spd,s);
	O_SetProperty(obj,k_spd,s);
	while(!Obj_IsDeleted(obj) && O_GetProperty(obj,k_val)==v){
		v+=s;
		O_SetProperty(obj,k_val,v);
		yield;
	}
}
task O_AddPropertyPatternA2(obj,del,k_val,s,a,ms){
	wait(del);
	let v = O_GetProperty(obj,k_val);
	let k_spd = GetRelatedProperty(k_val,PROP_RSPEED);   if(k_spd!=""){ s =OProp_CheckNoChange(obj,k_spd,s); }
	let k_acc = GetRelatedProperty(k_val,PROP_RACCEL);   if(k_acc!=""){ a =OProp_CheckNoChange(obj,k_acc,a); }
	let k_msp = GetRelatedProperty(k_val,PROP_MAXSPEED); if(k_msp!=""){ ms=OProp_CheckNoChange(obj,k_msp,ms); }
	O_SetProperty(obj,k_msp,ms);
	while(!Obj_IsDeleted(obj) && O_GetProperty(obj,k_val)==v){
		s+=a;
		if(s*a > ms*a && ms!=0){ s=ms; break; }
		v+=s;
		O_SetProperty(obj,k_val,v);
		O_SetProperty(obj,k_spd,s);
		yield;
	}
	O_SetProperty(obj,k_val,v);
	O_SetProperty(obj,k_spd,s);
}


task O_SetPropertyAtFrame(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtFrame(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(t in 0..frame){
		O_SetProperty(obj,k,v0+dv*t);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtDelay(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtDelay(obj,GetSubProperty(k,i),v[i],frame);}return;}
	wait(frame);
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtAccel(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtAccel(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(i in 0..frame){
		let t = i/frame;
		let vt = (v * t^2) + (v0 * (1-t^2));
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtDecel(obj,k,v,frame){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtDecel(obj,GetSubProperty(k,i),v[i],frame);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	ascent(i in 0..frame){
		let t = i/frame;		
		let u = 1-(1-t^2)*(1-t^2);
		let vt = v*u + v0*(1-u);
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}
task O_SetPropertyAtWeight(obj,k,v,frame,weight){
	if(Prop_IsArray(k)){ascent(i in 0..length(v)){O_SetPropertyAtWeight(obj,GetSubProperty(k,i),v[i],frame,weight);}return;}
	let v0 = O_GetProperty(obj,k);
	let dv = (v-v0)/frame;
	let isaccel = weight<0; if(isaccel){weight=(|weight|);}
	weight=weight^0.75;
	ascent(i in 0..frame){
		let t = i/frame;
		let m; let vt;
		if(!isaccel){
			m = 1 - (1-t)^(0.5*(weight^0.5));
			vt = v*m + v0*(1-m);
		}else{
			m = t^weight;
			vt = v0+dv*i*m;
		}
		O_SetProperty(obj,k,vt);
		yield;
	}
	O_SetProperty(obj,k,v);
}



//////////////////////////////////////////////////////////////////
//Object Functions
//////////////////////////////////////////////////////////////////



function O_GetType(obj){return typeof(obj);}

//Other pseudo-types, used for "objects" like ObjGap, ObjFog, &c.

function O_GetSubType(obj){
	return Obj_GetValueD(obj,"Subtype",typeof(obj));
}





//MISC

function ObjEnemy_GetLife(enemy){ return ObjEnemy_GetInfo(enemy,INFO_LIFE); }

let TYPE_ENEMY = 9000; let TYPE_FAM = 9001; let TYPE_DIE = 8000;
function DeleteEnemyAll(enetype,deletetype){
	let enems = GetAllEnemyID;
	ascent(i in 0..length(enems)){
		let ene = enems[i];
		if(Obj_GetType(ene)!=OBJ_ENEMY_BOSS || enetype==TYPE_ALL){
			if(enetype!=TYPE_FAM || Obj_GetValueD(ene,"IsFam",false)){
				alternative(deletetype)
				case(TYPE_IMMEDIATE){ Obj_Delete(ene); }
				case(TYPE_DIE){ ObjEnemy_SetLife(ene,0); }
				case(TYPE_FADE){ Obj_FadeDelete(ene); }
				case(TYPE_ITEM){
					// ItemExplode(ObjMove_GetX(ene),ObjMove_GetY(ene),trunc(ObjEnemy_GetLife(ene)/50));
					let x = ObjMove_GetX(ene); let y = ObjMove_GetY(ene);
					let n = trunc(ObjEnemy_GetLife(ene)/50);
					let r = max(48, 48*(360/n)/120);
					loop(n){
						let a = rand(0,360);
						let d = rand(r/2,r);
						NotifyEvent(GetCommonData("ItemScriptID",NULL),EV_SPAWN_ITEM,
						  [I_CANCEL,x,y,x+d*cos(a),y+d*sin(a),0]);
					}
					
					ObjEnemy_SetLife(ene,0);
				}
			}
		}
	}
}


function GetAllBossID{
	let enems = GetAllEnemyID;
	let bosses = [];
	let count = 0;
	ascent(i in 0..length(enems)){
		let enem = enems[i];
		if(Obj_GetValueD(enem,FLAG_BOSS,Obj_GetType(enem)==OBJ_ENEMY_BOSS)){
			bosses = bosses ~ [enem];
			count++;
		}
	}
	SetCommonData("BossCount",count);
	return bosses;
}


//////////////////////////////////////////////////////////////////
// Render Object Functions
//////////////////////////////////////////////////////////////////

function OR_SetAngle(obj,a){ Obj_SetValue(obj,RENDER_ANGLE,a); ObjRender_SetAngleZ(obj,a);}
function OR_SetAngleZ(obj,a){Obj_SetValue(obj,RENDER_ANGLE,a); ObjRender_SetAngleZ(obj,a);}
function OR_SetAngleX(obj,a){Obj_SetValue(obj,RENDER_ANGLEX,a);ObjRender_SetAngleX(obj,a);}
function OR_SetAngleY(obj,a){Obj_SetValue(obj,RENDER_ANGLEY,a);ObjRender_SetAngleY(obj,a);}
function OR_SetAngleXYZ(obj,x,y,z){OR_SetAngleX(obj,x);OR_SetAngleY(obj,y);OR_SetAngleZ(obj,z);}
function OR_GetAngle(obj){  return Obj_GetValueD(obj,RENDER_ANGLE, ObjRender_GetAngleZ(obj)); }
function OR_GetAngleZ(obj){ return Obj_GetValueD(obj,RENDER_ANGLE, ObjRender_GetAngleZ(obj)); }
function OR_GetAngleX(obj){ return Obj_GetValueD(obj,RENDER_ANGLEX,ObjRender_GetAngleX(obj)); }
function OR_GetAngleY(obj){ return Obj_GetValueD(obj,RENDER_ANGLEY,ObjRender_GetAngleY(obj)); }


//Andi - COLOR/ALPHA FUNCTIONS
//Set an object's alpha or RGB, depending on blend type.
//Efficient. Always use this to ensure alpha is accessible by other functions.
function OR_SetAlpha(obj, alpha){
	Obj_SetValue(obj, RENDER_ALPHA, alpha);
	let C; let R; let G; let B; let A;
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ADD_RGB,BLEND_SUBTRACT,BLEND_MULTIPLY,BLEND_SHADOW){
		C = Obj_GetValueD(obj,RENDER_COLOR,[255,255,255]);
		R = Obj_GetValueD(obj,RENDER_RCOL,C[0]);
		G = Obj_GetValueD(obj,RENDER_GCOL,C[1]);
		B = Obj_GetValueD(obj,RENDER_BCOL,C[2]);
		A = alpha/255;
		Obj_SetValue(obj,RENDER_COLOR,[R,G,B,alpha]);
	}
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ALPHA)   {ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_ARGB){ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_RGB) {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SUBTRACT){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_MULTIPLY){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SHADOW)  {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	others{ObjRender_SetAlpha(obj, alpha);}
}
function ObjRender_SetTrueAlpha(obj,alpha){ OR_SetAlpha(obj,alpha); }
//Set color such that it is accessible by other functions.
//Efficient. Always use one of these. 
function OR_SetColor(obj,r,g,b){
	ObjRender_SetColor(obj,r,g,b);
	Obj_SetValue(obj,RENDER_RCOL,r);
	Obj_SetValue(obj,RENDER_GCOL,g);
	Obj_SetValue(obj,RENDER_BCOL,b);
	Obj_SetValue(obj,RENDER_COLOR,[r,g,b]);
}
function OR_SetColorArr(obj,c){
	OR_SetColor(obj,c[0],c[1],c[2]);
	if(length(c)>3){ OR_SetAlpha(obj,c[3]); }
}
function OR_SetColorRGB(obj,r,g,b){ OR_SetColor(obj,r,g,b); }
function OR_SetColorRGBA(obj,r,g,b,a){
	OR_SetColor(obj,r,g,b);
	OR_SetAlpha(obj,a);
	Obj_SetValue(obj,RENDER_COLOR,[r,g,b,a]);
}
function ObjRender_SetTrueColor(obj,r,g,b){ OR_SetColor(obj,r,g,b); }
//Set color without changing stored values
function OR_SetTempColor(obj,r,g,b){ ObjRender_SetColor(obj,r,g,b); }
//Set alpha regardless of blend type without changing stored values
function OR_SetTempAlpha(obj, alpha){
	let C; let R; let G; let B; let A;
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ADD_RGB,BLEND_SUBTRACT,BLEND_MULTIPLY,BLEND_SHADOW){
		C = Obj_GetValueD(obj,RENDER_COLOR,[255,255,255]);
		R = Obj_GetValueD(obj,RENDER_RCOL,C[0]);
		G = Obj_GetValueD(obj,RENDER_GCOL,C[1]);
		B = Obj_GetValueD(obj,RENDER_BCOL,C[2]);
		A = alpha/255;
	}
	alternative(ObjRender_GetBlendType(obj))
	case(BLEND_ALPHA)   {ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_ARGB){ObjRender_SetAlpha(obj, alpha);}
	case(BLEND_ADD_RGB) {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SUBTRACT){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_MULTIPLY){ObjRender_SetColor(obj, R*A, G*A, B*A);}
	case(BLEND_SHADOW)  {ObjRender_SetColor(obj, R*A, G*A, B*A);}
	others{ObjRender_SetAlpha(obj, alpha);}
}


//Attempt to compensate for the lack of such functions.
//Efficient as long as value was properly stored, or after the first time.
function OR_GetAlpha(obj){
	if(Obj_IsValueExists(obj,RENDER_ALPHA)){return Obj_GetValue(obj,RENDER_ALPHA);}
	else{
		let C = Obj_GetValueD(obj,RENDER_COLOR,[255,255,255]);
		if(length(C) > 3){ Obj_SetValue(obj,RENDER_ALPHA,C[3]); return C[3]; }
		let A = Obj_GetValueD(obj,RENDER_ALPHA,-1);
		if(A!=-1){ return A;}
		let R = Obj_GetValueD(obj,RENDER_RCOL,C[0]); 
		let G = Obj_GetValueD(obj,RENDER_GCOL,C[1]); 
		let B = Obj_GetValueD(obj,RENDER_BCOL,C[2]);
		A = max(R,max(G,B)); //Use the largest RGB value
		Obj_SetValue(obj,RENDER_ALPHA,A); Obj_SetValue(obj,"A",A);
		Obj_SetValue(obj,RENDER_COLOR,[R,G,B,A]);
		return A;
	}
}
function OR_GetColor(obj){ return Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]); }
function OR_GetColorRGB(obj){return Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);}
function OR_GetColorRGBA(obj){
	let C = Obj_GetValueD(obj,RENDER_COLOR,[Obj_GetValueD(obj,"R",255),Obj_GetValueD(obj,"G",255),Obj_GetValueD(obj,"B",255)]);
	let A = OR_GetAlpha(obj);
	return C ~ [A];
}
function ObjRender_GetAlpha(obj){return OR_GetAlpha(obj);}

function OR_AddAlpha(obj,dA){
	OR_SetAlpha(obj,OR_GetAlpha(obj)+dA);
}
task OR_SetAlphaAtFrame(obj,a1,time){
	let a0   = ObjRender_GetAlpha(obj);
	let dA   = (a1-a0)/time;
	ascent(i in 0..time){
		OR_SetAlpha(obj,a0+dA*i);
		yield;
	}
}

function OR_AddScaleXYZ(obj,dX,dY,dZ){ ObjRender_SetScaleXYZ(obj,ObjRender_GetScaleX(obj)+dX,ObjRender_GetScaleY(obj)+dY,ObjRender_GetScaleZ(obj)+dZ); }
task OR_SetScaleAtFrame(obj,sx1,sy1,time){
	let sx0   = ObjRender_GetScaleX(obj);
	let sy0   = ObjRender_GetScaleY(obj);
	let dsx   = (sx1-sx0)/time;
	let dsy   = (sy1-sy0)/time;
	ascent(i in 0..time){
		ObjRender_SetScaleXYZ(obj,sx0+dsx*i,sy0+dsy*i,1);
		yield;
	}
}

//set "overall" scale
function OR_SetScale(obj,scale){
	let sclx = OR_GetScaleX(obj);
	let scly = OR_GetScaleY(obj);
	let ratio = (|sclx/scly|);
	OR_SetScaleXYZ(obj,scale*ratio*sign(sclx),scale/ratio*sign(scly),ObjRender_GetScaleZ(obj));
	Obj_SetValue(obj,RENDER_SCALE,scale);
	return scale;
}
function OR_GetScale(obj){
	let scale = Obj_GetValueD(obj,RENDER_SCALE,NULL);
	if(scale==NULL){
		let sclx = OR_GetScaleX(obj);
		let scly = OR_GetScaleY(obj);
		scale = ((|sclx|)+(|scly|))/2;
	}
	return scale;
}
function OR_SetScaleX(obj,scalex){
	ObjRender_SetScaleX(obj,scalex);
	Obj_SetValue(obj,RENDER_SCALEX,scalex);
}
function OR_GetScaleX(obj){return Obj_GetValueD(obj,RENDER_SCALEX,ObjRender_GetScaleX(obj));}

function OR_SetScaleY(obj,scaley){
	ObjRender_SetScaleY(obj,scaley);
	Obj_SetValue(obj,RENDER_SCALEY,scaley);
}
function OR_GetScaleY(obj){return Obj_GetValueD(obj,RENDER_SCALEY,ObjRender_GetScaleY(obj));}

function OR_SetScaleXYZ(obj,x,y,z){
	Obj_SetValue(obj,RENDER_SCALEX,x);
	Obj_SetValue(obj,RENDER_SCALEY,y);
	Obj_SetValue(obj,RENDER_SCALEZ,z);
	ObjRender_SetScaleXYZ(obj,x,y,z);
}



function OR_GetX(obj){return ObjRender_GetX(obj);}
function OR_GetY(obj){return ObjRender_GetY(obj);}
function OR_SetX(obj,v){ObjRender_SetX(obj,v);}
function OR_SetY(obj,v){ObjRender_SetY(obj,v);}



task Obj_FadeDelete(obj) {
	let a0   = Obj_GetValueD(obj,RENDER_ALPHA,255);
	let time = Obj_GetValueD(obj,"FadeTime",60);
	let dA   = a0/time;
	descent(i in 0..time){
		OR_SetAlpha(obj,dA*i);
		yield;
	}
	Obj_Delete(obj);
}


function O_SetRenderPriorityI(obj,v){
	Obj_SetRenderPriorityI(obj,v);
	Obj_SetValue(obj,RENDER_PRIORITY,v);
}
function O_GetRenderPriorityI(obj){
	if(Obj_IsValueExists(obj,RENDER_PRIORITY)){
		return Obj_GetValue(obj,RENDER_PRIORITY);
	}else{
		return Obj_GetRenderPriorityI(obj);
	}
}

function O_SetRenderPriority(obj,v){
	Obj_SetRenderPriority(obj,v);
	Obj_SetValue(obj,RENDER_PRIORITY,v*100);
}
function O_GetRenderPriority(obj){
	if(Obj_IsValueExists(obj,RENDER_PRIORITY)){
		return Obj_GetValue(obj,RENDER_PRIORITY)/100;
	}else{
		return Obj_GetRenderPriority(obj);
	}
}




/////////////////////////////////////////////////////////////////
// Shot Functions
/////////////////////////////////////////////////////////////////




function ShotA1(x,y,s,a,g,d){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s); OM_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,g);
	ManageShotDelay(shot,d,delay_type,delay_arr);
	return shot;
}
function ShotA2(x,y,s,a, ac,ms,  g,d){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s); OM_SetAngle(shot,a);
	OM_SetAcceleration(shot,ac); OM_SetMaxSpeed(shot,ms);
	ObjShot_SetGraphic(shot,g);
	ManageShotDelay(shot,d,delay_type,delay_arr);
	return shot;
}

function ShotB1(x,y,xs,ys,g,d){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	OM_SetSpeedX(shot,xs); OM_SetSpeedY(shot,ys);
	ObjShot_SetGraphic(shot,g);
	ManageShotDelay(shot,d,delay_type,delay_arr);
	return shot;
}
function ShotB2(x,y,xs,ys, xa,ya, xm,ym,  g,d){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	Obj_SetValue(shot,FLAG_XYMOVE,true);
	Obj_SetValue(shot,MOVE_XSPEED,xs); Obj_SetValue(shot,MOVE_YSPEED,ys);
	Obj_SetValue(shot,MOVE_XACCEL,xa); Obj_SetValue(shot,MOVE_YACCEL,ya);
	Obj_SetValue(shot,MOVE_XMAXSPEED,xm); Obj_SetValue(shot,MOVE_YMAXSPEED,ym);
	ObjMove_AddPatternB2(shot,0,xs,ys,xa,ya,xm,ym);
	Obj_SetValue(shot,MOVE_XSPEED~MOD_FRAME,frame);
	Obj_SetValue(shot,MOVE_YSPEED~MOD_FRAME,frame);
	ObjShot_SetGraphic(shot,g);
	ManageShotDelay(shot,d,delay_type,delay_arr);
	return shot;
}



function LooseLaserA1(x,y,s,a, len,wid,g,d){
	let shot = ObjShot_Create(OBJ_LOOSE_LASER);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s); OM_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,g);
	ObjLaser_SetLength(shot,len);
	ObjLaser_SetRenderWidth(shot,wid);
	ObjLaser_SetIntersectionWidth(shot,max(3, floor((wid - 12) / 3)));
	ObjLaser_SetGrazeInvalidFrame(shot, 9);
	ObjLaser_SetInvalidLength(shot,15,15);
	ManageLooseLaserDelay(shot,d,delay_type,delay_arr);
	return shot;
}

function CurveLaserA1(x,y,s,a, len,wid,g,d){
	let shot = ObjShot_Create(OBJ_CURVE_LASER);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s); OM_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,g);
	ObjLaser_SetLength(shot,len);
	ObjLaser_SetRenderWidth(shot,wid);
	ObjLaser_SetIntersectionWidth(shot,max(3, floor((wid - 12) / 3)));
	ObjLaser_SetGrazeInvalidFrame(shot, 9);
	ObjLaser_SetInvalidLength(shot,15,15);
	ObjCrLaser_SetTipDecrement(shot, 0);
	ManageLooseLaserDelay(shot,d,delay_type,delay_arr);
	return shot;
}

function StraightLaserA1(x,y,a,len,wid,  g,delay,delete){
	let shot = ObjShot_Create(OBJ_STRAIGHT_LASER);
	OM_SetPosition(shot,x,y);
	ObjStLaser_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,g);
	ObjLaser_SetLength(shot,len);
	ObjLaser_SetRenderWidth(shot,wid); 
	ObjLaser_SetIntersectionWidth(shot,max(3, floor((wid - 12) / 3)));
	Obj_SetValue(shot,LASER_RWIDTH,wid);
	Obj_SetValue(shot,LASER_IWIDTH,max(3, floor((wid - 12) / 3)));
	ObjLaser_SetGrazeInvalidFrame(shot, 9);
	OS_SetDeleteFrame(shot,delete);
	if(delete <= delay){ Obj_SetValue(shot,FLAG_DELAYLASER,true); }
	ManageStraightLaserDelay(shot,delay,delay_type,delay_arr);
	return shot;
}









let DELAY_MANUAL      = 9000000; //Don't register the shot
let DELAY_FADE        = 9010000; //Regist immediately and fade in
let DELAY_GLOW        = 9020000; //Simple light effect
let DELAY_RING        = 9030000; //GLOW plus a circle effect
let DELAY_LINE        = 9040000; //RING plus a line between it and the boss (or CD "DelayHub" obj)
let DELAY_IMAGE       = 9050000; //Arbitrary image; put path in delay_subtype, rect in delay_arr
let DELAY_HIDE        = 9060000; //Wait to register the shot, but don't show any effect

let delay_type = DELAY_RING; //Default type, override by adding the const to the delay argument
let delay_subtype = "";
let delay_arr = [];

let delay_las_extend_rate = 800/60;


task ManageShotDelay(shot,del,type,arr){
	if(del>=DELAY_MANUAL){
		let tmp=del;
		del = del%10000;
		type = tmp-del;
	}
	
	alternative(type)
	case(DELAY_MANUAL){ return; }
	case(DELAY_FADE){
		let obj = shot;
		ObjShot_Regist(obj); 
		ObjShot_SetIntersectionEnable(obj,false);
		let scl = 2;
		let alpha = 0;
		let alpha_subtract = 0;
		let d0 = del;
		while(del > 0){
			alpha_subtract = Obj_GetValueD(obj, "DelayAlpha", 0);
			// let c = OR_GetColor(shot);
			// OR_SetColor(obj,c[0],c[1],c[2]);
			OR_SetTempAlpha(obj,alpha-alpha_subtract);
			ObjRender_SetScaleXYZ(obj,scl,scl,scl);
			alpha += 255/d0;
			scl -= 1/d0;
			del--;
			yield;
		}
		OR_SetTempAlpha(obj,OR_GetAlpha(obj)-Obj_GetValueD(obj, "DelayAlpha", 0));
		ObjShot_SetIntersectionEnable(obj, OS_IsIntersectionEnable(shot));
	}
	case(DELAY_HIDE){
		wait(del);
		ObjShot_Regist(shot);
	}
	case(DELAY_GLOW){
		let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
		let cloudgraph = GLOW+GetShotColor(ObjShot_GetImageID(shot));
		let a = ObjMove_GetAngle(shot);
		let obj = CreateShotA1(x,y,0,a, cloudgraph, 0);
		OS_SetIntersectionEnable(obj,false);
		// ObjRender_SetScaleXYZ(obj,0,0,0);
		let s0 = 2+del/15; let s1 = 1; let ds = (s1-s0)/del; del=(|del|);
		ascent(i in 0..del){
			OR_SetScale(obj, s0+ds*i );
			let c = OR_GetColor(shot);
			OR_SetColor(obj,c[0],c[1],c[2]);
			OR_SetAlpha(obj, 255*i/del);
			ObjRender_SetAngleZ(obj,a+i*360/del);
			yield;
		}
		Obj_Delete(obj);
		ObjShot_Regist(shot);
	}
	case(DELAY_RING){
		ManageShotDelay(shot,del,DELAY_GLOW,[]);
		let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
		let path = direffect~"Ring.png";
		let obj = CreateSprite(x,y,path,[0,0,63,63],PRI_SHOT+1); //todo
		ObjRender_SetBlendType(obj,BLEND_ADD_RGB);
		
		let c0 = GetShotDataInfoA1(ObjShot_GetImageID(shot),TYPE_ENEMY,INFO_DELAY_COLOR);
		let r0 = c0[0]; let g0 = c0[1]; let b0 = c0[2];
		OR_SetColor(obj,r0,g0,b0);
		
		// ObjRender_SetScaleXYZ(obj,0,0,0);
		let s0 = (2+del/15)/3; let s1 = 0; let ds = (s1-s0)/del; del=(|del|);
		ascent(i in 0..del){
			OR_SetScale(obj, s0+ds*i );
			let c = OR_GetColor(shot);
			OR_SetColor(obj,(r0+c[0])/2,(g0+c[1])/2,(b0+c[2])/2);
			// OR_SetAlpha(obj, 255*i/del);
			yield;
		}
		Obj_Delete(obj);
		// ObjShot_Regist(shot);
		// ManageShotDelay(shot,6,DELAY_FADE,[]);
	}
	case(DELAY_IMAGE){
		let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
		let path = delay_subtype;
		let rect = GetCommonData("DelayRect",[0,0,GetTextureWidth(path)-1,GetTextureHeight(path)-1]);
		let w = rect[2]-rect[0]; let h = rect[3]-rect[1];
		
		let obj = CreateSprite(x,y,path,rect,PRI_SHOT+1);
		ObjRender_SetBlendType(obj,GetCommonData("DelayBlend",BLEND_ADD_RGB));
		
		let c0 = GetShotDataInfoA1(ObjShot_GetImageID(shot),TYPE_ENEMY,INFO_DELAY_COLOR);
		let r0 = c0[0]; let g0 = c0[1]; let b0 = c0[2];
		OR_SetColor(obj,r0,g0,b0);
		
		OR_SetAngleZ(obj,OM_GetAngle(shot));
		
		
		// ObjRender_SetScaleXYZ(obj,0,0,0);
		let s0 = (2+del/15)/3; let s1 = 0; let ds = (s1-s0)/del; del=(|del|);
		ascent(i in 0..del){
			ObjRender_SetScaleXYZ(obj, (s0+ds*i)*64/w, (s0+ds*i)*64/h, 1 );
			let c = OR_GetColor(shot);
			// OR_SetColor(obj,r0*c[0]/255,g0*c[1]/255,b0*c[2]/255);
			OR_SetColor(obj,(r0+c[0])/2,(g0+c[1])/2,(b0+c[2])/2);
			// OR_SetAlpha(obj, 255*i/del);
			yield;
		}
		Obj_Delete(obj);
		// ObjShot_Regist(shot);
		ManageShotDelay(shot,6,DELAY_FADE,[]);
		ManageShotDelay(shot,6,DELAY_GLOW,[]);
	}
	case(DELAY_LINE){
		ManageShotDelay(shot,del,DELAY_RING,[]);
		// ManageShotDelay(shot,del,DELAY_GLOW);
		let cobj = GetCommonData("DelayHub",boss);
		let dx0=rand(-4,4); let dy0=rand(-4,4);
		let dx1=rand(-2,2); let dy1=rand(-2,2);
		let x0 = OM_GetX(cobj)+dx0;  let y0 = OM_GetY(cobj)+dy0;
		let x  = OM_GetX(shot)+dx1;  let y  = OM_GetY(shot)+dy1;
		let a  = getangle(x0,y0,x,y);
		let d  = getdistance(x0,y0,x,y);
		let obj = CreateStraightLaserA1(x0,y0,a,d,40,del,LAS_C_WHITE,del+1);
		ObjStLaser_SetSource(obj,false);
		descent(i in 0..del){
			x0 = OM_GetX(cobj)+dx0;  y0 = OM_GetY(cobj)+dy0;
			x  = OM_GetX(shot)+dx1;  y  = OM_GetY(shot)+dy1;
			a  = getangle(x0,y0,x,y);
			d  = getdistance(x0,y0,x,y);
			ObjMove_SetPosition(obj,x0,y0);
			ObjStLaser_SetAngle(obj,a);
			ObjLaser_SetLength(obj,d);
			OR_SetAlpha(obj,255*(i/del)^2);
			yield;
		}
		Obj_Delete(obj);
	}	
}

task ManageLooseLaserDelay(obj,del,type,arr){
	if(del>=DELAY_MANUAL){
		let tmp=del;
		del = del%10000;
		type = tmp-del;
	}
	if(type==DELAY_MANUAL){return;}
	//Just the one type for now
	ObjShot_Regist(obj);
	let len = ObjLaser_GetLength(obj);
	let dL = len/del;
	loop(del){
		ObjMove_SetSpeed(obj,dL);		
		// ObjMove_SetSpeed(obj,-dL);		
		yield;
	}
	OM_SetSpeed(obj,Obj_GetValueD(obj,MOVE_SPEED,OM_GetSpeed(obj)));
	// OM_SetSpeed(obj,-Obj_GetValueD(obj,MOVE_SPEED,OM_GetSpeed(obj)));
	
}

task ManageStraightLaserDelay(obj,del,type,arr){
	if(del>=DELAY_MANUAL){
		let tmp=del;
		del = del%10000;
		type = tmp-del;
	}
	if(type==DELAY_MANUAL){return;}
	//Just the one type for now
	ObjShot_Regist(obj);
	
	let len = ObjLaser_GetLength(obj);
	let extenddel = delay_las_extend_rate/len;
	let dL = len/extenddel;
	ManageExtend;
	task ManageExtend{
		ascent(i in 0..extenddel){
			ObjLaser_SetLength(obj,dL*i);
			yield;
		}
		ObjLaser_SetLength(obj,len);
	}
	
	OS_SetIntersectionEnable(obj,false);
	let rwid = Obj_GetValueD(obj,LASER_RWIDTH,30);
	let cwid = Obj_GetValueD(obj,LASER_IWIDTH,6);
	ObjLaser_SetRenderWidth(obj, cwid/3 );
	
	wait(del);
	
	let expanddur;
	if(!Obj_GetValueD(obj,FLAG_DELAYLASER,false)){
		rwid = Obj_GetValueD(obj,LASER_RWIDTH,rwid);
		OS_SetIntersectionEnable(obj,true);
		expanddur = 5;
		
		ascent(i in 0..expanddur){
			ObjLaser_SetRenderWidth(obj, (rwid-cwid/3) * (i/expanddur)^0.5 );
			yield;
		}
		
	}else{
		rwid = 0;
		expanddur = Obj_GetValueD(obj,SHOT_DELETEFRAME,del)-del;
		if(expanddur == 0){return;}
		
		let da = OR_GetAlpha(obj)/expanddur;
		ascent(i in 0..expanddur){
			ObjLaser_SetRenderWidth(obj, (rwid-cwid/3) * (i/expanddur)^0.5 );
			OR_SetAlpha(obj,da*i);
			yield;
		}
		
	}
	ObjLaser_SetRenderWidth(obj, rwid );
	
}








function PrepareShotA1(x,y,s,a,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s);
	OM_SetAngle(shot,a);
	ObjShot_SetGraphic(shot,graph);
	return shot;
}
function PrepareShotA2(x,y,s,a,acc,mspd,graph){
	let shot = ObjShot_Create(OBJ_SHOT);
	OM_SetPosition(shot,x,y);
	OM_SetSpeed(shot,s);
	OM_SetAngle(shot,a);
	OM_SetAcceleration(shot,acc);
	OM_SetMaxSpeed(shot,mspd);
	ObjShot_SetGraphic(shot,graph);
	Obj_SetValue(shot,MOVE_ACCEL,acc); Obj_SetValue(shot,MOVE_MAXSPEED,mspd);
	return shot;
}



//if a shot is too close to the player, don't create it after all
//30 is a good radius
function CheckShot(shot,r){
	if(getdistance(ObjMove_GetX(shot),ObjMove_GetY(shot),px,py) <= r){
		let shot2 = CreateShotA1(ObjMove_GetX(shot),ObjMove_GetY(shot),0,0,ObjShot_GetImageID(shot),10);
		ObjRender_SetAlpha(shot2,128);
		ObjShot_SetDeleteFrame(shot2,0);
		ObjShot_SetDeleteFrame(shot,0);
	}
}



function GetAllShotId{
	return GetShotIdInCircleA2(cx,cy,800,TARGET_ENEMY);
}
function GetAllShotID{return GetShotIdInCircleA2(cx,cy,800,TARGET_ENEMY);}
function GetShotIDInCircleA2(x,y,r,targ){return GetShotIdInCircleA2(x,y,r,targ);}




function CreateDummyShot(x,y){
	let shot = CreateShotA1(x,y,0,0,0,0);
	ObjShot_SetSpellResist(shot,true);
	ObjShot_SetAutoDelete(shot,false);
	Obj_SetValue(shot,FLAG_DUMMY,true);
	Obj_SetValue(shot,"NoInfluence",true);
	return shot;
}



////////////////////////////////////////////////////////////////////
// Shot Object Functions
////////////////////////////////////////////////////////////////////

//Andi - Copy a shot as best as I could manage
//Things without getters need to be noted in the shot's dictionary to be used
function CopyShot(shot){
	if(Obj_IsDeleted(shot)){return NULL;}
		
	let x = ObjMove_GetX(shot);
	let y = ObjMove_GetY(shot);
	let spd = ObjMove_GetSpeed(shot);
	let ang = ObjMove_GetAngle(shot);
	let graph = ObjShot_GetImageID(shot);
	
	let acc  = O_GetProperty(shot,MOVE_ACCEL);
	let angv = O_GetProperty(shot,MOVE_ANGV);
	let mspd = Obj_GetValueD(shot,MOVE_MAXSPEED,9999);
	
	let spellresist = ObjShot_IsSpellResist(shot);
	let intersect = Obj_GetValueD(shot,FLAG_INTERSECTION,true);
	let scalexyz = [ObjRender_GetScaleX(shot),ObjRender_GetScaleY(shot),ObjRender_GetScaleZ(shot)];
	let blendtype = ObjRender_GetBlendType(shot);
	let color = OR_GetColor(shot);
	let alpha = OR_GetAlpha(shot);	
	
	let cpy=NULL; 
	if(Obj_GetType(shot)==OBJ_SHOT){
		cpy = CreateShotA1(x,y,spd,ang,graph,0);
	}else{
		let length = ObjLaser_GetLength(shot);
		let width = Obj_GetValueD(shot,"Width",15);
		let dur = Obj_GetValueD(shot,"Duration",30);
		let del = Obj_GetValueD(shot,"Delay",tern(Obj_GetType(shot)==OBJ_STRAIGHT_LASER, 15, 0));
		if(Obj_GetType(shot)==OBJ_LOOSE_LASER){ cpy = CreateLooseLaserA1(x,y,spd,ang, length, width, graph, del); }else
		if(Obj_GetType(shot)==OBJ_STRAIGHT_LASER){ cpy = CreateStraightLaserA1(x,y,ang,length,width, dur, graph, del); }else
		if(Obj_GetType(shot)==OBJ_CURVE_LASER){ cpy = CreateCurveLaserA1(x,y,spd,ang, length, width, graph, del); }
	}
	
	OM_AddPatternA3(shot,0,spd,ang,acc,angv,mspd,graph);
		
	ObjRender_SetBlendType(cpy, blendtype);
	OR_SetColor(cpy,color[0],color[1],color[2]);
	OR_SetAlpha(cpy,alpha);
	ObjRender_SetScaleXYZ(cpy, scalexyz[0],scalexyz[1],scalexyz[2]);
	
	ObjShot_SetSpellResist(cpy,spellresist);
	ObjShot_SetIntersectionEnable(cpy,intersect);	
	Obj_SetRenderPriority(cpy,Obj_GetRenderPriority(shot));
		
	Obj_SetValue(cpy,FLAG_INTERSECTION,intersect);
	
	return cpy;
}

function ObjShot_Delete(shot){ObjShot_SetDeleteFrame(shot,0);}
function OS_Delete(shot){ObjShot_SetDeleteFrame(shot,0);}

function OS_SetDeleteFrame(shot,f){
	Obj_SetValue(shot,SHOT_DELETEFRAME,f);
	ObjShot_SetDeleteFrame(shot,f);
}


function OS_SetSpellResist(shot,v){
	ObjShot_SetSpellResist(shot,v);
	Obj_SetValue(shot,FLAG_SPELLRESIST,v);
}
function OS_IsSpellResist(shot){
	return Obj_GetValueD(shot,FLAG_SPELLRESIST,false);
}


function OS_GetDelayColor(shot) {
	if(isnull(shot)){return [0,0,0];}
	let id = ObjShot_GetImageID(shot);
	if(id==0){ return [0,0,0]; }
	return GetShotDataInfoA1(id,TARGET_ENEMY,INFO_DELAY_COLOR);
}
function OS_GetID(shot){return ObjShot_GetImageID(shot);}

function OS_GetCollisionRadius(shot) {
	if(isnull(shot)){return 0;}
	let base = GetShotDataInfoA1(max(1,ObjShot_GetImageID(shot)),TARGET_ENEMY,INFO_COLLISION);
	// let scl = OR_GetScale(shot);
	let scl = 1;
	return base*scl;
}

function OS_GetBaseHitbox(shot) {
	if(isnull(shot)){return 0;}
	let base = GetShotDataInfoA1(max(1,ObjShot_GetImageID(shot)),TARGET_ENEMY,INFO_COLLISION);
	return base;
}



//////////////////////////////////////////////////////////////////////
// Move Object Functions
//////////////////////////////////////////////////////////////////////



function OM_IsXYMove(obj){
	if(Obj_IsValueExists(obj,FLAG_XYMOVE)){return Obj_GetValue(obj,FLAG_XYMOVE);}
	if(Obj_IsValueExists(obj,MOVE_XSPEED)||Obj_IsValueExists(obj,MOVE_YSPEED)){return true;}
	// if(ObjMove_GetAngle(obj)==0&&ObjMove_GetSpeed(obj)==0&&OM_GetAcceleration(obj)==0){
	return false;
}




//for moving shit what don't do ObjMove
task Obj_AddPatternA1(obj,fr,s,a){
	wait(fr);
	Obj_SetValue(obj,MOVE_SPEED,s);
	Obj_SetValue(obj,MOVE_ANGLE,a);
	OR_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,MOVE_SPEED,s)==s && Obj_GetValueD(obj,MOVE_ANGLE,a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
	}
}
task Obj_AddPatternA2(obj,fr,s,a,acc,mspd){
	wait(fr);
	Obj_SetValue(obj,"Speed",s);
	Obj_SetValue(obj,"Angle",a);
	Obj_SetValue(obj,"Acceleration",acc);
	Obj_SetValue(obj,"MaxSpeed",mspd);
	let isDecel = (acc<0);
	ObjRender_SetAngleZ(obj,a);
	let dx = s*cos(a); let dy = s*sin(a);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"Speed",s)==s && Obj_GetValueD(obj,"Angle",a)==a){
		ObjRender_SetX(obj,ObjRender_GetX(obj)+dx);
		ObjRender_SetY(obj,ObjRender_GetY(obj)+dy);
		yield;
		s+=acc;
		alternative(isDecel)
		case(true) {s=max(s,mspd);}
		case(false){s=min(s,mspd);}
		Obj_SetValue(obj,"Speed",s);
		dx = s*cos(a); dy = s*sin(a);
	}
}





task OM_SetAngularAcceleration(obj,anga){
	Obj_SetValue(obj,MOVE_ANGACCEL,anga);
	let angv = Obj_GetValueD(obj,MOVE_ANGV,0);
	let mangv = Obj_GetValueD(obj,MOVE_MAXANGV,0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,MOVE_ANGACCEL,0)==anga ){
		angv = Obj_GetValueD(obj,MOVE_ANGV,0);
		mangv = Obj_GetValueD(obj,MOVE_MAXANGV,0);
		if( (|angv|) < (|mangv|) || sign(mangv-angv) == sign(anga) ){
			angv += anga;
			ObjMove_SetAngularVelocity(obj,angv);
			Obj_SetValue(obj,MOVE_MAXANGV,angv);
		}else{
			ObjMove_SetAngularVelocity(obj,mangv);
			Obj_SetValue(obj,MOVE_ANGV,mangv);
			return;
		}
		yield;
	}
}
function OM_SetMaxAngularVelocity(obj,mangv){ Obj_SetValue(obj,MOVE_MAXANGV,mangv); }
function OM_GetAngularAcceleration(obj){ Obj_GetValueD(obj,MOVE_ANGACCEL,0); }
function OM_GetMaxAngularVelocity(obj){ Obj_GetValueD(obj,MOVE_MAXANGV,0); }


task OM_SetJerk(obj,jerk){
	Obj_SetValue(obj,MOVE_JERK,jerk);
	let acc = Obj_GetValueD(obj,MOVE_ACCEL,0);
	let macc = Obj_GetValueD(obj,MOVE_MAXACCEL,0);
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,MOVE_ACCEL,0)==acc ){
		acc = Obj_GetValueD(obj,MOVE_ACCEL,0);
		macc = Obj_GetValueD(obj,MOVE_MAXACCEL,0);
		// if( (|acc|) < (|macc|) || sign(macc-acc) == sign(jerk) ){
		// if( inrange(acc,0,(|macc|)*sign(jerk)) ){
		// if( inrange(acc,99-99*sign(jerk),(|macc|)*sign(jerk)) ){
		// if( (|acc+999|) < (|macc+999|) || sign(macc-acc) == sign(jerk) ){
		if( isapproaching(acc,jerk,macc) ){
			acc += jerk;
			ObjMove_SetAcceleration(obj,acc);
			Obj_SetValue(obj,MOVE_ACCEL,acc);
		}else{
			ObjMove_SetAcceleration(obj,macc);
			Obj_SetValue(obj,MOVE_ACCEL,macc);
			return;
		}
		yield;
	}
}
function OM_SetMaxAcceleration(obj,macc){ Obj_SetValue(obj,MOVE_MAXACCEL,macc); }

function OM_GetJerk(obj){ return Obj_GetValueD(obj,MOVE_JERK,0); }
function OM_GetMaxAcceleration(obj){ return Obj_GetValueD(obj,MOVE_MAXACCEL,9999); }







task OR_SetAngularVelocity(obj,da){
	Obj_SetValue(obj,"RenderAngularVelocity",da);
	if(da==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocity",0)==da){
		ObjRender_SetAngleZ(obj,ObjRender_GetAngleZ(obj)+da);
		yield;
	}
}
task OR_SetAngularVelocityXYZ(obj,dxa,dya,dza){
	Obj_SetValue(obj,"RenderAngularVelocityXYZ",[dxa,dya,dza]);
	if(dxa==0&&dya==0&&dza==0){return;}
	while(!Obj_IsDeleted(obj) && Obj_GetValueD(obj,"RenderAngularVelocityXYZ",[0,0,0])==[dxa,dya,dza]){
		ObjRender_SetAngleXYZ(obj,ObjRender_GetAngleX(obj)+dxa,ObjRender_GetAngleY(obj)+dya,ObjRender_GetAngleZ(obj)+dza);
		yield;
	}
}




function OM_SetSpeed(obj,val){
	ObjMove_SetSpeed(obj,val);
	Obj_SetValue(obj,MOVE_SPEED,val);
	Obj_SetValue(obj,FLAG_XYMOVE,false);
}
function OM_GetSpeed(obj){
	if(!Obj_GetValueD(obj,FLAG_XYMOVE,false)){
		return ObjMove_GetSpeed(obj);
	}else{
		let dx = OM_GetSpeedX(obj);
		let dy = OM_GetSpeedY(obj);
		return (|dx^2+dy^2|)^0.5
	}
}






function OM_SetAngle(obj,val){
	ObjMove_SetAngle(obj,val);
	Obj_SetValue(obj,MOVE_ANGLE,val);
	Obj_SetValue(obj,FLAG_XYMOVE,false);
}
function OM_GetAngle(obj){
	let a;
	alternative(Obj_GetValueD(obj,FLAG_XYMOVE,false))
	case(false){
		// a=Obj_GetValueD(obj,MOVE_ANGLE,ObjMove_GetAngle(obj));		
		a=ObjMove_GetAngle(obj);		
	}
	case(true){
		let dx = OM_GetSpeedX(obj);
		let dy = OM_GetSpeedY(obj);
		a = atan2(dy,dx);
	}
	return a;
}
function OM_SetAcceleration(obj,val){
	ObjMove_SetAcceleration(obj,val);
	Obj_SetValue(obj,MOVE_ACCEL,val);
}
function OM_GetAcceleration(obj){return Obj_GetValueD(obj,MOVE_ACCEL,0);}
function OM_SetMaxSpeed(obj,val){
	ObjMove_SetMaxSpeed(obj,val);
	Obj_SetValue(obj,MOVE_MAXSPEED,val);
}
function OM_GetMaxSpeed(obj){
	// return Obj_GetValueD(obj,MOVE_MAXSPEED,99*sgn(OM_GetSpeed(obj)));
	return Obj_GetValueD(obj,MOVE_MAXSPEED,99*sgn(OM_GetAcceleration(obj)));
}
function OM_SetAngularVelocity(obj,val){
	ObjMove_SetAngularVelocity(obj,val);
	Obj_SetValue(obj,MOVE_ANGV,val);
}
function OM_GetAngularVelocity(obj){return Obj_GetValueD(obj,MOVE_ANGV,0);}





//Add pattern and store parameters in the object's dictionary
function OM_AddPatternA1(obj,del,spd,ang){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	ObjMove_AddPatternA1(obj,del,spd,ang);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
	}
}

function OM_AddPatternA2(obj,del,spd,ang,acc,angv,mspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
	}
}

function OM_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternGraphic",graph);
	ObjMove_AddPatternA3(obj,del,spd,ang,acc,angv,mspd,graph);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
		Obj_SetValue(obj,SHOT_GRAPHIC,graph);
	}
}






function OM_AddPatternA5(obj,del,spd,ang,acc,angv,mspd,jerk,macc,anga,mangv){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternSpeed",spd);
	Obj_SetValue(obj,"PatternAngle",ang);
	Obj_SetValue(obj,"PatternAcceleration",acc);
	Obj_SetValue(obj,"PatternAngularVelocity",angv);
	Obj_SetValue(obj,"PatternMaxSpeed",mspd);
	Obj_SetValue(obj,"PatternJerk",jerk);
	Obj_SetValue(obj,"PatternMaxAcceleration",macc);
	Obj_SetValue(obj,"PatternAngularAcceleration",anga);
	Obj_SetValue(obj,"PatternMaxAngularVelocity",mangv);
	ObjMove_AddPatternA2(obj,del,spd,ang,acc,angv,mspd);
	Manage;
	task Manage{
		wait(del);
		Obj_SetValue(obj,MOVE_SPEED,spd);
		Obj_SetValue(obj,MOVE_ANGLE,ang);
		Obj_SetValue(obj,MOVE_ACCEL,acc);
		Obj_SetValue(obj,MOVE_ANGV,angv);
		Obj_SetValue(obj,MOVE_MAXSPEED,mspd);
		Obj_SetValue(obj,MOVE_JERK,jerk);
		Obj_SetValue(obj,MOVE_MAXACCEL,macc);
		Obj_SetValue(obj,MOVE_ANGACCEL,anga);
		Obj_SetValue(obj,MOVE_MAXANGV,mangv);
		OM_SetJerk(obj,jerk);
		OM_SetAngularAcceleration(obj,anga);
	}
}




function OM_AddPatternB1(obj,del,xspd,yspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	ObjMove_AddPatternB1(obj,del,xspd,yspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,FLAG_XYMOVE,true);
		Obj_SetValue(obj,MOVE_XSPEED,xspd);
		Obj_SetValue(obj,MOVE_YSPEED,yspd);
	}
}
function OM_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd){
	Obj_SetValue(obj,"PatternDelay",del);
	Obj_SetValue(obj,"PatternUseXYSystem",true);
	Obj_SetValue(obj,"PatternUseSASystem",false);
	Obj_SetValue(obj,"PatternXSpeed",xspd);
	Obj_SetValue(obj,"PatternYSpeed",yspd);
	Obj_SetValue(obj,"PatternXAcceleration",xacc);
	Obj_SetValue(obj,"PatternYAcceleration",yacc);
	Obj_SetValue(obj,"PatternXMaxSpeed",xmspd);
	Obj_SetValue(obj,"PatternYMaxSpeed",ymspd);
	ObjMove_AddPatternB2(obj,del,xspd,yspd,xacc,yacc,xmspd,ymspd);
	Update;
	task Update{
		wait(del);
		Obj_SetValue(obj,FLAG_XYMOVE,true);
		Obj_SetValue(obj,MOVE_XSPEED,xspd);
		Obj_SetValue(obj,MOVE_YSPEED,yspd);
		Obj_SetValue(obj,MOVE_XACCEL,xacc);
		Obj_SetValue(obj,MOVE_YACCEL,yacc);
		Obj_SetValue(obj,MOVE_XMAXSPEED,xmspd);
		Obj_SetValue(obj,MOVE_YMAXSPEED,ymspd);
	}
}


function OM_SetPosition(obj,x,y){ObjMove_SetX(obj,x);ObjMove_SetY(obj,y);}
function OM_SetX(obj,v){ObjMove_SetX(obj,v);}
function OM_GetX(obj){return ObjMove_GetX(obj);}
function OM_SetY(obj,v){ObjMove_SetY(obj,v);}
function OM_GetY(obj){return ObjMove_GetY(obj);}
function OM_SetA(obj,v){ObjMove_SetAngle(obj,v);}
function OM_GetA(obj){return ObjMove_GetAngle(obj);}










//XY move setters

function OM_SetSpeedX(obj,xs){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_XSPEED,xs);
	Obj_SetValue(obj,MOVE_XSPEED~MOD_FRAME,frame);
	let ys=OM_GetSpeedY(obj);
	let xa=OM_GetAccelerationY(obj); let ya=OM_GetAccelerationY(obj);
	let xm=OM_GetMaxSpeedX(obj); let ym=OM_GetMaxSpeedY(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,xs,NO_CHANGE,NO_CHANGE,NO_CHANGE,xm,ym);
	// ObjMove_AddPatternB1(obj,0,xs,NO_CHANGE);
	// ObjMove_AddPatternB2(obj,0,xs,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE);
}
function OM_SetSpeedY(obj,ys){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_YSPEED,ys);
	Obj_SetValue(obj,MOVE_YSPEED~MOD_FRAME,frame);
	let xs=OM_GetSpeedX(obj);
	let xa=OM_GetAccelerationY(obj); let ya=OM_GetAccelerationY(obj);
	let xm=OM_GetMaxSpeedX(obj); let ym=OM_GetMaxSpeedY(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,NO_CHANGE,ys,NO_CHANGE,NO_CHANGE,xm,ym);
	// ObjMove_AddPatternB1(obj,0,NO_CHANGE,ys);
	// ObjMove_AddPatternB2(obj,0,NO_CHANGE,ys,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE);
}
function OM_SetAccelerationX(obj,xa){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_XACCEL,xa);
	let xs=OM_GetSpeedX(obj); let ys=OM_GetSpeedY(obj);
	let ya=OM_GetAccelerationY(obj);
	let xm=OM_GetMaxSpeedX(obj); let ym=OM_GetMaxSpeedY(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,xa,NO_CHANGE,xm,ym);
	// ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,xa,NO_CHANGE,NO_CHANGE,NO_CHANGE);
}
function OM_SetAccelerationY(obj,ya){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_YACCEL,ya);
	let xs=OM_GetSpeedX(obj); let ys=OM_GetSpeedY(obj);
	let xa=OM_GetAccelerationX(obj);
	let xm=OM_GetMaxSpeedX(obj); let ym=OM_GetMaxSpeedY(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,ya,xm,ym);
	// ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,ya,NO_CHANGE,NO_CHANGE);
}
function OM_SetMaxSpeedX(obj,xm){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_XMAXSPEED,xm);
	let xs=OM_GetSpeedX(obj); let ys=OM_GetSpeedY(obj);
	let xa=OM_GetAccelerationX(obj); let ya=OM_GetAccelerationY(obj);
	let ym=OM_GetMaxSpeedY(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,xm,ym);
	// ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,xm,NO_CHANGE);
}
function OM_SetMaxSpeedY(obj,ym){
	Obj_SetValue(obj,FLAG_XYMOVE,true);
	Obj_SetValue(obj,MOVE_XMAXSPEED,ym);
	let xs=OM_GetSpeedX(obj); let ys=OM_GetSpeedY(obj);
	let xa=OM_GetAccelerationX(obj); let ya=OM_GetAccelerationY(obj);
	let xm=OM_GetMaxSpeedX(obj);
	// ObjMove_AddPatternB2(obj,0,xs,ys,xa,ya,xm,ym);
	ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,xm,ym);
	// ObjMove_AddPatternB2(obj,0,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,NO_CHANGE,ym);
}


//XY move getters

function OM_GetSpeedX(obj){
	if(Obj_IsValueExists(obj,MOVE_XSPEED)){
		let a = OM_GetAccelerationX(obj);
		let t = frame-Obj_GetValueD(obj,MOVE_XSPEED~MOD_FRAME,frame);
		let m = OM_GetMaxSpeedX(obj);
		let s = Obj_GetValue(obj,MOVE_XSPEED);
		return s + 0.5*a*t^2;
	}else{
		if(Obj_GetValueD(obj,FLAG_XYMOVE,false)){
			return NULL; //shouldn't happen
		}else{
			return ObjMove_GetSpeed(obj)*cos(ObjMove_GetAngle(obj));
		}
	}
}
function OM_GetSpeedY(obj){
	if(Obj_IsValueExists(obj,MOVE_YSPEED)){
		let a = OM_GetAccelerationY(obj);
		let t = frame-Obj_GetValueD(obj,MOVE_YSPEED~MOD_FRAME,frame);
		return Obj_GetValue(obj,MOVE_YSPEED) + 0.5*a*t^2;
	}else{
		if(Obj_GetValueD(obj,FLAG_XYMOVE,false)){
			return NULL; //shouldn't happen
		}else{
			return ObjMove_GetSpeed(obj)*sin(ObjMove_GetAngle(obj));
		}
	}
}

function OM_GetAccelerationX(obj){
	if(Obj_IsValueExists(obj,MOVE_XACCEL)){
		return Obj_GetValue(obj,MOVE_XACCEL);
	}else{
		if(Obj_GetValueD(obj,FLAG_XYMOVE,false)){
			return NULL; //shouldn't happen
		}else{
			return OM_GetAcceleration(obj)*cos(ObjMove_GetAngle(obj));
		}
	}
}
function OM_GetAccelerationY(obj){
	if(Obj_IsValueExists(obj,MOVE_YACCEL)){
		return Obj_GetValue(obj,MOVE_YACCEL);
	}else{
		if(Obj_GetValueD(obj,FLAG_XYMOVE,false)){
			return NULL; //shouldn't happen
		}else{
			return OM_GetAcceleration(obj)*sin(ObjMove_GetAngle(obj));
		}
	}
}

function OM_GetMaxSpeedX(obj){
	if(Obj_IsValueExists(obj,MOVE_XMAXSPEED)){
		return Obj_GetValue(obj,MOVE_XMAXSPEED);
	}else{
		let a = 99*sgn(OM_GetAccelerationX(obj));
		if(a!=0){return a;}
		return OM_GetMaxSpeed(obj)*cos(ObjMove_GetAngle(obj));
	}
}

function OM_GetMaxSpeedY(obj){
	if(Obj_IsValueExists(obj,MOVE_YMAXSPEED)){
		return Obj_GetValue(obj,MOVE_YMAXSPEED);
	}else{
		let a = 99*sgn(OM_GetAccelerationY(obj));
		if(a!=0){return a;}
		return OM_GetMaxSpeed(obj)*sin(ObjMove_GetAngle(obj));
	}
}





// function OM_GetSpeedX(obj){return Obj_GetValueD(obj,MOVE_XSPEED,OM_GetSpeed(obj)*cos(OM_GetAngle(obj)));}
// function OM_GetSpeedY(obj){return Obj_GetValueD(obj,MOVE_YSPEED,OM_GetSpeed(obj)*sin(OM_GetAngle(obj)));}
// function OM_GetAccelerationX(obj){return Obj_GetValueD(obj,MOVE_XACCEL,OM_GetAcceleration(obj)*cos(OM_GetAngle(obj)));}
// function OM_GetAccelerationY(obj){return Obj_GetValueD(obj,MOVE_YACCEL,OM_GetAcceleration(obj)*sin(OM_GetAngle(obj)));}
// function OM_GetMaxSpeedX(obj){
	// return Obj_GetValueD(obj,MOVE_XMAXSPEED,99*sgn(OM_GetAccelerationX(obj)));
// }
// function OM_GetMaxSpeedY(obj){
	// return Obj_GetValueD(obj,MOVE_YMAXSPEED,99*sgn(OM_GetAccelerationY(obj)));
// }




task OM_Still(obj,time){
	if(!OM_IsXYMove(obj)){
		OM_SetAcceleration(obj,0);
		let s0 = ObjMove_GetSpeed(obj);
		let dS = s0/time;
		descent(i in 0..time){
			OM_SetSpeed(obj, s0*(i/time)^2 );
			yield;
		}
		OM_SetSpeed(obj,0);
		OM_SetAcceleration(obj,0);
		OM_SetAngularVelocity(obj,0);
	}else{
		OM_SetAccelerationX(obj,0); OM_SetAccelerationY(obj,0);
		let xs0 = OM_GetSpeedX(obj); let dxs = xs0/time;
		let ys0 = OM_GetSpeedY(obj); let dys = ys0/time;
		descent(i in 0..time){
			OM_SetSpeedX(obj, xs0*(i/time)^2 ); 
			OM_SetSpeedY(obj, ys0*(i/time)^2 );
			yield;
		}
		OM_SetSpeedX(obj,0); OM_SetSpeedY(obj,0);
		OM_SetAccelerationX(obj,0); OM_SetAccelerationY(obj,0);
	}
}
function ObjMove_Still(obj,time){OM_Still(obj,time);}










//Simulate 3D position for 2D objects
//Z=0: normal plane; Z=100: fully receded; Z=-100: fully proceded
//Intentionally don't store new values, so "true" ones remain stored
let sz=400;
function OM_SetZ(obj,z){
	Obj_SetValue(obj,MOVE_Z,z);
	let t = z/sz; //-1..0..1 //t=0 when normal, t->1 in bg, t->-1 in fg
	let c = OR_GetColor(obj);
	let r = c[0]/2+128; let g = c[1]/2+128; let b = c[2]/2+128;
	let Sx = Obj_GetValueD(obj,RENDER_SCALEX,1);
	let Sy = Obj_GetValueD(obj,RENDER_SCALEY,1);
	let A = OR_GetAlpha(obj);
	
	let pri = O_GetRenderPriorityI(obj);
	if(!Obj_IsValueExists(obj,RENDER_PRIORITY)){
		Obj_SetValue(obj,RENDER_PRIORITY,pri);
	}
	Obj_SetRenderPriorityI(obj,pri-0.5*t); // 5*t  //10*t
	
	ObjRender_SetColor(obj, r-r/2*t, g-g/2*t, b-b/2*t );
	// ObjRender_SetColor(obj, r-r/2*(|t|), g-g/2*(|t|), b-b/2*(|t|) );
	if(z>=0){
		ObjRender_SetAlpha(obj, A-A/2*(|t|));
		ObjRender_SetScaleXYZ(obj,Sx*(|1-t|),Sy*(|1-t|),1);
	}else{
		// ObjRender_SetAlpha(obj, A-A*2*(|t|)^0.5);
		// ObjRender_SetScaleXYZ(obj,Sx*(1+(|t|)^0.25),Sy*(1+(|t|)^0.25),1);
		ObjRender_SetAlpha(obj, A-A*5*(|t/10|)^0.5);
		ObjRender_SetScaleXYZ(obj,Sx*(1+(|t|)^0.25),Sy*(1+(|t|)^0.25),1);
	}
	
	
	// let collide = (|z|) <= OC_GetIntersectionRadius(obj);
	if(O_GetType(obj)==OBJ_SHOT){
		let collide = ( Obj_GetValueD(obj,FLAG_INTERSECTION,true) && ((|z|)<=OC_GetIntersectionRadius(obj)) );
		ObjShot_SetIntersectionEnable(obj,collide);
	}else{ 
		OC_SetIntersectionEnable(obj, (|z|)<=OC_GetIntersectionRadius(obj) );
	}
	
}

function OM_GetZ(obj){
	return Obj_GetValueD(obj,MOVE_Z,0);
}











//////////////////////////////////////////////////////////////////
// Intersection Functions
//////////////////////////////////////////////////////////////////





//Determine if two line segments intersect
function IsIntersected_Line_Line(ax0,ay0,ax1,ay1,  bx0,by0,bx1,by1) {
	//Convert vector 1 to equation - A*x + B*y + C
	let e_a1 = ay1-ay0;
	let e_b1 = ax0-ax1;
	let e_c1 = (ax1*ay0) - (ax0*ay1);
	
	//Plug endpoints of vector 2 into that equation
	let e_d1 = (e_a1*bx0) + (e_b1*by0) + e_c1;
	let e_d2 = (e_a1*bx1) + (e_b1*by1) + e_c1;
	
	//If d1 and d2 have the same sign, they are both on same side of first line
	//and therefore the lines cannot intersect
	//0 is a special case
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Since we were treating vector 1 an an infinite line, 
	//we need to repeat that check treating vector 2 as an infinite line instead
	
	//Convert to equation
	let e_a2 = by1-by0;
	let e_b2 = bx0-bx1;
	let e_c2 = (bx1*by0) - (bx0*by1);
	//Plug in endpoints of vector 1
	e_d1 = (e_a2*ax0) + (e_b2*ay0) + e_c2;
	e_d2 = (e_a2*ax1) + (e_b2*ay1) + e_c2;
	//Check if they're on the same side of vector 1
	if((e_d1>0&&e_d2>0)||(e_d1<0&&e_d2<0)){
		return false;
	}
	
	//Check if they're colinear, i.e. intersecting at way too many points
	//Technically this should be its own case but I don't really care
	//It's not exactly a collision and it's unlikely to ever come up anyway
	if( (e_a1*e_b2)-(e_a2*e_b1) < 0.001 ) {
		return false;
	}
	
	//Well, we've eliminated all the other possibilities I can think of
	//So we'll assume they intersect
	return true;
}

//Find point at which two line segments intersect
function GetIntersection_Line_Line(x0,y0,x1,y1,  x2,y2,x3,y3) {
	//Convert vector 1 to equation - 
	//A*x + B*y + C
	let a1 = y1-y0;
	let b1 = x0-x1;
	let c1 = (x1*y0) - (x0*y1);
	//Convert vector 2 to equation - 
	//A*x + B*y + C
	let a2 = y3-y2;
	let b2 = x2-x3;
	let c2 = (x3*y2) - (x2*y3);
	
	//  a1x*a2x + b1y*a2x - c1*a2x = 0
	//  a2x*a1x + b2y*a1x - c2*a1x = 0
	
	//   b1y*a2x - b2y*a1x   =  c1*a2x - c2*a1x
	//   yx( b1*a2 ) - yx(b2*a1)   =  x(c1*a2) - x(c2*a1)
	//   (c1*a2 - c2*a1)/(b1*a2 - b2*a1) = y
	
	let x = (c1*b2-c2*b1)/(a1*b2-a2*b1);
	let y = (c1*a2 - c2*a1)/(b1*a2 - b2*a1);
	
	if(min(x0,x1)<=x && x <= max(x0,x1) && min(y0,y1)<=y && y <= max(y0,y1)) {
		return [x,y];
	}else{
		return [NULL,NULL];
	}
}

//////////////////////////////////////////////////////////////////
//Collision Object Functions
//////////////////////////////////////////////////////////////////

function OC_GetIntersectionRadius(obj){
	// if(!OC_IsIntersectionEnable(obj)){return 0;}
	if(Obj_IsValueExists(obj,COL_RADIUS)){
		return Obj_GetValue(obj,COL_RADIUS);
	}
	if(Obj_IsValueExists(obj,"CollisionObject")){
		let r = OC_GetIntersectionRadius(Obj_GetValue(obj,"CollisionObject"));
		if(r>0){return r;}
	}
	//default values
	alternative(O_GetType(obj))
	case(OBJ_SHOT){return OS_GetCollisionRadius(obj)*OR_GetScale(obj);}
	case(OBJ_ENEMY){return 10;}
	others{return 0;}
}
function OC_SetIntersectionRadius(obj,v){
	if(O_GetType(obj)==OBJ_SHOT){
		// let base = OS_GetCollisionRadius(obj)/OR_GetScale(obj);
		let base = OS_GetCollisionRadius(obj);
		OR_SetScale(obj,v/base);
		Obj_SetValue(obj,COL_SCALE,v/base);
	}
	Obj_SetValue(obj,COL_RADIUS,v);
	if(!Obj_IsValueExists(obj,"CollisionManagerHash")){
		ManageCollisionRadius(obj,v);
	}
	// ManageCollisionRadius(obj,v);
	
	task ManageCollisionRadius(obj,r){
		if(typeof(obj)==OBJ_SHOT){ ObjShot_SetIntersectionEnable(obj,false); }
		let dummy = CreateDummyShot(0,0);
		Obj_SetValue(obj,"CollisionObject",dummy);
		Obj_SetValue(dummy,COL_RADIUS,r);
		if(O_GetType(obj)==OBJ_SHOT){
			Obj_SetValue(dummy,COL_SCALE,r/OS_GetCollisionRadius(obj));
		}
		
		let hash = GetNextHash;
		Obj_SetValue(obj,"CollisionManagerHash",hash);
		while(!Obj_IsDeleted(obj)&&Obj_GetValueD(obj,"CollisionManagerHash",0)==hash){
			let x = ObjMove_GetX(obj); let y = ObjMove_GetY(obj);
			ObjMove_SetPosition(dummy,x,y);
			r = Obj_GetValueD(obj,COL_RADIUS,r);
			ObjShot_SetIntersectionCircleA1(dummy,r);
			yield;
		}
		Obj_Delete(dummy);
		ObjShot_SetIntersectionEnable(obj,Obj_GetValueD(obj,FLAG_INTERSECTION,true));
	}
}


function OC_SetIntersectionEnable(obj,intersect){
	Obj_SetValue(obj,FLAG_INTERSECTION,intersect); 
	if(O_GetType(obj)==OBJ_SHOT){
		ObjShot_SetIntersectionEnable(obj,intersect);
	}
}
function OC_IsIntersectionEnable(obj){
	if(Obj_IsValueExists(obj,FLAG_INTERSECTION)){return Obj_GetValue(obj,FLAG_INTERSECTION);}
	else{
		alternative(O_GetType(obj))
		case(OBJ_SHOT){return !( Obj_GetValueD(obj,FLAG_DUMMY,false) || (ObjShot_GetImageID(obj)==0) );}
		case(OBJ_ENEMY){return true;}
		others{return false;}
	}
}






function OS_SetIntersectionEnable(obj,intersect){
	Obj_SetValue(obj,FLAG_INTERSECTION,intersect); 
	ObjShot_SetIntersectionEnable(obj,intersect);	
}
function OS_IsIntersectionEnable(obj){
	return OC_IsIntersectionEnable(obj); 
}



function OS_SetScale(obj,scl){
	let sclx = OR_GetScaleX(obj);
	let scly = OR_GetScaleY(obj);
	let ratio = (|sclx/scly|);
	OS_SetScaleXYZ(obj,scl*ratio*sign(sclx),scl/ratio*sign(scly),ObjRender_GetScaleZ(obj));
	Obj_SetValue(obj,RENDER_SCALE,scl);
	Obj_SetValue(obj,COL_SCALE,scl);
}
function OS_SetScaleXYZ(obj,xscl,yscl,zscl){
	let v = max(xscl,yscl);
	let base = OS_GetBaseHitbox(obj);
	Obj_SetValue(obj,COL_SCALE,v/base);
	Obj_SetValue(obj,COL_RADIUS,v);
	
	OR_SetScaleXYZ(obj,xscl,yscl,zscl);
		
	if(!Obj_IsValueExists(obj,"CollisionManagerHash")){
		ManageCollisionRadius(obj,v);
	}
	
	task ManageCollisionRadius(obj,r){
		if(typeof(obj)==OBJ_SHOT){ ObjShot_SetIntersectionEnable(obj,false); }
		let dummy = CreateDummyShot(0,0);
		Obj_SetValue(obj,"CollisionObject",dummy);
		Obj_SetValue(dummy,COL_RADIUS,r);
		if(O_GetType(obj)==OBJ_SHOT){
			Obj_SetValue(dummy,COL_SCALE,r/OS_GetCollisionRadius(obj));
		}
		
		let hash = GetNextHash;
		Obj_SetValue(obj,"CollisionManagerHash",hash);
		// while(!Obj_IsDeleted(obj)&&Obj_GetValueD(obj,"CollisionManagerHash",0)==hash){
		while(!Obj_IsDeleted(obj)){
			let x = ObjMove_GetX(obj); let y = ObjMove_GetY(obj);
			ObjMove_SetPosition(dummy,x,y);
			r = Obj_GetValueD(obj,COL_RADIUS,r);
			ObjShot_SetIntersectionCircleA1(dummy,r);
			yield;
		}
		Obj_Delete(dummy);
		ObjShot_SetIntersectionEnable(obj,Obj_GetValueD(obj,FLAG_INTERSECTION,true));
	}
}










//////////////////////////////////////////////////////////////////
// Laser Object Functions
//////////////////////////////////////////////////////////////////

task ObjStLaser_SetAngularVelocity(las,angv){
	Obj_SetValue(las,"AngularVelocity",angv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularVelocity",angv)==angv){
		ObjStLaser_SetAngle(las,ObjStLaser_GetAngle(las)+angv);
		yield;
	}
}
task ObjStLaser_SetAngularAcceleration(las,anga){
	Obj_SetValue(las,"AngularAcceleration",anga);
	let angv = Obj_GetValueD(las,"AngularVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"AngularAcceleration",0)==anga ){
		angv = Obj_GetValueD(las,"AngularVelocity",0);
		if( (|angv|) < (|Obj_GetValueD(las,"MaxAngularVelocity",3)|) ){
			ObjStLaser_SetAngularVelocity(las,angv+anga);
			Obj_SetValue(las,"AngularVelocity",angv+anga);
		}
		yield;
	}
}
function ObjStLaser_SetMaxAngularVelocity(las,mangv){OM_SetMaxAngularVelocity(las,mangv);}

function ObjStLaser_SetTipPosition(las,x,y){
	let x0 = ObjMove_GetX(las);	let y0 = ObjMove_GetY(las);
	let len = getdistance(x0,y0,x,y);
	let ang = getangle(x0,y0,x,y);
	ObjLaser_SetLength(las,len);
	ObjStLaser_SetAngle(las,ang);
}

task ObjLaser_SetExtendVelocity(las,extv){
	Obj_SetValue(las,"ExtendVelocity",extv);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendVelocity",0)==extv && Obj_GetValueD(las,"MaxExtendLength",0)>=ObjLaser_GetLength(las)){
		ObjLaser_SetLength(las,ObjLaser_GetLength(las)+extv);
		yield;
	}
}
task ObjLaser_SetExtendAcceleration(las,exta){
	Obj_SetValue(las,"ExtendAcceleration",exta);
	let extv = Obj_GetValueD(las,"ExtendVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExtendAcceleration",0)==exta ){
		extv = Obj_GetValueD(las,"ExtendVelocity",0);
		if( (|extv|) < (|Obj_GetValueD(las,"MaxExtendVelocity",2)|) ){
			ObjLaser_SetExtendVelocity(las,extv+exta);
			Obj_SetValue(las,"ExtendVelocity",extv+exta);
		}
		yield;
	}
}
function ObjLaser_SetMaxExtendVelocity(las,mextv){
	Obj_SetValue(las,"MaxExtendVelocity",mextv);
}
function ObjLaser_SetMaxExtendLength(las,mextl){
	Obj_SetValue(las,"MaxExtendLength",mextl);
}

task ObjLaser_SetExpandVelocity(las,expv){
	Obj_SetValue(las,"ExpandVelocity",expv); let width;
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandVelocity",0)==expv){
		width = Obj_GetValueD(las,"Width",15);
		if(width < Obj_GetValueD(las,"MaxExpandWidth",50)) {
			ObjLaser_SetRenderWidth(las,width+expv);
			ObjLaser_SetIntersectionWidth(las,(width+expv)/3);
			Obj_SetValue(las,"Width",width+expv);
		}
		yield;
	}
}
task ObjLaser_SetExpandAcceleration(las,expa){
	Obj_SetValue(las,"ExpandAcceleration",expa);
	let expv = Obj_GetValueD(las,"ExpandVelocity",0);
	while(!Obj_IsDeleted(las) && Obj_GetValueD(las,"ExpandAcceleration",0)==expa ){
		expv = Obj_GetValueD(las,"ExpandVelocity",0);
		if( (|expv|) < (|Obj_GetValueD(las,"MaxExpandVelocity",3)|) ){
			ObjLaser_SetExpandVelocity(las,expv+expa);
		}
		yield;
	}
}
function ObjLaser_SetMaxExpandVelocity(las,mexpv){
	Obj_SetValue(las,"MaxExpandVelocity",mexpv);
}
function ObjLaser_SetMaxExpandWidth(las,mexpw){
	Obj_SetValue(las,"MaxExpandWidth",mexpw);
}

