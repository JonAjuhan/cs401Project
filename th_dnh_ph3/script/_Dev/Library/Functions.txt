//REQUIRES:
#include "./Resources.txt"
#include "./ExtendedDNF.txt"
// #include "./Cutin/Cutin.txt"

//?

//TODO: Function to distort screen like SampleE1 but in a wave

//Functions to do things rather than be used by other functions



let BREAK_DELAY = 999901; let BREAK_DEAD = 999902;
//"standardized" TFinalize
task TBreakSpell(args) {
	SaveBossPositions;
//	let del=checkarr(args,BREAK_DELAY);if(del==-1){del=15;}else{del=args[del+1];}
//	let ded=checkarr(args,BREAK_DEAD);
//	if(ded==-1){
		// SE_Play(spellbreak,100);
//	}else{
//		del=1; //
//		//SE_Play(defeated,100);
//		//SetAutoDeleteObject(false);
//	}
	yield;
	yield;
	let boss = GetEnemyBossObjectID[0];
	
	// loop(3){yield;}
//	
//	
	// DeleteShotAllOut(TYPE_ALL, TYPE_ITEM, ObjMove_GetX(boss), ObjMove_GetY(boss),del);
	// DeleteShotAll(TYPE_ALL, TYPE_ITEM);
//	//AfterImageCircle(ex,ey,[255,255,255,255],1,20,30,BLEND_ADD_ARGB,79);
//	let eff = GlowCircle(ex,ey,[255,255,255,255],1,20,30);
//	Obj_SetRenderPriorityI(eff,79);
//	
//	
//	wait(del);
	ClearInvalidRenderPriority();
	if(!Obj_IsDeleted(boss)){Obj_Delete(boss);}
	CloseScript(GetOwnScriptID());
	return;
}
task TBreakNonspell(args) {
	SaveBossPositions;
//	let doeffect = checkarr(args,NULL)==-1;
//	if(doeffect){
		// SE_Play(spellbreak,100);
//		let eff = GlowCircle(ex,ey,[255,255,255,255],1,20,30);
//		Obj_SetRenderPriorityI(eff,79);
//	}
	yield;
	let boss = GetEnemyBossObjectID[0];
//	
//	let del=checkarr(args,BREAK_DELAY); if(del==-1){del=15;}else{del=args[del+1];}
//	// DeleteShotAll(TYPE_ALL, TYPE_FADE);
	// DeleteShotAllOut(TYPE_ALL, TYPE_ITEM, ObjMove_GetX(boss), ObjMove_GetY(boss), del);
	loop(3){
		DeleteShotAll(TYPE_ALL, TYPE_ITEM);
		yield;
	}
//	
//	loop(del){ DeleteShotAll(TYPE_ALL, TYPE_ITEM); yield; }
	ClearInvalidRenderPriority();
	if(!Obj_IsDeleted(boss)){Obj_Delete(boss);}
	CloseScript(GetOwnScriptID());
	return;
}


























function CheckGameOver{
	if(GetPlayerLife < 0){
		FadeBGM;
		CloseStgScene;
		// let EndMenuScript = LoadScriptInThread(dirsys~"EndScene.txt");
		// StartScript(EndMenuScript);
		// while(!IsCloseScript(EndMenuScript)){yield;}
		// let result = NULL;
		// result = GetScriptResult(EndMenuScript);
		// if(result != RESULT_CANCEL){
			// CloseStgScene;
		// }else{
			// ResumeBGM;
		// }
	}
}




//Display "Item Get Border Line" - TresserT
task ShowPointOfCollection{
	// loop(30){yield;}
	let height = GetCommonData("PointOfCollection",GetStgFrameHeight*0.25);
	let text = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(text,dirsys~"img/Default_System.png");
	ObjSprite2D_SetSourceRect(text,18,130,174,152);
	// ObjSprite2D_SetDestRect(text,-78*1.5,-6*1.5,78*1.5,6*1.5);
	ObjSprite2D_SetDestRect(text,-78,-7, 78,9);
	ObjRender_SetPosition(text,GetStgFrameWidth/2,height-15,0); //-20
	Obj_SetRenderPriority(text,0.29);
	
	let spread = 3; let opacity = 0.5;
	let obj = [];
	ascent(i in 0..spread){
		obj = obj ~ [ObjPrim_Create(OBJ_SPRITE_2D)];
		ObjPrim_SetTexture(obj[i],dirsys~"img/Default_System.png");
		ObjSprite2D_SetSourceRect(obj[i],0,158,168,166);
		ObjRender_SetColorHSV(obj[i],(spread-i)*135/spread,255,255);
		ObjRender_SetAlpha(obj[i],255*opacity);
		Obj_SetRenderPriority(obj[i],0.29);
	}
	
	let blend = BLEND_ALPHA;
	ascent(t in 0..135){
		let alpha = min(255,t*255/30) * opacity;
		if(t > 105){ alpha = (135-t)*255/30 * opacity; }
		let dist = min(1,t*1/30);
		ascent(i in 0..spread){
			ObjSprite2D_SetDestRect(obj[i],GetStgFrameWidth/2-t*GetStgFrameWidth/2,height-1.5+(i*i)*2/(spread*spread),GetStgFrameWidth/2+t*GetStgFrameWidth/2,height+1.5+(i*i)*2/(spread*spread));
			ObjRender_SetAlpha(obj[i],alpha);
			ObjRender_SetBlendType(obj[i],blend);
		}
		ObjRender_SetAlpha(text,alpha);
		ObjRender_SetBlendType(text,blend);
		// if(t%10 == 0){ blend = BLEND_ALPHA; }
		// else if(t%10 == 5){ blend = BLEND_ADD_ARGB; }
		if(t%20 == 0){ blend = BLEND_ALPHA; }
		else if(t%20 == 10){ blend = BLEND_ADD_ARGB; }
		yield;
	}
	Obj_Delete(text);
	ascent(i in 0..spread){ Obj_Delete(obj[i]); }
}



//image rect should be around 160 by 160, auto scaled if not	//e.g. "rose.png",[0,0,64,64]
task StageIntro(stagetext,titletext,subtitletext,img,source){
	// let img = dirimg~"StageIntro.png";
	let pic = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(pic, img);
	// ObjSprite2D_SetSourceRect(pic, 320, 0, 480, 160);
	ObjSprite2D_SetSourceRect(pic, source[0], source[1], source[2], source[3]);
	ObjSprite2D_SetDestCenter(pic);
	
	let xscale = 160/(source[2]-source[0]);
	// let yscale = 160/(source[3]-source[1]);
	
	let stage = makeText(cx-60,cy-114,    14,[0,0,255],ALIGNMENT_CENTER, 0, stagetext);
	ObjText_SetFontColorTop(   stage, 255, 255, 255);
	ObjText_SetFontColorBottom(stage, 180, 180, 255);
	ObjText_SetFontBorderColor(stage,   0,   0, 255);
	// ObjText_SetFontBorderType( stage,BORDER_SHADOW);
	// ObjText_SetFontType(stage, "Gyosho");
	ObjText_SetFontType(stage, "Gyosho");
	
	let title = makeText(cx,cy-96,    32,[0,0,255],ALIGNMENT_CENTER, 0, titletext);
	ObjText_SetFontColorTop(   title, 255, 255, 200);
	ObjText_SetFontColorBottom(title, 255, 255, 128);
	ObjText_SetFontBorderColor(title,  64,  64, 200);
	// ObjText_SetFontBorderType( title,BORDER_SHADOW);
	ObjText_SetFontBold(title,true);
	// ObjText_SetFontType(title, "Gyosho");
	// ObjText_SetFontType(title, "SpinCycleOT");
	ObjText_SetFontType(title, "Gyosho");
	
	let desc = makeText(cx+60,cy-24,  16,[0,0,255],ALIGNMENT_CENTER, 0, subtitletext);
	ObjText_SetFontColorTop(   desc, 255, 255, 255);
	ObjText_SetFontColorBottom(desc, 180, 180, 255);
	ObjText_SetFontBorderColor(desc,   0,   0, 255);
	// ObjText_SetFontBorderType( desc,BORDER_SHADOW);
	// ObjText_SetFontType(desc, "Gyosho");
	ObjText_SetFontType(desc, "Gyosho");
	

	ObjRender_SetPosition(pic, GetCenterX + 80, GetCenterY - 64, 0);
	ObjRender_SetAngleZ(pic, 90);
	// ObjRender_SetPosition(title, GetCenterX, GetCenterY - 96, 0);
	// ObjRender_SetPosition(desc, GetCenterX, GetCenterY, 0);

	ObjRender_SetAlpha(pic, 0);
	ObjRender_SetAlpha(title, 0);
	ObjRender_SetAlpha(desc, 0);

	Obj_SetRenderPriority(pic, 0.73);
	Obj_SetRenderPriority(title, 0.731);
	Obj_SetRenderPriority(desc, 0.731);

	renderpic;
	wait(90);
	renderstage;
	wait(30);
	rendertitle;
	wait(60);
	rendertext;

	task renderpic{
		let alpha = 0;
		let a = 90;
		let scale = 2;
		while(alpha < 255){
			ObjRender_SetScaleXYZ(pic, scale*xscale, scale*xscale, scale);
			ObjRender_SetAlpha(pic, alpha);
			ObjRender_SetAngleZ(pic, a);
			alpha += 2;
			a -= 0.7;
			scale -= 1/128;
			yield;
		}
		wait(150);
		while(alpha > 0){
			ObjRender_SetScaleXYZ(pic, scale*xscale, scale*xscale, scale);
			ObjRender_SetAlpha(pic, alpha);
			alpha -= 2;
			scale -= 1/128;
			if(scale <= 0){Obj_Delete(pic);}
			yield;
		}
	}
	task rendertitle{
		let alpha = 0;
		while(alpha < 255){
			ObjRender_SetAlpha(title, alpha*1.0);
			alpha += 5;
			yield;
		}
		wait(120);
		while(alpha > 0){
			ObjRender_SetAlpha(title, alpha*1.0);
			alpha -= 5;
			yield;
		}
		Obj_Delete(title);
	}
	task rendertext{
		let alpha = 0;	
		while(alpha < 255){
			ObjRender_SetAlpha(desc, alpha*0.8);
			alpha += 5;
			yield;
		}
		wait(60);
		while(alpha > 0){
			ObjRender_SetAlpha(desc, alpha*0.8);
			alpha -= 5;
			yield;
		}
		Obj_Delete(desc);
	}
	task renderstage{
		let alpha = 0;	
		while(alpha < 255){
			ObjRender_SetAlpha(stage, alpha*0.8);
			alpha += 5;
			yield;
		}
		wait(150);
		while(alpha > 0){
			ObjRender_SetAlpha(stage, alpha*0.8);
			alpha -= 5;
			yield;
		}
		Obj_Delete(stage);
	}
}

//call in end single
function StageOutro(stagenum){
	let isExtra = (stagenum > 6);
	let isFinal = (stagenum == 6);
	let isAllClear = (isFinal || isExtra);
	
	
	
	let lcol = cx;
	let rcol = cx+96;
	
	let y0 = 106;
	let dy = 16;
	
	let fadeindel = 0;
	let bonus = 0;
	
	function CreateLeftColumnText(row){
		// let obj = ObjText_CreateA1(16,"THSpatial",[255,128,64]);
		let obj = ObjText_CreateA1(16,"THSpatial",[255,128,64]);
		ObjText_SetFontColorTop(obj,255,200,200);
		ObjText_SetMaxWidth(obj,lcol);
		ObjText_SetHorizontalAlignment(obj,ALIGNMENT_RIGHT);
		ObjText_SetFontBold(obj,true);
		ObjRender_SetX(obj,0);
		ObjRender_SetY(obj,y0+row*dy);
		FadeInText(obj,row);
		return obj;
	}
	function CreateRightColumnText(row){
		let obj = ObjText_CreateA1(16,"THSpatial",[255,128,64]);
		ObjText_SetFontColorTop(obj,255,200,200);
		ObjText_SetMaxWidth(obj,rcol);
		ObjText_SetHorizontalAlignment(obj,ALIGNMENT_RIGHT);		
		ObjText_SetFontBold(obj,true);
		ObjRender_SetX(obj,0);
		ObjRender_SetY(obj,y0+row*dy);
		FadeInText(obj,row);
		return obj;
	}
	task FadeInText(obj,row){
		let del = 5*row;
		let t = 45;
		fadeindel = max(fadeindel,del+t);
		ObjRender_SetAlpha(obj,0);
		wait(del);
		ascent(i in 0..t){
			ObjRender_SetAlpha(obj,i*255/t); //235
			yield;
		}
	}
	task FadeInFlash(obj){
		let i = 0;
		while(!Obj_IsDeleted(obj)){
			ObjRender_SetAlpha(obj,min(4*i,255)*( 0.6+0.4*(|cos(3*i)|)^0.5) );
			yield; i++;
		}
	}
	
	let obj_stagenum = CreateLeftColumnText(1);
	let obj_stagebonus = CreateRightColumnText(1);
	let stagenumstr = "Stage "~tost(stagenum);
	if(isExtra){ stagenumstr="Stage EX ";}
	if(isFinal){ stagenumstr="All "; }
	ObjText_SetText(obj_stagenum,stagenumstr~" Clear!");
	// let stagebonusnum = 1000000*stagenum;
	let stagebonusnum = 1000000*2^(stagenum-1);
	let stagebonustext = ObjText_CreateA1(16,"THSpatial",[255,128,64]);	
	ObjText_SetText(obj_stagebonus,tost(stagebonusnum));
	bonus += stagebonusnum;
	
	let obj_playernum = CreateLeftColumnText(5);
	let obj_spellnum = CreateLeftColumnText(6);
	let obj_playerbonus = CreateRightColumnText(5);
	let obj_spellbonus = CreateRightColumnText(6);
	if(isAllClear){
		
		let lives = floor(GetPlayerLife());
		ObjText_SetText(obj_playernum,"Player Bonus");
		ObjText_SetText(obj_playerbonus,tost(lives)~" * 5000000");
		bonus += 5000000*lives;
		
		let bombs = floor(GetPlayerSpell());
		ObjText_SetText(obj_spellnum,"Spell Bonus");
		ObjText_SetText(obj_spellbonus,tost(bombs)~" * 1000000");
		bonus += 1000000*bombs;
		
	}
	
	let obj_capturenum = CreateLeftColumnText(3);
	let obj_capturebonus = CreateRightColumnText(3);
	
	let captured = GetCommonData("SpellsCaptured",0);
	let captureval = 1000000*stagenum;
	SetCommonData("TotalSpellsCaptured",captured+GetCommonData("TotalSpellsCaptured",0));
	ObjText_SetText(obj_capturenum,"Capture Bonus");
	ObjText_SetText(obj_capturebonus,tost(captured)~" * "~tost(captureval));
	bonus += captured*captureval;
	
	
	
	
	let obj_diff = CreateLeftColumnText(8);
	let diffstring = GetCommonData("Difficulty","Normal")~" Rank";
	ObjText_SetText(obj_diff,diffstring);
	
	let obj_diffmod = CreateRightColumnText(8);
	let diffmod=0;
	alternative(rank)
	case(RANK_EASY){ diffmod = 0.5; }
	case(RANK_NORM){ diffmod = 1.0; }
	case(RANK_HARD){ diffmod = 1.5; }
	case(RANK_LUNA){ diffmod = 2.0; }
	if(isExtra)    { diffmod = 2.0; }
	let diffmodstr = "* "~vtos("1.01f",diffmod);
	ObjText_SetText(obj_diffmod,diffmodstr);
	
	let obj_finalbonus = CreateRightColumnText(9);
	bonus = bonus*diffmod;
	let finalbonusstr = "= "~tost(bonus);
	ObjText_SetText(obj_finalbonus,finalbonusstr);
	ObjText_SetFontColorTop(obj_finalbonus,255,200,200);
	ObjText_SetFontColorBottom(obj_finalbonus,255,64,64);
	

	wait(fadeindel);
	
	let time = 180; //120
	let incr = trunc(bonus/time/10)*10;
	let r = bonus - incr*time;
	ascent(i in 0..time){
		AddScore(incr);
		if(i%3==0){SE_Play(se_graze,100);}
		if(i%3==1){SE_Play(se_item,100);}
		yield;
	}
	AddScore(r);
	
	let obj_next = ObjPrim_Create(OBJ_SPRITE_2D);
	if(!isAllClear){
		ObjPrim_SetTexture(obj_next, dirsys~"img/Default_SystemText.png");
		ObjSprite2D_SetSourceRect(obj_next, 9, 128, 263, 159);
		ObjSprite2D_SetDestCenter(obj_next);
		ObjRender_SetPosition(obj_next,cx, 60,0);
		Obj_SetRenderPriorityI(obj_next,75);
		FadeInFlash(obj_next);
	}
	
	WaitForConfirm();
	
	FadeBGM;
	SetCommonData("SpellsCaptured",0);
	Obj_FadeDelete(obj_stagenum);
	Obj_FadeDelete(obj_stagebonus);
	Obj_FadeDelete(obj_capturenum);
	Obj_FadeDelete(obj_capturebonus);
	Obj_FadeDelete(obj_playernum);
	Obj_FadeDelete(obj_playerbonus);
	Obj_FadeDelete(obj_spellnum);
	Obj_FadeDelete(obj_spellbonus);
	Obj_FadeDelete(obj_diff);
	Obj_FadeDelete(obj_diffmod);
	Obj_FadeDelete(obj_finalbonus);
	Obj_FadeDelete(obj_next);

	//afterwards,
	//fade to black (todo: using reserved render target?)
	FadeToBlack(60,180,60);
	wait(60);
	//CloseScript(GetOwnScriptID)
	
}



function WaitForConfirm{
	while(GetVirtualKeyState(VK_OK)!=KEY_FREE){yield;}
	while(GetVirtualKeyState(VK_OK)!=KEY_PUSH){yield;}
}



task FadeToBlack(delin,dur,delout){
	let obj = GetCommonData("ScreenFadeObject",ObjPrim_Create(OBJ_SPRITE_2D));
	SetCommonData("ScreenFadeObject",obj);
	ObjPrim_SetTexture(obj, dirimg~"black.png");
	ObjSprite2D_SetSourceRect(obj, 0, 0, 100, 100);
	ObjSprite2D_SetDestCenter(obj);
	// Obj_SetRenderPriorityI(obj, 100);
	Obj_SetRenderPriorityI(obj, 79);
	ObjRender_SetAlpha(obj, 0);
	
	// RenderToTextureB1(GetReservedRenderTargetName(2),obj,true);

	ObjRender_SetPosition(obj, GetCenterX, GetCenterY, 0);
	ObjRender_SetScaleXYZ(obj, 8, 8, 0);
	let a = 0;
	if(delin<1){a=255;ObjRender_SetAlpha(obj,a);}
	else{
		while(a < 255){
			ObjRender_SetAlpha(obj, a);
			a += 255/delin;
			yield;
		}
	}
	wait(dur);
	if(delout<1){a=0;ObjRender_SetAlpha(obj,a);}
	else{
		while(a > 0){
			ObjRender_SetAlpha(obj, a);
			a -= 255/delout;
			yield;
		}
	}
	// Obj_Delete(obj); //todo - transitions
}


function SetBGM(title){
	// Notify(SCRIPT_MUSIC,EV_SET_SONG,[title]);
	NotifyEventAll(EV_SET_SONG,[title]);
}
function SetBGMLoop(title,loopstart,loopend){
	// NotifyEvent(GetCommonData("SystemScriptID",NULL),EV_SET_SONG,[title,loopstart,loopend]);
	NotifyEventAll(EV_SET_SONG,[title,rtoa(loopstart),rtoa(loopend)]);
}
function FadeBGM(){
	// NotifyEvent(GetCommonData("SystemScriptID",NULL),EV_FADE_SONG,[]);
	NotifyEventAll(EV_FADE_SONG,[]);
}









//For dynamically changing pattern speed (experimental, TODO move)
function ScaleAllSpeeds(r){ //ratio new/old
	let shots = GetAllShotID();
	ascent(i in 0..length(shots)){ Scale(shots[i]); }
	let enems = GetAllEnemyID();
	ascent(i in 0..length(enems)){ Scale(enems[i]); }
	
	function Scale(obj){
		let sp = OM_GetSpeed(obj);
		let ac = OM_GetAcceleration(obj);
		let ms = OM_GetMaxSpeed(obj);
		let av = OM_GetAngularVelocity(obj);
		OM_AddPatternA2(obj,0,sp*r,NO_CHANGE,ac*r,av*r,ms*r);
	}
}












function rainbow(i) {
	i = (i*360) %360;	//convert from ratio 0..1 to period of 0..360
	let r = sin(i+0)  * 127 + 128;
	let g = sin(i+120)* 127 + 128;
	let b = sin(i+240)* 127 + 128;
	return [r,g,b];
}


function makeText(x,y,size,color,align,alpha,text) {
	let sx = GetStgFrameWidth(); let sy = GetStgFrameHeight();
	let width = 384; //default stage frame width (height is 448)
	let tx;
	if( align == ALIGNMENT_LEFT) { tx = x; }
	else if( align == ALIGNMENT_RIGHT ) { tx = x - width; }
	else if( align == ALIGNMENT_CENTER) { tx = x - width/2;	}
	let objText = ObjText_Create();
	ObjText_SetHorizontalAlignment(objText, align);
	ObjText_SetMaxWidth(objText, width);
	ObjRender_SetX(objText, tx);
	ObjRender_SetY(objText, y);
	ObjText_SetFontSize(objText, size);
	// ObjText_SetFontType(objText, "Helvetica");
	ObjText_SetFontType(objText, "Cirno");
	ObjText_SetFontColorTop(objText, color[0],color[1],color[2]); //224, 64, 192
	// ObjText_SetFontColorTop(objText, 255, 255, 255);
	ObjText_SetFontColorBottom(objText, 255, 255, 255);
	// ObjText_SetFontBorderType(objText, BORDER_FULL);
	// ObjText_SetFontBorderColor(objText, color[0],color[1],color[2]); //224, 64, 192
	// ObjText_SetFontBorderWidth(objText, 1);
	ObjRender_SetAlpha(objText,alpha);
	ObjText_SetText(objText,text);
	Obj_SetRenderPriorityI(objText,GetCameraFocusPermitPriorityI()+1);
	return objText;
}

function ObjText_CreateA1(size,font,color){
	let text = ObjText_Create;
	ObjText_SetFontType(text,font);
	ObjText_SetFontSize(text,size);
	if(length(color)==0){color=[255,255,255];}
	if(length(color)>3){ObjRender_SetAlpha(text,color[3]);}
	ObjText_SetFontColorTop(text,255,255,255);
	ObjText_SetFontColorBottom(text,color[0],color[1],color[2]);
	ObjText_SetLinePitch(text,0);
	ObjText_SetMaxWidth(text,GetStgFrameWidth);
	Obj_SetRenderPriorityI(text, 70); //70
	return text;
}











///////////////////////////////////////////////////////////////




//good values for intensity are 1-3 or so for something with long duration like a spark
//10 is good for a more intense shaking
task ScreenShake(time, xintensity, yintensity) {
	let xdir = 2*(round(rand(0,1)))-1; let ydir = 2*(round(rand(0,1)))-1;
	//Prevents screen edges from showing
	let zoom = max(xintensity,yintensity);
	task zoomin{
		ascent(i in 0..zoom){Set2DCameraRatio(1+i/125);wait(i);}
	}
	zoomin;
	while(time>0) {
		Set2DCameraFocusX(GetStgFrameWidth/2 + sin(10*time*xdir)*cos(20*time*xdir)*xintensity);
		Set2DCameraFocusY(GetStgFrameHeight/2 + sin(20*time*ydir)*cos(10*time*ydir)*yintensity);
		time--; yield;
	}
	//Restore the camera to normal
	Set2DCameraFocusX(GetStgFrameWidth/2);
	Set2DCameraFocusY(GetStgFrameHeight/2);
	task zoomout{
		descent(i in 0..zoom){
			Set2DCameraRatio(1+i/125);
			ascent(j in 0..zoom-i){
				yield;
				Set2DCameraRatio(1+i/125 - (j/125/(zoom-i)) );
			}
		}
		Reset2DCamera;
	}
	zoomout;
}
task Zoom(x,y,mag,time){
	let x0 = Get2DCameraX; let y0 = Get2DCameraY;
	let magx0 = Get2DCameraRatioX; let magy0 = Get2DCameraRatioY;
	let dx = (x-x0)/time; let dy = (y-y0)/time;
	let dmagx = (mag-magx0)/time; let dmagy = (mag-magy0)/time;
	ascent(i in 0..time){
		Set2DCameraFocusX(x0+dx*i);
		Set2DCameraFocusY(y0+dy*i);
		Set2DCameraRatioX(magx0+dmagx*i);
		Set2DCameraRatioY(magy0+dmagy*i);
		yield;
	}
}
task RotateScreen(change, time, dir) {
    loop(time) {
        Set2DCameraAngleZ(Get2DCameraAngleZ() + change/time * dir);
        yield;
    }
}













function AfterImageShot(shot,color,scale,scaleinc,time,blend,layer)  {
	let rect = GetShotDataInfoA1(ObjShot_GetImageID(shot),TARGET_ENEMY,INFO_RECT);
	// return AfterImageB2(shot,GetCurrentScriptDirectory~"../shot/img/AllStarShot.png",color,scale,scaleinc,time,rect[0],rect[1],rect[2],rect[3],0,blend,layer);
	let eff = AfterImageA1(ObjMove_GetX(shot),ObjMove_GetY(shot),GetCurrentScriptDirectory~"../shot/img/AllStarShot.png",color,scale,scaleinc,time,rect[0],rect[1],rect[2],rect[3],0);
	Obj_SetRenderPriority(eff,layer);
	ObjRender_SetBlendType(eff,blend);
	return eff;
}
function AfterImageBoss(boss,color,scale,scaleinc,time,blend,layer) {
	let eff = AfterImageA1(ObjMove_GetX(boss),ObjMove_GetY(boss),GetCurrentScriptDirectory()~"../boss.png",color,scale,scaleinc,time,1,1,64,64,0);	
	Obj_SetRenderPriority(eff,layer);
	ObjRender_SetBlendType(eff,blend);
	return eff;
	//return AfterImageB2(boss,GetCurrentScriptDirectory()~"../boss.png",color,scale,scaleinc,time,1,1,64,64,0,blend,layer);	
}

// function AfterImagePlayer(img,rect,color,scale,scaleinc,time,blend,layer) {
	// return AfterImageB2(GetPlayerObjectID(),img,color,scale,scaleinc,time,rect[0],rect[1],rect[2],rect[3],0,blend,layer);
// }
// function AfterImageCircle(x,y,color,scale,scaleinc,time,blend,layer) {
	// return AfterImageA2(x,y,CSD~"../img/gradientcircle.png",color,scale,scaleinc,time, 1,1,300,300 ,0, blend,layer);
// }

// task TAfterImageShot(shot,color,scale,scaleinc,time,blend,layer) {
	// if(layer==0){layer=23;}
	// while(!Obj_IsDeleted(shot)) {
		// AfterImageShot(shot,color,scale,scaleinc,time,blend,layer);
		// yield;
	// }
// }
// task TAfterImageBoss(boss,color,scale,scaleinc,time,del,blend,layer) {
	// if(layer==0){layer=23;}
	// while(!Obj_IsDeleted(boss)) {
		// AfterImageBoss(boss,color,scale,scaleinc,time,blend,layer);
		// wait(del);
	// }
// }
// task TAfterImagePlayer(color,scale,scaleinc,time,del,blend,layer) {
	// if(layer==0){layer=43;}
	// while(!Obj_IsDeleted(boss)) {
		// AfterImagePlayer(CSD~"../img/PlayerSilhouette.png",[1,1,32,46],color,scale,scaleinc,time,blend,layer);
		// wait(del);
	// }
// }

//AJS
function AfterImageA1(tobjx,tobjy,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle){
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	task TAfterImage(tobjx,tobjy,texture,color,scaleinc,time,x1,y1,x2,y2,Yangle){
		let alpha0 = 255;
		let Red = color[0]; let Green = color[1]; let Blue = color[2];
		if(length(color)>3){alpha0=color[3];}
		let alpha = alpha0;
		ObjPrim_SetTexture(obj, texture);
		ObjSprite2D_SetSourceRect(obj, x1, y1, x2, y2);
		ObjRender_SetScaleXYZ(obj,scale,scale,0);
		Obj_SetRenderPriorityI(obj,23);
		ObjSprite2D_SetDestCenter(obj);
		ObjRender_SetPosition(obj,tobjx,tobjy,0);
		ObjRender_SetAlpha(obj,alpha);
		ObjRender_SetBlendType(obj,BLEND_ADD_ARGB);
		ObjRender_SetColor(obj,Red,Green,Blue);
		ObjRender_SetAngleY(obj,Yangle);	
		loop(time){
			scale+=scaleinc/time;
			ObjRender_SetScaleXYZ(obj,scale,scale,0);
			alpha-=alpha0/time;
			ObjRender_SetAlpha(obj,alpha);
			yield;
		}
		Obj_Delete(obj);
	}
	TAfterImage(tobjx,tobjy,texture,color,scaleinc,time,x1,y1,x2,y2,Yangle);
	return obj;
}

// function AfterImageB1(tobj,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle) {
	// let obj = AfterImageA1(ObjRender_GetX(tobj),ObjRender_GetY(tobj),texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle);
	// return obj;
// }
// function AfterImageA2(x,y,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle,blend,layer) {
	// let obj = AfterImageA1(x,y,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle);
	// ObjRender_SetBlendType(obj,blend);
	// Obj_SetRenderPriorityI(obj,layer);
	// return obj;
// }
// function AfterImageB2(tobj,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle,blend,layer) {
	// let obj = AfterImageB1(tobj,texture,color,scale,scaleinc,time,x1,y1,x2,y2,Yangle);
	// ObjRender_SetBlendType(obj,blend);
	// Obj_SetRenderPriorityI(obj,layer);
	// return obj;
// }


function GlowCircle(x,y,color,scale,scaleinc,time){
	return AfterImageA1(x,y,dirimg~"gradientcircle.png",color,scale,scaleinc,time, 1,1,300,300 ,0);
	//AfterImageCircle(x,y,color,scale,scaleinc,time,blend,layer);
}
function GlowCircle2(x,y,color,scale,scaleinc,time,img,rect){
	if(rect==[0,0,0,0]){rect=[1,1,300,300];}
	return AfterImageA1(x,y,img,color,scale,scaleinc,time, rect[0],rect[1],rect[2],rect[3] ,0);
	//AfterImageCircle(x,y,color,scale,scaleinc,time,blend,layer);
}

function TintScreen(color,time) {
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let scale = 2; let alpha0 = 255;
	let Red = color[0]; let Green = color[1]; let Blue = color[2];
	if(length(color)>3){alpha0=color[3];}
	let alpha = alpha0;
	ObjPrim_SetTexture(obj, GetCurrentScriptDirectory()~"../img/gradient.png");
	ObjSprite2D_SetSourceRect(obj, 0, 0, 300, 300);
	ObjRender_SetScaleXYZ(obj,scale,scale,0);
	Obj_SetRenderPriorityI(obj,79);
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetPosition(obj,cx,cy,0);
	ObjRender_SetAlpha(obj,alpha);
	ObjRender_SetBlendType(obj,BLEND_ADD_ARGB);
	ObjRender_SetColor(obj,Red,Green,Blue);
	ObjRender_SetAngleY(obj,0);
	task TTint(obj,color,scale,scaleinc,time,alpha0,alpha) {
		loop(time){
			scale+=scaleinc/time;
			ObjRender_SetScaleXYZ(obj,scale,scale,0);
			alpha-=alpha0/time;
			ObjRender_SetAlpha(obj,alpha);
			yield;
		}
		Obj_Delete(obj);
	}
	if(time>=0){TTint(obj,color,scale,0,time,alpha0,alpha);}
	return obj;
}


function killplayer{
	let shot=CreateDummyShot(px,py); Obj_SetVisible(shot,false);
	ObjShot_SetIntersectionCircleA1(shot,15);
}
task exterminateplayer{
	while(GetPlayerState!=STATE_HIT && !IsPlayerSpellActive){killplayer;yield;}
}




//Deletes all objects in an array, rather than just removing references to them
function DeleteInArray(arr){
	while(length(arr)>0){Obj_Delete(arr[0]);arr=erase(arr,0);}
	return arr;
}
function FadeDeleteInArray(arr){
	while(length(arr)>0){Obj_FadeDelete(arr[0]);arr=erase(arr,0);}
	return arr;
}
function DeleteFamInArray(arr){
	while(length(arr)>0){
		Obj_FadeDelete(arr[0]);
		//FamExpandDelete(arr[0],3,35);
		arr=erase(arr,0);}
	return arr;
}



//See also: 
//	IsIntersected_Line_Circle
//	IsIntersected_Obj_Obj
// function CrossLineA1(shot,m1,m2) {
	// return CrossLineA3(ObjMove_GetX(shot),ObjMove_GetY(shot),ObjMove_GetX(m1),ObjMove_GetY(m1),ObjMove_GetX(m2),ObjMove_GetY(m2), 10);
// }
// function CrossLineA2(x,y,m1,m2) {
	// return CrossLineA3(x,y,ObjMove_GetX(m1),ObjMove_GetY(m1),ObjMove_GetX(m2),ObjMove_GetY(m2), 10);
// }
// function CrossLineA3(x,y, m1x,m1y,m2x,m2y, width) {
	// //mathematically find distance from shot to line
	// let d = (absolute( (m2x-m1x)*(m1y-y)-(m1x-x)*(m2y-m1y) ) ) / ( ( (m2x-m1x)^2 + (m2y-m1y)^2 )^0.5 );
	// let close = (d<width);
	// return close;
// }




///////////////////////////////////////////////////////////////
//Bounce/Wrap Functions
///////////////////////////////////////////////////////////////


//Finds the angle needed to bounce a shot so that it hits the specified coords
//Does not actually bounce the shot, so do that separately
function AimBounce(x0,y0,x1,y1,wall) {
	let wcoord;
	alternative(wall)
	case(LFT){wcoord=0;}
	case(TOP){wcoord=0;}
	case(RGT){wcoord=sx;}
	case(BTM){wcoord=sy;}
	
	let xdist; let ydist;
	if(wall == LFT || wall == RGT) {
		xdist = wcoord-x0 + wcoord-x1;
		ydist = y1-y0;
	}
	else if(wall == TOP || wall == BTM) {
		xdist = x1-x0;
		ydist = wcoord-y0 + wcoord-y1;
	}
	return atan2(ydist,xdist);
}
//Finds the angle needed to wrap a shot across the stage boundaries and hit the specified coords
//Again, does not actually wrap the shot, so do that separately
function AimWrap(x0,y0,x1,y1,wall) {
	let off;
	alternative(wall)
	case(LFT){off=-sx;}
	case(TOP){off=-sy;}
	case(RGT){off=sx;}
	case(BTM){off=sy;}
	
	let xdist; let ydist;
	if(wall == LFT || wall == RGT) {
		xdist = x0 + off-x1;
		ydist = y1-y0;
	}
	else if(wall == TOP || wall == BTM) {
		xdist = x1-x0;
		ydist = y1 + off-y1;
	}
	return atan2(ydist,xdist);
}

//----------------------------------------------------------------
//Bounce off the walls of the stage frame
//Changes only angle
/////////////////////////////////////////////////////////
let LFT = 999900; let TOP = 999901; let RGT = 999902; let BTM = 999903; let NON = 999904; let CLIP = 999910;
//Bounce a shot/something just once
//Use this repeatedly if you want to do something when it bounces
function bounce(obj) {
	let x = ObjMove_GetX(obj); let y = ObjMove_GetY(obj);
	if(y<sy && y>0 && x>0 && x<sx){return false;}
	if(!OM_IsXYMove(obj)){
		let a = ObjMove_GetAngle(obj);
		if(x<0||x>sx) { a=reflect(a,90); }
		if(y<0||y>sy) { a=reflect(a,0 ); }
		ObjMove_SetAngle(obj,a);
	}else{
		let dx=OM_GetSpeedX(obj); let dy=OM_GetSpeedY(obj);
		if(x<0||x>sx) { dx*=-1; }
		if(y<0||y>sy) { dy*=-1; }
		OM_SetSpeedX(obj,dx); OM_SetSpeedY(obj,dy);
	}
	return true;
}
//Again, use this repeatedly to do something when it wraps
function wrap(obj) {
	let x = ObjMove_GetX(obj); let y = ObjMove_GetY(obj);
	if(y<sy && y>0 && x>0 && x<sx){return false;}	
	if(x<0||x>sx){ObjMove_SetX(obj,cx+(cx-x));}
	if(y<0||y>sy){ObjMove_SetY(obj,cy+(cy-y));}
	return true;
}
//This one also changes x/y acceleration. If you use it on a non-XYmove shot, it changes angv.
function bounce2(obj){
	let b = isoff(obj); if(!b){return false;}
	let x = OM_GetX(obj); let y = OM_GetY(obj);
	if(OM_IsXYMove(obj)){
		let xs = OM_GetSpeedX(obj); let ys = OM_GetSpeedY(obj);
		let xa = OM_GetAccelerationX(obj); let ya = OM_GetAccelerationY(obj);
		let xm = OM_GetMaxSpeedX(obj); let ym = OM_GetMaxSpeedY(obj);
		let bx = (x<0||x>sx); let by = (y<0||y>sy);
		if(by){
			OM_SetMaxSpeedY(obj,-ym);
			OM_SetSpeedY(obj,-ys);
			OM_SetAccelerationY(obj,-ya);
		}
		if(bx){
			OM_SetMaxSpeedX(obj,-xm);
			OM_SetSpeedX(obj,-xs);
			OM_SetAccelerationX(obj,-xa);
		}
		return (bx||by);
	}else{
		let angv = OM_GetAngularVelocity(obj);
		OM_SetAngularVelocity(obj,-angv);
		return bounce(obj);
	}
}
//Same deal for if you only want it to bounce off certain walls
function bounceW(obj,walls) {
	let x = ObjMove_GetX(obj); let y = ObjMove_GetY(obj);
	if(y<sy && y>0 && x>0 && x<sx){return false;}
	
	let lft=false; let top=false; let rgt=false; let btm=false;
	ascent(i in 0..length(walls)){
		alternative(walls[i])
		case(LFT){lft=true;}
		case(TOP){top=true;}
		case(RGT){rgt=true;}
		case(BTM){btm=true;} 
	}
	let off = false;
	if((lft&&x<0)||(rgt&&x>sx)) { off=true; }
	if((top&&y<0)||(btm&&y>sy)) { off=true; }
	if(off){ bounce(obj); }
	return off;
}
function wrapW(shot,walls) {
	let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
	if(y<sy && y>0 && x>0 && x<sx){return false;}
	let lft=false; let top=false; let rgt=false; let btm=false;
	ascent(i in 0..length(walls)){
		alternative(walls[i])
		case(LFT){lft=true;}
		case(TOP){top=true;}
		case(RGT){rgt=true;}
		case(BTM){btm=true;} 
	}
	// if(x<=0 &&lft) { ObjMove_SetX(shot,sx); }
	// if(y<=0 &&top) { ObjMove_SetX(shot,sy); }
	// if(x>=sx&&rgt) { ObjMove_SetY(shot, 0); }
	// if(y>=sy&&btm) { ObjMove_SetY(shot, 0); }
	if(x<0&&lft||rgt&&x>sx){ObjMove_SetX(shot,cx+(cx-x));}
	if(y<0&&top||btm&&y>sy){ObjMove_SetY(shot,cy+(cy-y));}
	return true;
}


task OM_BounceA1(obj,bounces){
	yield;while(isoff(obj)){yield;}
	while(bounces>0){
		while(!bounce(obj)){yield;} bounces--;
		while(isoff(obj)){yield;}
	}
}
task OM_BounceB1(obj,bounces,walls){
	while(isoff(obj)){yield;}
	while(bounces>0){
		while(!bounceW(obj,walls)){yield;} bounces--;
		while(isoff(obj)){yield;}
	}
}
task OM_WrapA1(obj,wraps){
	while(isoff(obj)){yield;}
	while(wraps>0){
		while(!wrap(obj)){yield;} wraps--;
		while(isoff(obj)){yield;}
	}
}
task OM_WrapB1(obj,wraps,walls){
	while(isoff(obj)){yield;}
	while(wraps>0){
		while(!wrapW(obj,walls)){yield;} wraps--;
		while(isoff(obj)){yield;}
	}
}
// task OM_WrapB1(shot, wraps, walls) {
	// let lft=checkarr(walls,LFT)!=-1; let top = checkarr(walls,TOP)!=-1; let rgt = checkarr(walls,RGT)!=-1; let btm = checkarr(walls,BTM)!=-1;
	// //let clip = checkarr(walls,CLIP); //if(clip!=-1){clip = walls[clip+1];}else{clip=0;}
	// let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
	// let x0 = 0; let y0 = 0; let x1 = sx; let y1 = sy;
	// let clip=checkarr(walls,CLIP);
	// if(clip!=-1){x0=walls[clip+1];y0=walls[clip+2];x1=walls[clip+3];y1=walls[clip+4];}
	
	// while(wraps!=0 && !Obj_IsDeleted(shot)) {
		// //Wait for shot to reach boundary
		// while( x>x0 && y>y0 && x<x1 && y<y1 ) { 
			// yield;
			// x = ObjMove_GetX(shot); y = ObjMove_GetY(shot);
		// }

		// let offLft = (x<=x0); 
		// let offTop = (y<=y0); 
		// let offRgt = (x>=x1); 
		// let offBot = (y>=y1);
		
		// if(offLft&&lft) { x+=2*(cx-x); }
		// if(offTop&&top) { y+=2*(cy-y); }
		// if(offRgt&&rgt) { x+=2*(cx-x); }
		// if(offBot&&btm) { y+=2*(cy-y); }
		// ObjMove_SetPosition(shot,x,y);
		
		// yield; //wait for bullet to move away from bound before checking again
		// x = ObjMove_GetX(shot); y = ObjMove_GetY(shot);
		// wraps--;
	// }
	// return;
// }

function BounceA1(shot, bounces, walls){OM_BounceB1(shot, bounces, walls);}
function WrapA1(shot, bounces, walls){OM_WrapB1(shot, bounces, walls);}




function GetMoveAtWrap(x0,y0,x1,y1,walls){
	//Unpack array of walls
	let lft=false; let top=false; let rgt=false; let btm=false; let non=false;
	let over = 1;    //number of times to wrap around before reaching destination
	let orthweight = 1.5; //preferred number of walls to wrap across (1=orthagonal, 2=diagonal)
	let wrapweight = 2.25;
	let overshoot = 1; //multiplier for final distance
	let exind = 0; //number of extra parameters processed
	ascent(i in 0..length(walls)){
		alternative(walls[i])
		case(LFT){lft=true;}case(TOP){top=true;}case(RGT){rgt=true;}case(BTM){btm=true;}case(NON){non=true;}
		//Extra args: first=over, second=orthweight, third=wrapweight
		others{
			alternative(exind)
			case(0){over=walls[i];}
			case(1){orthweight=walls[i]}
			case(2){wrapweight=walls[i]}
			case(3){overshoot=walls[i]}
			exind++;
		}
	}
	//Find dist/ang when wrapping across each wall
	let dists = []; let compdists = []; let angs = []; let xdests = []; let ydests = [];
	ascent(i in -over..over+1){
		if( (i==0) || (lft&&(i<0)) || (rgt&&(i>0)) ){
			ascent(j in -over..over+1){
				if( ((non||i!=0)&&(j==0)) || (top&&(j<0)) || (btm&&(j>0)) ){
					let x = x1+sx*i;
					let y = y1+sy*j;
					let dist = getdistance(x0,y0,x,y); let compdist=dist;
					let ang = getangle(x0,y0,x,y);
					
					dists  = dists  ~ [ dist*overshoot ];
					angs   = angs   ~ [ ang ];
					xdests = xdests ~ [ x*overshoot ];
					ydests = ydests ~ [ y*overshoot ];
					
					// let yc = y1+sx*j *over; //treat stage as square for determining which wall
					// let compdist = getdistance(x0,y0,x,yc);
					
					//No wrap - bias against not wrapping
					if(i==0&&j==0){compdist*=wrapweight;}
					//Diagonal wrap - bias against wrapping across multiple different walls
					else if(i!=0&&j!=0){
						let k = (i^2+j^2)^0.5;
						compdist*=orthweight*k;
					} 
					//Orthagonal wrap - bias against wrapping across only a single wall
					else{ 
						compdist*=(1/orthweight); 
					}
					
					compdists  = compdists  ~ [ compdist ];
				}
			}
		}
	}
	//Determine shortest dist
	let shortest = 999999; 
	let index = -1;
	ascent(i in 0..length(dists)){
		if(compdists[i] < shortest){
			index = i;
			shortest = compdists[i];
		}
	}
	return [ dists[index], angs[index], xdests[index], ydests[index] ];
}

function GetDistanceAtWrap(x0,y0,x1,y1,walls){ return GetMoveAtWrap(x0,y0,x1,y1,walls)[0]; }
function GetAngleAtWrap(x0,y0,x1,y1,walls){ return GetMoveAtWrap(x0,y0,x1,y1,walls)[1]; }
function GetDestAtWrap(x0,y0,x1,y1,walls){ let arr = GetMoveAtWrap(x0,y0,x1,y1,walls); return [arr[2],arr[3]]; }

task OM_SetDestAtWrapF(obj,x,y,walls,frames){
	let move = GetMoveAtWrap(ObjMove_GetX(obj),ObjMove_GetY(obj),x,y,walls);
	let dist = move[0];
	let ang = move[1];
	// let spd = dist/frames;
	let spd = (dist/frames)*1.1;
	ObjMove_AddPatternA1(obj,0,spd,ang);
	task MyWrap{loop(frames){wrap(obj);yield;}}MyWrap;
	wait(frames*0.9);
	// let over = 1; ascent(i in 0..length(walls)){if(walls[i]<LFT){over=walls[i];break;}}
	descent(i in 0..frames*0.1){
		let t = i/(frames*0.1);
		ObjMove_SetSpeed(obj, spd*t^2 );
		// ObjMove_SetSpeed(obj, spd*(i/(frames/10))^(over-1) );
		yield;
	}
	ObjMove_SetSpeed(obj, 0 );
}



//----------------------------------------------------------------




task OM_BindPos(obj2,obj1){
	while(!Obj_IsDeleted(obj1) && !Obj_IsDeleted(obj2)){
		ObjRender_SetPosition(obj2,getrx(obj1),getry(obj1),0);
		yield;
	}
}
task OM_BindPosA2(obj2,obj1,x,y){
	while(!Obj_IsDeleted(obj1) && !Obj_IsDeleted(obj2)){
		ObjRender_SetPosition(obj2,getrx(obj1)+x,getry(obj1)+y,0);
		yield;
	}
}





//Andi - Bounce straight lasers, works ok-ish last I checked
function LasBounceA1(las, width,dur,del, rgt,top,lft,btm, wrap) {
	let x = ObjMove_GetX(las); let y = ObjMove_GetY(las);
	let a = ObjStLaser_GetAngle(las);
	let length = ObjLaser_GetLength(las);
	let dx = length*cos(a); let dy = length*sin(a);
	let tx = x+dx; let ty = y+dy; //tip x/y

	//determine point at which las crosses boundary
	let offLft; let offTop; let offRgt; let offBot;
	let n = 1; //num bounds crossed
	while(n>0 && length>0) {
		n = 0;
		offLft=(tx<=0); offTop=(ty<=0); offRgt=(tx>=sx); offBot=(ty>=sy);
		if(offLft){n++;} if(offTop){n++;} if(offRgt){n++;} if(offBot){n++;}
		if(n>0) {
			length--;
			dx = length*cos(a); dy = length*sin(a);
			tx = x+dx; ty = y+dy;
		}
		else { 
			length++;
			dx = length*cos(a); dy = length*sin(a);
			tx = x+dx; ty = y+dy;
			offLft=(tx<=0); offTop=(ty<=0); offRgt=(tx>=sx); offBot=(ty>=sy);
			//Now figure out what angle it should bounce at
			let nx=0; let ny=0; //point on reflected line
			
			if(wrap) {
				if(offLft) { tx=sx-50*cos(a); ty-=50*sin(a); }
				if(offTop) { ty=sy-50*sin(a); tx-=50*cos(a); }
				if(offRgt) { tx=0-50*cos(a); ty-=50*sin(a); }
				if(offBot) { ty=0-50*sin(a); tx-=50*cos(a); }
				return CreateStraightLaserA1(tx,ty,a,600,width,dur,ObjShot_GetImageID(las),del);
			}
			
			if(offLft) { ny = y + 2*dy; nx = x; }
			if(offTop) { nx = x + 2*dx;	ny = y; }
			if(offRgt) { ny = y + 2*dy; nx = x; }
			if(offBot) { nx = x + 2*dx; ny = y; }
			let a1 = angleBetween(tx,ty,nx,ny);
			//At this point we know we want a laser at tx,ty,a1	
			return CreateStraightLaserA1(tx,ty,a1,600,width,dur,ObjShot_GetImageID(las),del);
		}
	}
	//If the laser cannot be bounced, return an invisible laser to avoid errors
	return CreateStraightLaserA1(174,0,90,0,0,0,0,0);
}
///////////////////////////////////////////////////////////////

//Set a bullet on a stable orbit around a point
//Based on real math!
function SetOrbit(shot,cx,cy,speed, nudge) {
	//reach 360 after traveling (circumference)
	let sx = ObjMove_GetX(shot); let sy = ObjMove_GetY(shot);
	let radius = getdist(sx,sy,cx,cy);
	let circumf = 2*pi()*radius;
	let period = circumf / speed;
	let angv = 2*pi() / period * 57.2958 * nudge;
	let angle = angleBetween(cx,cy,sx,sy) + 90*nudge;
	ObjMove_AddPatternA2(shot,0,speed,angle,0,angv,speed);
}

function SetOrbitB1(shot,c,speed, nudge) {SetOrbit(shot,ObjMove_GetX(c),ObjMove_GetY(c),speed,nudge);}
task SetOrbitA2(shot,cx,cy,speed,nudge,delay) {wait(delay);SetOrbit(shot,cx,cy,speed,nudge);}
task SetOrbitB2(shot,c,speed,nudge,delay) {wait(delay);SetOrbitB1(shot,c,speed,nudge);}
//Try to get shots with different radii orbit at the same RPM
function SyncOrbit(rad,spd) {
	let n = 500/spd; //based on testing - 500 probably isn't exactly the right constant
	return 2*pi()*rad/n; //I no longer remember what this does
}

//todo - supposed to make sure a shot doesn't circle indefinitely
// function GetLimitAngv(obj){
	// let s = OM_GetMaxSpeed(obj);
	
	// // let angv = 2*pi() / period * 57.2958;
// }



//Another from TalosMistake
task SetHoming(obj,maxTraverse,time,delay){ 
	wait(delay);
	let angle = ObjMove_GetAngle(obj);
	let c = 0;
    while(! Obj_IsDeleted(obj) && c<time) {
		c++;
        ObjMove_SetAngle(obj, angle);
        yield;
        // direction angle to player's character
        let dir = atan2(GetPlayerY - ObjMove_GetY(obj),
                        GetPlayerX - ObjMove_GetX(obj));
        // difference between 'dir' and 'angle'
        let diff = dir - angle;
        while(diff >= 180) { diff -= 360; }    // adjust the range
        while(diff < -180) { diff += 360; }
        let diffAbs = (|diff|);
        if(diffAbs < maxTraverse) {
            // if the difference is small,
            // the bullet turns to the player's character
            angle = dir;
        } else {
            // otherwise, the bullet turns 'maxTraverse' degrees
            angle += maxTraverse * diff / diffAbs;
        }
    }
}


//Temporarily phase a bullet out, making it transparent and non-colliding
task Phase(shot,frames,alpha1, alpha2) {
	ObjRender_SetAlpha(shot,alpha1);
	ObjShot_SetIntersectionEnable(shot,false);
	ObjShot_SetAutoDelete(shot,false);
	let resist = ObjShot_IsSpellResist(shot);
	ObjShot_SetSpellResist(shot,true);
	wait(frames);
	ObjRender_SetAlpha(shot,alpha2);
	ObjShot_SetIntersectionEnable(shot,true);
	ObjShot_SetAutoDelete(shot,true);
	ObjShot_SetSpellResist(shot,resist);
}
//Fade in rather than suddenly setting alpha
task Phase2(shot,frames,alpha1, alpha2) {
	let dAlpha = (alpha2-alpha1)/frames;
	let resist = ObjShot_IsSpellResist(shot);
	ObjShot_SetIntersectionEnable(shot,false);
	ObjShot_SetAutoDelete(shot,false);
	ObjShot_SetSpellResist(shot,true);
	ascent(i in 0..frames) {
		ObjRender_SetAlpha(shot,alpha1+dAlpha*i);
		yield;
	}
	ObjShot_SetIntersectionEnable(shot,true);
	ObjShot_SetAutoDelete(shot,true);
	ObjShot_SetSpellResist(shot,resist);
}

task DelayFadeDelete(shot,del) {
	wait(del);
	ObjShot_FadeDelete(shot);
}
task OS_SetFadeDeleteFrame(shot,del) {
	wait(del);
	ObjShot_FadeDelete(shot);
}
task O_SetFadeDeleteFrame(obj,del) {
	wait(del);
	Obj_FadeDelete(obj);
}
// task Obj_SetRGBFadeDeleteFrame(obj,del) {
	// wait(del);
	// Obj_FadeDelete(obj);
// }


//Scale a shot over time
task GrowShot(shot,scale0,scale1,dur){
	let dScale = (scale1-scale0)/dur;
	let i=0; let flipx=1; let flipy=1;
	while(i<dur && !Obj_IsDeleted(shot)){
		flipx=tononzero(sign(ObjRender_GetScaleX(shot))); flipy=tononzero(sign(ObjRender_GetScaleY(shot)));
		ObjRender_SetScaleXYZ(shot,(scale0+i*dScale)*flipx,(scale0+i*dScale)*flipy,1);
		yield; i++;
	}
	//ObjRender_SetScaleXYZ(shot,scale1,scale1,1);
}



//Python
task ObjRender_SetMoveFromBackground(obj, time, startscale, endscale){
	let s = startscale;
	Obj_SetValue(obj, "IsSpawning", true);
	Obj_SetRenderPriorityI(obj, 24);
	loop(time){
		ObjRender_SetScaleXYZ(obj, s, s, 0);
		s += (endscale - startscale)/time;
		yield;
	}
	Obj_SetValue(obj, "IsSpawning", false);
	Obj_SetRenderPriorityI(obj, 30);
}









function WarnShot(shot) {
	let warn = CreateShotA1(ObjMove_GetX(shot),ObjMove_GetY(shot),0,0,ObjShot_GetImageID(shot),15);
	ObjShot_SetIntersectionEnable(warn,false);
	ObjShot_SetSpellResist(shot,true);
	Obj_SetValue(shot,FLAG_DUMMY,true);
	ObjShot_FadeDelete(warn);
	return shot;
}
function WarnShotA1(x,y,color){
	let shot = CreateShotA1(x,y,0,0,701+color,15);
	ObjShot_SetIntersectionEnable(shot,false);
	ObjShot_SetSpellResist(shot,true);
	Obj_SetValue(shot,FLAG_DUMMY,true);
	ObjShot_FadeDelete(shot);
	return shot;
}
function WarnShotA2(x,y,type,angle,color,shotdelay,fadedelay) {
	let shot = CreateShotA1(x,y,0,angle,type,shotdelay);
	ObjShot_SetIntersectionEnable(shot,false);
	ObjShot_SetSpellResist(shot,true);
	ObjRender_SetColor(shot,color[0],color[1],color[2]);
	if(length(color)>3){ObjRender_SetAlpha(shot,color[3]);}
	Obj_SetValue(shot,FLAG_DUMMY,true);
	DelayFadeDelete(shot,fadedelay);
	return shot;
}

function DebugWarnShot(x,y) {
	let shot = WarnShotA1(x,y,[255,255,255]);
}
function DebugWarnShot2(pos) {
	let shot = WarnShotA1(pos[0],pos[1],[255,255,255]);
}


//set a shot's color according to its delay color
function OS_TintShot(shot,tint){
	let color = OS_GetDelayColor(shot);
	let R=color[0]; let G=color[1]; let B=color[2];
	R = 255 - (255-R)*tint/255;
	G = 255 - (255-G)*tint/255;
	B = 255 - (255-B)*tint/255;
	OR_SetColor(shot,R,G,B);
	// color = [brightness+color[0],brightness+color[1],brightness+color[2]];
}

//Make object appear to flip, allowing graphic/etc 
//to be changed when it is fully invisible to avoid jarring effect
task OR_FlipX(obj,t){
	let s0 = OR_GetScaleX(obj);
	ascent(i in 0..t){
		OR_SetScaleX(obj, s0*(|cos(i*180/t)|) );
		yield;
	}
}


function SetMagicCircleAlpha(a,ma){
	// // MCircNextAlpha = m; //80
	// Obj_SetValue(objSpellCircle,"MaxAlpha",s); //64
	let bosses = GetAllBossID();
	ascent(i in 0..length(bosses)){
		Obj_SetValue(bosses[i],"MagicCircleAlpha",a);
		Obj_SetValue(bosses[i],"MagicCircleMaxAlpha",ma);
		// if(ma==0){ Obj_SetValue(bosses[i],"EnableMagicCircle",false); }
		Obj_SetValue(bosses[i],FLAG_CHECK,false);
	}
}

//smooth out the movement from ObjMove_SetDestAtFrame
//accelerate at start/end while keeping same total frames
function smooth(obj,frames,smoothness) {
	let spd = ObjMove_GetSpeed(obj);
	let acc = spd/smoothness;
	ObjMove_AddPatternA2(obj,0,0,NO_CHANGE,acc,0,spd);
	ObjMove_AddPatternA2(obj,frames-smoothness,NO_CHANGE,NO_CHANGE,-1*acc,0,0);
	return spd;
}



//Makes a "drain" that deletes shots
task Drain(cx,cy,r,time){
	loop(time){
		DeleteShotInCircle(TYPE_SHOT,TYPE_IMMEDIATE,cx,cy,r);
		yield;
	}
}


//Make a shot appear to "tremble" without moving its hitbox
//Done by creating a non-colliding shot with the same sprite/color/alpha/scale
function OS_Tremble(shot,xmag,ymag,dur){
	if(isnull(shot)){return;}
	let mx; let my; let rx; let ry;
	mx = ObjMove_GetX(shot);
	my = ObjMove_GetY(shot);
	let xdir = randSign; let ydir = randSign;
	
	let shotid = ObjShot_GetImageID(shot);
	let rshot = CreateShotA1(mx,my,0,0,shotid,0);
	ObjShot_SetIntersectionEnable(rshot,false);
	ObjShot_SetSpellResist(rshot,ObjShot_IsSpellResist(shot));
	Obj_SetVisible(shot,false);
	UpdateGraphic;
	
	RenderTremble;
	return rshot;
	
	task RenderTremble{
		ascent(i in 0..dur) {
			mx = ObjMove_GetX(shot);
			my = ObjMove_GetY(shot);
			rx = mx+sin(10*i*xdir)*cos(20*i*xdir)*xmag;
			ry = my+sin(20*i*ydir)*cos(10*i*ydir)*ymag;
			if(Obj_IsValueExists(shot,FLAG_CHECKINFO)){UpdateGraphic;}
			ObjMove_SetPosition(rshot,rx,ry);
			ObjMove_SetAngle(rshot,ObjMove_GetAngle(shot));
			yield;
		}	
		Obj_SetVisible(shot,true);
		Obj_Delete(rshot);
	}
	
	
	function UpdateGraphic{
		Obj_Delete(rshot);
		rshot = CopyShot(shot);
		ObjShot_SetIntersectionEnable(rshot,false);
		ObjShot_SetSpellResist(rshot,ObjShot_IsSpellResist(shot));
		if(!Obj_GetValue(shot,FLAG_CHECKINFO)){Obj_DeleteValue(shot,FLAG_CHECKINFO);}
		return;
		// //No getter for color, so stick it in the shot's dictionary when you set it
		// let color = Obj_GetValueD(shot,"Color",[255,255,255,Obj_GetValueD(shot,"Alpha",255)]);
		// ObjRender_SetColor(rshot,color[0],color[1],color[2]);
		// if(length(color)>3){ObjRender_SetAlpha(rshot,color[3]);}
		// else{ObjRender_SetAlpha(rshot,Obj_GetValueD(shot,"Alpha",255));}
		// ObjRender_SetScaleXYZ(rshot,ObjRender_GetScaleX(shot),ObjRender_GetScaleY(shot),1);
	}
	
}












//todo
task DeleteShotAllOut(type,deltype,x,y,t){
	let dr = 800/t;
	ascent(i in 0..t){
		DeleteShotInCircle(type,deltype,x,y,dr*i);
		yield;
	}
}

















//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//Since I can't be bothered to convert length and width to a number between 0 and 1, 
//two more parameters are used, sx and sy. sx is equal to the length of
//the spark and sy is the width. Trial and error.
//Standard sized Master Spark (obj is laser, obj2 aura):
//let obj = MasterSpark(bossX, bossY, GetAngleToPlayer(bossObj), 400, 200, 60, 1.5, 1, Spark, 255, 255, 255, BLEND_ADD_RGB);
//let obj2 = MasterSpark(bossX, bossY, GetAngleToPlayer(bossObj), 400, 200, 60, 1.5, 1.2, Spark, 0, 0, 255, BLEND_ADD_RGB);
function MasterSpark(x, y, a, l, w, d, sx, sy, tex, r, g, b, blend){
	let obj = ObjShot_Create(OBJ_STRAIGHT_LASER);
	ObjShot_Regist(obj);
	ObjMove_SetPosition(obj, x, y);
	ObjStLaser_SetAngle(obj, a);
	ObjStLaser_SetSource(obj, false);
	ObjLaser_SetLength(obj, l);
	ObjLaser_SetIntersectionWidth(obj, w);
	ObjShot_SetDelay(obj, d);
	ObjShot_SetGraphic(obj, 1);

	let objRender = ObjPrim_Create(OBJ_SPRITE_2D);
    ObjPrim_SetTexture(objRender, tex);
    ObjSprite2D_SetSourceRect(objRender, 1, 1, 256, 128);
    ObjSprite2D_SetDestRect(objRender, 1, -128, 256, 128);
    ObjRender_SetColor(objRender, r, g, b);
    ObjRender_SetScaleXYZ(objRender, sx, sy, 0);
    ObjRender_SetBlendType(objRender, blend);
    ObjRender_SetPosition(objRender, x, y, 0);
    Obj_SetRenderPriorityI(objRender, 49);
    ObjRender_SetAngleZ(objRender, a);

    sparkshit;

    return obj;

    task sparkshit{
    	let s = 0;
    	ObjRender_SetScaleY(objRender, 0.05);
    	wait(d);
    	loop(5){
    		ObjRender_SetScaleY(objRender, s);
    		ObjRender_SetPosition(objRender, ObjMove_GetX(obj), ObjMove_GetY(obj), 0);
    		ObjRender_SetAngleZ(objRender, ObjStLaser_GetAngle(obj));
    		s += sy/5;
    		yield;
    	}
    	s = sy;
    	while(!Obj_IsDeleted(obj)){
    		ObjRender_SetPosition(objRender, ObjMove_GetX(obj), ObjMove_GetY(obj), 0);
    		ObjRender_SetAngleZ(objRender, ObjStLaser_GetAngle(obj));
    		yield;
    	}
    	while(s > 0){
    		ObjRender_SetScaleY(objRender, s);
    		s -= 0.05;
    		yield;
    	}
    	Obj_Delete(objRender);
    }
}




function SparkA1(x,y,a,l,w,arc,delete,delay){
	return SparkA0(x,y,a,l,w,arc,delete,delay);
}


function SparkA0(x,y,a,l,w,arc,delete,delay){
	let wI = w;
	
	let shot = ObjShot_Create(OBJ_STRAIGHT_LASER);
	ObjMove_SetPosition(shot, x, y); ObjStLaser_SetAngle(shot, a);
	ObjLaser_SetLength(shot, l); ObjShot_SetDelay(shot, delay);
	ObjShot_SetGraphic(shot, NULL); ObjStLaser_SetSource(shot, false);
	Obj_SetVisible(shot,false); ObjShot_SetAutoDelete(shot,false);
	ObjLaser_SetInvalidLength(shot,100,100);
	ObjLaser_SetGrazeInvalidFrame(shot,9);
	ObjRender_SetBlendType(shot,BLEND_ADD_ARGB);
	Obj_SetValue(shot,LASER_RWIDTH,w); Obj_SetValue(shot,LASER_IWIDTH,w);
	ObjShot_Regist(shot);
	
	
	let nV = 32; //min 6 for 0 arc, 14+ for nonzero arc. 32 looks good
	let t=0;
	
	let robj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetPrimitiveType(robj,PRIMITIVE_TRIANGLESTRIP);
	ObjPrim_SetVertexCount(robj,nV);
	ObjPrim_SetTexture(robj,dirimg~"masterspark.png");
	Obj_SetRenderPriorityI(robj,PRI_SHOT+1);
	
	function GetSourceX(side,d){ return 800 * d/l +rand(-1,1); }
	function GetSourceY(side,d){ return 331.5 + 75.5*side +rand(-1,1); }
	
	function GetDestX(side,d){ return x + w/2*cos(a+90*side) + d*cos(a+arc*side) +rand(-1,1); }
	function GetDestY(side,d){ return y + w/2*sin(a+90*side) + d*sin(a+arc*side) +rand(-1,1); }

	function GetHitX(side,a,d){ return x + w/2*cos(a+90*side) + d*cos(a+arc*side); }
	function GetHitY(side,a,d){ return y + w/2*sin(a+90*side) + d*sin(a+arc*side); }
	
	sub UpdateVertices{
		let Al = OR_GetAlpha(shot);
		let C = OR_GetColor(shot); let R=C[0]; let G=C[1]; let B=C[2];
		ascent(i in 0..nV){
			let side = (-1)^i; 
			let d;
			alternative(i)
			case(0,1){ d=0; }
			case(2,3){ d=w/2; }
			case(nV-3,nV-4){ d=l-w/2; }
			case(nV-1,nV-2){ d=l; }
			others{ d = w/2 + 2*floor(i/2)/nV*(l-w); }
			
			ObjPrim_SetVertexPosition(robj,i, GetDestX(side,d), GetDestY(side,d), 0);
			if(i==2 || i==3){ d= 70/800 * l; }else
			if(i==nV-3 || i==nV-4){ d= (800-70)/800 * l; }
			ObjPrim_SetVertexUVT(robj,i,GetSourceX(side,d),GetSourceY(side,d));
			
			let dAl = 32*sin( t*25 - i*360*2/nV*l/800);
			ObjPrim_SetVertexAlpha(robj,i, Al+dAl );
			ObjPrim_SetVertexColor(robj,i, R+dAl, G+dAl, B+dAl );
		}
	}
	
	sub SetHitbox{
		if(!Obj_GetValueD(shot,FLAG_INTERSECTION,true)){return;}
		ObjShot_SetIntersectionCircleA2(shot, x+w/2*cos(a), y+w/2*sin(a),                                                                    0.85*wI/2);
		ObjShot_SetIntersectionLine(shot,     GetHitX(0,a,    w/4),GetHitY(0,a,    w/4),GetHitX(0,a,    l-w*0.75),GetHitY(0,a,    l-w*0.75), 0.85*wI/2);
		if(!!arc){ //if(arc!=0){
			ObjShot_SetIntersectionLine(shot, GetHitX(0,a+arc,w/4),GetHitY(0,a+arc,w/4),GetHitX(0,a+arc,l-w*0.75),GetHitY(0,a+arc,l-w*0.75), 0.85*wI/2);
			ObjShot_SetIntersectionLine(shot, GetHitX(0,a-arc,w/4),GetHitY(0,a-arc,w/4),GetHitX(0,a-arc,l-w*0.75),GetHitY(0,a-arc,l-w*0.75), 0.85*wI/2);
		}
	}
	
	Obj_SetValue(shot,RENDER_OBJECT,robj);
	Manage;
	return shot;
	
	task Manage{
		yield;
		while(!Obj_IsDeleted(shot) && t<delete){
			a = ObjStLaser_GetAngle(shot);
			x = ObjMove_GetX(shot);
			y = ObjMove_GetY(shot);
			l = ObjLaser_GetLength(shot);
			w  = Obj_GetValueD(shot,LASER_RWIDTH,w);
			wI = Obj_GetValueD(shot,LASER_IWIDTH,wI);
			
			arc = Obj_GetValueD(shot,SPARK_ARC,arc);
			if(Obj_IsValueExists(shot,"SparkVerts")){
				nV = Obj_GetValue(shot,"SparkVerts"); Obj_DeleteValue(shot,"SparkVerts");
				ObjPrim_SetVertexCount(shot,nV);
			}
			
			ObjRender_SetBlendType(robj,ObjRender_GetBlendType(shot));
			
			UpdateVertices();
			SetHitbox();
			
			yield; t++;
		}
		Obj_Delete(robj);
	}
}


task ManageSparkA1(spk,w,delete,delay){
	let expan = min( 30, (delete-delay*2)/2 );
	ManageSparkA0(spk,w,delete,delay,expan,expan);
}
task ManageSparkA2(spk,w,delete,delay,expand,contract){
	ManageSparkA0(spk,w,delete,delay,expand,contract);
}

	
task ManageSparkA0(spk,w,delete,delay,expand,contract){
	let dur = delete - delay - expand - contract; //duration at full width
	function SetWidth(wid){ OL_SetRenderWidth(spk, wid); OL_SetIntersectionWidth(spk, wid); }
	ascent(f in 0..delay){     SetWidth( 1                ); yield; }
	ascent(f in 0..expand){    SetWidth( w*(f/expand)^0.5 ); yield; }
	ascent(f in 0..dur){       SetWidth( w                ); yield; }
	descent(f in 0..contract){ SetWidth( w*(f/contract)^2 ); yield; }
	Obj_Delete(spk);
}












//Debug function to label vertices of a primitive
task ShowVertices(obj){
	let nV = ObjPrim_GetVertexCount(obj);
	let texts = [];
	ascent(i in 0..nV){
		let text = ObjText_Create;
		ObjText_SetFontSize(text,8);
		ObjText_SetFontBorderType(text,BORDER_FULL);
		ObjText_SetFontBorderColor(text,0,0,0);
		ObjText_SetFontBorderWidth(text,1);
		ObjText_SetText(text,itoa(i));
		
		texts = texts~[text];
	}
	while(!Obj_IsDeleted(obj)){
		ascent(i in 0..nV){
			let pos = ObjPrim_GetVertexPosition(obj,i);
			ObjRender_SetPosition(texts[i], pos[0],pos[1],0);
		}
		yield;
	}
}


















//move x% of the remaining distance
function ObjMove_SetDestAtZeno(obj,x,y,ratio){
	let x0 = ObjMove_GetX(obj); let y0 = ObjMove_GetY(obj);
	//let dist = getdist(x0,y0,x,y); let ang = getangle(x0,y0,x,y);
	ObjMove_SetPosition(obj,lerp(x0,x,ratio),lerp(y0,y,ratio));
}

//disappear and warp to the destination
task ObjMove_SetDestAtWarp(obj, destX, destY, time){
	let xscale = ObjRender_GetScaleX(obj);
	let yscale = ObjRender_GetScaleY(obj);

	let ori = [xscale, yscale]; let tmp;

	Obj_SetValue(obj, "Warping", true);
	Obj_SetValue(obj, "Destination", [destX, destY]);

	let smooth=true;
	if(time<0){time=(|time|);smooth=false;}
	
	let blinktime; let hidetime;
	if(time!=0){
		blinktime = min(20,time/2);
		hidetime = time-2*blinktime;
	}else{
		blinktime = 20;
		hidetime = 0;
	}
	
	loop(blinktime){
		ObjRender_SetScaleXYZ(obj, xscale, yscale, 0);
		xscale -= ori[0]/blinktime;
		yscale += ori[1]/blinktime;
		yield;
	}
	if(hidetime!=0){
		if(Obj_GetType(obj)==OBJ_SHOT){tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); ObjShot_SetIntersectionEnable(obj,false);}
		if(Obj_GetType(obj)==OBJ_ENEMY_BOSS){ tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); Obj_SetValue(obj,"IsIntersectionEnable",false); }
		if(Obj_GetType(obj)==OBJ_ENEMY){ tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); Obj_SetValue(obj,"IsIntersectionEnable",false); }
		
		Obj_SetVisible(obj,false);
		
		if(smooth){
			ObjMove_SetDestAtFrame(obj,destX,destY,hidetime);
		}else{
			let ang = getangle(ex,ey,destX,destY);
			ObjMove_SetPosition(obj,ex+2000*cos(ang),ey+2000*sin(ang));
		}
		wait(hidetime);
		Obj_SetVisible(obj,true);
		ObjMove_SetPosition(obj,destX,destY);
		
		if(Obj_GetType(obj)==OBJ_SHOT){ObjShot_SetIntersectionEnable(obj,Obj_GetValueD(obj,"IsIntersectionEnable",true));}
		if(Obj_GetType(obj)==OBJ_ENEMY_BOSS){ Obj_SetValue(obj,"IsIntersectionEnable",tmp); }
		if(Obj_GetType(obj)==OBJ_ENEMY){ Obj_SetValue(obj,"IsIntersectionEnable",tmp); }
	}
	ObjRender_SetPosition(obj, destX, destY, 0);
	loop(20){
		ObjRender_SetScaleXYZ(obj, xscale, yscale, 0);
		xscale += ori[0]/20;
		yscale -= ori[1]/20;
		yield;
	}
	Obj_SetValue(obj, "Warping", false);
	ObjRender_SetScaleXYZ(obj, ori[0], ori[1], 0);
}

//"Jump" to a location, growing larger and then smaller again
task ObjMove_SetDestAtScale(obj,destX,destY,time,scaleincr){
	let xscale = ObjRender_GetScaleX(obj);
	let yscale = ObjRender_GetScaleY(obj);
	
	let dx = (destX - ObjRender_GetX(obj))/time;
	let dy = (destY - ObjRender_GetY(obj))/time;
	
	let xs; let ys;

	Obj_SetValue(obj, "Warping", true);
	Obj_SetValue(obj, "Destination", [destX, destY]);

	let tmp;
	if(Obj_GetType(obj)==OBJ_SHOT){tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); ObjShot_SetIntersectionEnable(obj,false);}
	if(Obj_GetType(obj)==OBJ_ENEMY_BOSS){ tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); Obj_SetValue(obj,"IsIntersectionEnable",false); }
	if(Obj_GetType(obj)==OBJ_ENEMY){ tmp = Obj_GetValueD(obj,"IsIntersectionEnable",true); Obj_SetValue(obj,"IsIntersectionEnable",false); }
	
	ascent(i in 0..time){
		xs = xscale+xscale*scaleincr*sin(i*180/time);
		ys = yscale+yscale*scaleincr*sin(i*180/time);
		ObjRender_SetScaleXYZ(obj, xs,ys, 0);
		ObjRender_SetPosition(obj,ObjRender_GetX(obj)+dx,ObjRender_GetY(obj)+dy,0);
		yield;
	}
	
	if(Obj_GetType(obj)==OBJ_SHOT){ObjShot_SetIntersectionEnable(obj,Obj_GetValueD(obj,"IsIntersectionEnable",true));}
	if(Obj_GetType(obj)==OBJ_ENEMY_BOSS){ Obj_SetValue(obj,"IsIntersectionEnable",tmp); }
	if(Obj_GetType(obj)==OBJ_ENEMY){ Obj_SetValue(obj,"IsIntersectionEnable",tmp); }

	Obj_SetValue(obj, "Warping", false);
//	ObjRender_SetScaleXYZ(obj, ori[0], ori[1], 0);
}








//How many shots can you dodge in the stopped time?
let TimeFlowing = true;
let TimeCenter = NULL;

function OM_Freeze(obj){
	if(!Obj_GetValueD(obj,FLAG_FREEZE,false)){
		if(!Obj_GetValueD(obj,FLAG_XYMOVE,false)){ SetArrProps(TimeProps_SA,0); }
		else{ SetArrProps(TimeProps_XY,0); }
		// SetArrProps( [TimeProps_SA,TimeProps_XY][Obj_GetValueD(obj,FLAG_XYMOVE,false)], 0 ); //yiss ternary operator so sexy
		SetArrProps(TimeProps_F1,true);
		SetArrProps(TimeProps_F2,false);
		if(Obj_GetType(obj)==OBJ_SHOT){SetArrProps(TimeProps_Sh,0);}
		
		function SetArrProps(props,v){
			ascent(i in 0..length(props)){
				let prop = props[i];
				let orig = O_GetProperty(obj,prop);
				O_SetProperty(obj,prop,0);
				Obj_SetValue(obj,prop,orig);
			}
		}
		Obj_SetValue(obj,FLAG_FREEZE,true);
	}
}
function OM_Resume(obj){
	if(Obj_GetValueD(obj,FLAG_FREEZE,false)){
		if(!Obj_GetValueD(obj,FLAG_XYMOVE,false)){ SetArrProps(TimeProps_SA); }
		else{ SetArrProps(TimeProps_XY); }
		// SetArrProps( [TimeProps_SA,TimeProps_XY][Obj_GetValueD(obj,FLAG_XYMOVE,false)] ); //yiss ternary operator so sexy
		SetArrProps(TimeProps_F1);
		SetArrProps(TimeProps_F2);
		if(Obj_GetType(obj)==OBJ_SHOT){SetArrProps(TimeProps_Sh);}
		
		function SetArrProps(props){
			ascent(i in 0..length(props)){
				let prop = props[i];
				let orig = Obj_GetValueD(obj,prop,O_GetProperty(obj,prop));
				O_SetProperty(obj,prop,orig);
			}
		}
		Obj_SetValue(obj,FLAG_FREEZE,false);
	}
}

//Properties to manipulate to stop time
let TimeProps_SA = []; 
let TimeProps_XY = []; 
let TimeProps_Sh = [];
let TimeProps_F1 = []; //true when frozen
let TimeProps_F2 = []; //false when frozen
let RebuildTimeProps=true;

sub BuildTimePropertyArray{
	TimeProps_SA=[];TimeProps_XY=[];TimeProps_F1=[];TimeProps_F2=[];TimeProps_Sh=[];
	TimeProps_SA=TimeProps_SA ~ [MOVE_MAXSPEED,MOVE_SPEED,MOVE_ACCEL];		
	TimeProps_SA=TimeProps_SA ~ [MOVE_ANGV]; //don't set angle to zero!
	
	TimeProps_XY=TimeProps_XY ~ [MOVE_XMAXSPEED];		
	TimeProps_XY=TimeProps_XY ~ [MOVE_YMAXSPEED];		
	TimeProps_XY=TimeProps_XY ~ [MOVE_XSPEED];		
	TimeProps_XY=TimeProps_XY ~ [MOVE_YSPEED];		
	TimeProps_XY=TimeProps_XY ~ [MOVE_XACCEL];		
	TimeProps_XY=TimeProps_XY ~ [MOVE_YACCEL];		
	
	// TimeProps_Sh=TimeProps_Sh ~ [SHOT_DELETEFRAME];
	TimeProps_F1=TimeProps_F1 ~ [FLAG_SPELLRESIST];
	TimeProps_F2=TimeProps_F2 ~ [FLAG_INTERSECTION];
	RebuildTimeProps=false;
}



//
//TODO: Look into using render targets to forcibly freeze specific render priorities (background)
task TimeStopA1{
	let shots;
	if(RebuildTimeProps){BuildTimePropertyArray;}
	

	//ZA WARUDO!
	sub StopAll{
		shots = GetShotIdInCircleA2(cx,cy,9999,TARGET_ALL);
		ascent(i in 0..length(shots)){
			let shot = shots[i];
			OM_Freeze(shot);
		}
	}
	
	function ToHold(state){ 
		alternative(state)
		case(KEY_HOLD,KEY_PUSH){return KEY_HOLD;} 
		case(KEY_FREE,KEY_PULL){return KEY_FREE;}
	}
	
	let OSpd = GetPlayerSpeed;
	let OLft = ToHold(GetVirtualKeyState(VK_LEFT));
	let ORgt = ToHold(GetVirtualKeyState(VK_RIGHT));
	let OFoc = ToHold(GetVirtualKeyState(VK_SLOWMOVE));
	let OTime = ObjEnemyBossScene_GetInfo(objScene,INFO_TIMERF);
	let OX = ObjRender_GetX(GetPlayerObjectID); let OY = ObjRender_GetY(GetPlayerObjectID);
	
	TEffect;
	TimeFlowing = false;
	SetCommonData("IsTimeFlowing",false);	
	SetCommonData("IsTimeStop",true);
	SetCommonData("TimeRate",0);
	
	//Toki yo tomare!
	StopAll;
	while(!TimeFlowing){
		frame--;
		if(OSpd[0]==0 && GetPlayerSpeed[0]!=0){OSpd=GetPlayerSpeed;}
		SetPlayerSpeed(0,0);
		ObjRender_SetPosition(GetPlayerObjectID,OX,OY,0);
		SetVirtualKeyState(VK_LEFT,OLft);
		SetVirtualKeyState(VK_RIGHT,ORgt);
		SetVirtualKeyState(VK_UP,KEY_FREE);
		SetVirtualKeyState(VK_DOWN,KEY_FREE);
		SetVirtualKeyState(VK_SHOT,KEY_FREE);
		SetVirtualKeyState(VK_BOMB,KEY_FREE);
		SetVirtualKeyState(VK_SLOWMOVE,OFoc);
		ObjEnemyBossScene_SetSpellTimer(objScene,OTime);
		if(GetPlayerInvincibilityFrame>0){SetPlayerInvincibilityFrame(GetPlayerInvincibilityFrame+1);}
		//if(GetPlayerDownStateFrame>0){SetPlayerDownStateFrame(GetPlayerDownStateFrame+1);}
		
		// if(GetShotCount(TARGET_ALL) != length(shots)){
		StopAll;
		// }
		
		yield;
	}

	//Soshite, toki wo ugokidasu.
	// if(GetCommonData("StopShots",NULL)!=NULL){shots = shots ~ GetCommonData("StopShots"); DeleteCommonData("StopShots");}
	ascent(i in 0..length(shots)){
		let shot = shots[i];
		OM_Resume(shot);
	}
	if(OSpd[0]!=0 && OSpd[1]!=0){SetPlayerSpeed(OSpd[0],OSpd[1]);}
	
	SetCommonData("IsTimeFlowing",true);
	SetCommonData("IsTimeStop",false);
	SetCommonData("TimeRate",1);
	//Done
	
	//Manages invert effect
	task TEffect{
		SE_Play(se_timestop,100);
		let circ = CreateSprite(cx,cy,dirimg~"circle.png",[0,0,256,256],73); let scl;
		ObjRender_SetBlendType(circ,BLEND_ALPHA);
		ObjRender_SetAlpha(circ,128);
		let hamon = CreateSprite(cx,cy,dirimg~"ripple_rgb.png",[0,0,480,480],73);
		ObjRender_SetBlendType(hamon,BLEND_INV_DESTRGB);
		//setdat("TimeEffect",[circ,hamon]);
		ascent(i in 0..60){
			scl = i*6/60; //4/45 
			ObjRender_SetScaleXYZ(circ,scl,scl,1); 
			ObjRender_SetScaleXYZ(hamon,scl,scl,1);
			if(TimeCenter!=NULL){
				setrpos(circ,getrx(TimeCenter),getry(TimeCenter),0);
				setrpos(hamon,getrx(TimeCenter),getry(TimeCenter),0);
			}
			yield;
		}
		while(!TimeFlowing){yield;}
		descent(i in 0..30){
			scl = i*6/30; 
			ObjRender_SetScaleXYZ(circ,scl,scl,1); 
			ObjRender_SetScaleXYZ(hamon,scl,scl,1);
			if(TimeCenter!=NULL){
				setrpos(circ,getrx(TimeCenter),getry(TimeCenter),0);
				setrpos(hamon,getrx(TimeCenter),getry(TimeCenter),0);
			}
			yield;
		}
		Obj_Delete(circ);
		Obj_Delete(hamon);
		//remdat("TimeEffect");
	}
}
function TimeResume{
	TimeFlowing = true;
}
//Freeze additional shots in time, and unfreeze them when time resumes
function TimeAddShots(shots){
	let shot;
	ascent(i in 0..length(shots)){
		shot = shots[i];
		setval(shot,"StopSpeed",getsp(shot));
		setval(shot,"StopAcceleration",getvald(shot,"Acceleration",0));
		setval(shot,"StopAngularVelocity",getvald(shot,"AngularVelocity",0));
		setval(shot,"StopSpellResist",ObjShot_IsSpellResist(shot));
		setval(shot,"StopIntersection",Obj_GetValueD(shot,"IsIntersectionEnable",true));
		ObjMove_SetSpeed(shot,0);
		ObjMove_SetAcceleration(shot,0);
		ObjMove_SetAngularVelocity(shot,0);
		ObjShot_SetSpellResist(shot,true);
		ObjShot_SetIntersectionEnable(shot,false);
	}
	setdat("StopShots",getdatd("StopShots",[]) ~ shots);
}







task TimeStop{
	let shots = GetShotIdInCircleA2(cx,cy,9999,TARGET_ALL);
	let shot;

	//ZA WARUDO!
	ascent(i in 0..length(shots)){
		shot = shots[i];
		setval(shot,"StopSpeed",getsp(shot));
		setval(shot,"StopAcceleration",getvald(shot,"Acceleration",0));
		setval(shot,"StopAngularVelocity",getvald(shot,"AngularVelocity",0));
		setval(shot,"StopSpellResist",ObjShot_IsSpellResist(shot));
		setval(shot,"StopIntersection",Obj_GetValueD(shot,"IsIntersectionEnable",true));
		ObjMove_SetSpeed(shot,0);
		ObjMove_SetAcceleration(shot,0);
		ObjMove_SetAngularVelocity(shot,0);
		ObjShot_SetSpellResist(shot,true);
		ObjShot_SetIntersectionEnable(shot,false);
	}
	let OSpd = GetPlayerSpeed;
	let OLft = GetVirtualKeyState(VK_LEFT); if(OLft==KEY_PUSH){OLft = KEY_HOLD;}
	let ORgt = GetVirtualKeyState(VK_RIGHT);if(ORgt==KEY_PUSH){ORgt = KEY_HOLD;}
	let OFoc = GetVirtualKeyState(VK_SLOWMOVE);if(OFoc==KEY_PUSH){OFoc = KEY_HOLD;}
	let OTime = ObjEnemyBossScene_GetInfo(objScene,INFO_TIMERF);
	let OX = ObjRender_GetX(GetPlayerObjectID); let OY = ObjRender_GetY(GetPlayerObjectID);
	
	TEffect;
	TimeFlowing = false; setdat("TimeFlowing",false);	
	
	//Toki yo tomare!
	while(!TimeFlowing){
		frame--;
		if(OSpd[0]==0 && GetPlayerSpeed[0]!=0){OSpd=GetPlayerSpeed;}
		SetPlayerSpeed(0,0);
		ObjRender_SetPosition(GetPlayerObjectID,OX,OY,0);
		SetVirtualKeyState(VK_LEFT,OLft);
		SetVirtualKeyState(VK_RIGHT,ORgt);
		SetVirtualKeyState(VK_UP,KEY_FREE);
		SetVirtualKeyState(VK_DOWN,KEY_FREE);
		SetVirtualKeyState(VK_SHOT,KEY_FREE);
		SetVirtualKeyState(VK_BOMB,KEY_FREE);
		SetVirtualKeyState(VK_SLOWMOVE,OFoc);
		ObjEnemyBossScene_SetSpellTimer(objScene,OTime);
		if(GetPlayerInvincibilityFrame>0){SetPlayerInvincibilityFrame(GetPlayerInvincibilityFrame+1);}
		//if(GetPlayerDownStateFrame>0){SetPlayerDownStateFrame(GetPlayerDownStateFrame+1);}
		
		yield;
	}

	//Soshite, toki wo ugokidasu.
	if(isdat("StopShots")){shots = shots ~ getdat("StopShots"); remdat("StopShots");}
	ascent(i in 0..length(shots)){
		shot = shots[i];
		ObjMove_SetSpeed(shot,getvald(shot,"StopSpeed",getsp(shot)));
		ObjMove_SetAcceleration(shot,getvald(shot,"StopAcceleration",getvald(shot,"Acceleration",0)));
		ObjMove_SetAngularVelocity(shot,getvald(shot,"StopAngularVelocity",getvald(shot,"AngularVelocity",0)));
		ObjShot_SetSpellResist(shot,getvald(shot,"StopSpellResist",false));
		ObjShot_SetIntersectionEnable(shot,getvald(shot,"StopIntersection",true));
	}
	if(OSpd[0]!=0 && OSpd[1]!=0){SetPlayerSpeed(OSpd[0],OSpd[1]);}
	//get rid of any shots that are RIGHT on top of the player
	shots = GetShotIdInCircleA2(px,py,20,TARGET_ENEMY);
	ascent(i in 0..length(shots)){
		if(Obj_GetValueD(shots[i],"StopIntersection",true)){
			ObjShot_FadeDelete(shots[i]);
		}
	}
	setdat("TimeFlowing",true);
	//Done
	
	//Manages invert effect
	task TEffect{
		SE_Play(se_timestop,100);
		let circ = CreateSprite(cx,cy,dirimg~"circle.png",[0,0,256,256],73); let scl;
		ObjRender_SetBlendType(circ,BLEND_ALPHA);
		ObjRender_SetAlpha(circ,128);
		let hamon = CreateSprite(cx,cy,dirimg~"ripple_rgb.png",[0,0,480,480],73);
		ObjRender_SetBlendType(hamon,BLEND_INV_DESTRGB);
		//setdat("TimeEffect",[circ,hamon]);
		ascent(i in 0..60){
			scl = i*6/60; //4/45 
			ObjRender_SetScaleXYZ(circ,scl,scl,1); 
			ObjRender_SetScaleXYZ(hamon,scl,scl,1);
			if(TimeCenter!=NULL){
				setrpos(circ,getrx(TimeCenter),getry(TimeCenter),0);
				setrpos(hamon,getrx(TimeCenter),getry(TimeCenter),0);
			}
			yield;
		}
		while(!TimeFlowing){yield;}
		descent(i in 0..30){
			scl = i*6/30; 
			ObjRender_SetScaleXYZ(circ,scl,scl,1); 
			ObjRender_SetScaleXYZ(hamon,scl,scl,1);
			if(TimeCenter!=NULL){
				setrpos(circ,getrx(TimeCenter),getry(TimeCenter),0);
				setrpos(hamon,getrx(TimeCenter),getry(TimeCenter),0);
			}
			yield;
		}
		Obj_Delete(circ);
		Obj_Delete(hamon);
		//remdat("TimeEffect");
	}
}



















//Get the point at which the line intersects a stage border
function GetLineBorderPoint(x0, y0, x1, y1){ //Trickysticks is such a nice person :D
	let a = atan2(y1-y0, x1-x0);
	let aTL = atan2( 0-y0, 0-x0);     let aTR = atan2( 0-y0,sx-x0);
	let aBL = atan2(sy-y0, 0-x0);     let aBR = atan2(sy-y0,sx-x0);
	if(  a >= aTL && a <= aTR ){
		return [x0 - (0-y0)*tan(a+90), 0]; //top
	}if( a >= aTR && a <= aBR ){
		return [sx, y0 + (sx-x0)*tan(a)]; //right
	}if( a >= aBR && a <= aBL ){
		return [x0 - (sx-y0)*tan(a-90), sy]; //bottom
	}if( a >= aBL || a <= aTL ){
		return [0, y0 + (0-x0)*tan(a+180)]; //left
	}
	return [];
}

//Determine whether specified line segment intersects a stage border
function GetLineWallIntersection(x0, y0, x1, y1){ //Trickysticks is such a nice person :D
	let ta = atan2(y1-y0, x1-x0);
	if( ta>= atan2(0 - y0, sx - x0) && ta<=  atan2(sy - y0, sx - x0)){ return true; }
	if( ta> atan2(sy - y0, 0 - x0) || ta<  atan2(0 - y0, 0 - x0)){ return true; }
}




//From Koishitale
task ObjPlayer_SetDestAtFrame(px,py,frame){
	let originalposition = [GetPlayerX,GetPlayerY];
	let distance = [  px-GetPlayerX ,py-GetPlayerY ];
	ascent(i in 0..frame){
		SetVirtualKeyState(VK_LEFT,KEY_FREE);
		SetVirtualKeyState(VK_RIGHT,KEY_FREE);
		SetVirtualKeyState(VK_UP,KEY_FREE);
		SetVirtualKeyState(VK_DOWN,KEY_FREE);
		ObjMove_SetPosition(GetPlayerObjectID,originalposition[0]+distance[0]*i/frame,originalposition[1]+distance[1]*i/frame);
		yield;
	}
}
task ObjPlayer_DisableControl(frame){
	loop(frame){
		SetVirtualKeyState(VK_LEFT,KEY_FREE);
		SetVirtualKeyState(VK_RIGHT,KEY_FREE);
		SetVirtualKeyState(VK_UP,KEY_FREE);
		SetVirtualKeyState(VK_DOWN,KEY_FREE);
		SetVirtualKeyState(VK_SHOT,KEY_FREE);
		SetVirtualKeyState(VK_BOMB,KEY_FREE);
		SetVirtualKeyState(VK_SLOWMOVE,KEY_FREE);
		yield;
	}
}





function InvertRipple(x,y,scl0,scl1,time){
	let hamon = CreateSprite(x,y,dirimg~"ripple_rgb.png",[0,0,480,480],73);
	ObjRender_SetBlendType(hamon,BLEND_INV_DESTRGB);
	let hamon2 = CreateSprite(x,y,dirimg~"ripple_rgb.png",[0,0,480,480],73);
	ObjRender_SetBlendType(hamon2,BLEND_ADD_RGB);
	ObjRender_SetColor(hamon2,64,64,64);
	TRipple;
	
	task TRipple{
		let scl; let dScl = (scl1 - scl0)/time;
		ascent(i in 0..time){
			scl = scl0+i*dScl;
			ObjRender_SetScaleXYZ(hamon,scl,scl,1);
			ObjRender_SetScaleXYZ(hamon2,scl,scl,1);
			yield;
		}
		Obj_Delete(hamon);
		Obj_Delete(hamon2);
	}
	
	setval(hamon,"RenderObject",hamon2);
	return hamon;
}






//AJS (modified by Andi)
function PagodaLaserA1(x,y,a,maxlength,maxwidth,dur,color,delay) {
	return PagodaLaser(x,y,a,maxlength,maxwidth,dur,color,delay,maxwidth/96,"PagodaLaser.png");
}

function PagodaLaserA2(x,y,a,maxlength,maxwidth,dur,color,delay,img) {
	return PagodaLaser(x,y,a,maxlength,maxwidth,dur,color,delay,maxwidth/96,img);
}

function PagodaLaser(x,y,a,maxlength,maxwidth,dur,color,delay,scale,effimg) {
	let objHitbox = CreateStraightLaserA1(x,y,a,maxlength,maxwidth*(5/4),dur+45,1,delay);
	ObjLaser_SetInvalidLength(objHitbox, 0, 0);
	PagodaBeam;
	return objHitbox;
	
	task PagodaBeam {
		let objLaser1 = ObjPrim_Create(OBJ_SPRITE_2D);
		let objLaser2 = ObjPrim_Create(OBJ_SPRITE_2D);
		let objDetail = ObjPrim_Create(OBJ_SPRITE_2D);
		let objFire = ObjPrim_Create(OBJ_SPRITE_2D);
		let objFire2 = ObjPrim_Create(OBJ_SPRITE_2D);
				
		let width = 2;
		let length = maxlength;
		if(scale<0){scale=maxwidth/96;}
		let fire_scalex = 1.75*scale; //1.2
		let fire_scaley = 2.5*scale; //1.2
		let fire_scale2x = 1.5*scale; //0.8
		let fire_scale2y = 2.25*scale; //0.8
		let fire_count = 0;
		let detail_count = 0;
				
		Obj_SetVisible(objHitbox,false);
		
		ObjRender_SetBlendType(objLaser1, BLEND_ALPHA);
		Obj_SetRenderPriorityI(objLaser1, 28);
		ObjPrim_SetTexture(objLaser1, dirshot~"img/"~effimg);
		ObjSprite2D_SetSourceRect(objLaser1, 0, 37, 256, 69);
		ObjSprite2D_SetDestRect(objLaser1, 0.5, -16, 256.5, 16);
		ObjRender_SetColor(objLaser1,color[0],color[1],color[2]);
		
		ObjRender_SetBlendType(objLaser2, BLEND_ADD_RGB);
		Obj_SetRenderPriorityI(objLaser2, 29);
		ObjPrim_SetTexture(objLaser2, dirshot~"img/"~effimg);
		ObjSprite2D_SetSourceRect(objLaser2, 0, 77, 256, 109);
		ObjSprite2D_SetDestRect(objLaser2, 0.5, -16, 256.5, 16);
		
		ObjRender_SetBlendType(objDetail, BLEND_ALPHA);
		Obj_SetRenderPriorityI(objDetail, 29);
		ObjPrim_SetTexture(objDetail, dirshot~"img/"~effimg);
		ObjSprite2D_SetSourceRect(objDetail, 0, 0, 256, 30);
		ObjSprite2D_SetDestRect(objDetail, 0.5, -18, 256.5, 18);
		
		ObjRender_SetBlendType(objFire, BLEND_ALPHA);
		Obj_SetRenderPriorityI(objFire, 27);
		ObjPrim_SetTexture(objFire, dirshot~"img/PagodaLaser_Fire.png");
		ObjRender_SetColor(objFire,color[0],color[1],color[2]);
		ObjRender_SetScaleXYZ(objFire,fire_scalex,fire_scaley,1);
		
		ObjRender_SetBlendType(objFire2, BLEND_ADD_RGB);
		Obj_SetRenderPriorityI(objFire2, 30);
		ObjPrim_SetTexture(objFire2, dirshot~"img/PagodaLaser_Fire.png");
		ObjRender_SetScaleXYZ(objFire2,fire_scale2x,fire_scale2y,1);
		
		UpdatePos;
		task UpdatePos{
			while(!Obj_IsDeleted(objHitbox)){
				x = ObjMove_GetX(objHitbox);
				y = ObjMove_GetY(objHitbox);
				a = ObjStLaser_GetAngle(objHitbox);
				
				ObjRender_SetPosition(objLaser1,x,y,0);
				ObjRender_SetAngleZ(objLaser1,a);
				ObjRender_SetPosition(objLaser2,x,y,0);
				ObjRender_SetAngleZ(objLaser2,a);
				ObjRender_SetPosition(objDetail,x,y,0);
				ObjRender_SetAngleZ(objDetail,a);
				ObjRender_SetPosition(objFire,x,y,0);
				ObjRender_SetAngleZ(objFire,a);
				ObjRender_SetPosition(objFire2,x,y,0);
				ObjRender_SetAngleZ(objFire2,a);
				
				
				if(fire_count%2==0) { ObjSprite2D_SetSourceRect(objFire, 1, 1, 123, 127); }
				else if(fire_count%2==1) { ObjSprite2D_SetSourceRect(objFire, 129, 1, 255, 127); }
				ObjSprite2D_SetDestRect(objFire, 0.5, -61, 128.5, 61);
				if(fire_count%2==0) { ObjSprite2D_SetSourceRect(objFire2, 1, 129, 123, 255); }
				else if(fire_count%2==1) { ObjSprite2D_SetSourceRect(objFire2, 129, 129, 255, 255); }
				ObjSprite2D_SetDestRect(objFire2, 0.5, -61, 128.5, 61);
				
				ObjSprite2D_SetSourceRect(objDetail, 0-detail_count, 0, 256-detail_count, 30);
				ObjSprite2D_SetDestRect(objDetail, 0.5, -18, 256.5, 18);
				
				ObjRender_SetScaleXYZ(objLaser1,2*(length/800),width/25,1);
				ObjRender_SetScaleXYZ(objLaser2,2*(length/800),width/32,0);
				ObjRender_SetScaleXYZ(objDetail,2*(length/800),width/32,0);
				
				fire_count+=0.5;
				detail_count+=12;
				
				yield;
			}
			Obj_Delete(objLaser1);
			Obj_Delete(objLaser2);
			Obj_Delete(objDetail);
			Obj_Delete(objFire);
			Obj_Delete(objFire2);
		}
		
		//Delay
		loop(delay){ yield; }
		length = 0;
		//Active
		loop(dur) {
			length = min(length+800/20, maxlength);
			width  = min(width+(maxwidth-2)/20, maxwidth-2);
			
			yield;
		}
		//Remove
		ObjShot_SetIntersectionEnable(objHitbox,false);
		loop(30) {				
			ObjRender_SetScaleY(objFire,fire_scaley*(width/32));
			ObjRender_SetScaleY(objFire2,fire_scale2y*(width/32));
			
			width-=(maxwidth+2)/30;
			yield;
		}
		
		Obj_Delete(objHitbox);
	}
}



//Simpler function, manages glow for a sun created as a normal shot
function SunGlow(shot){
	let obj = CreateSprite(ObjMove_GetX(shot),ObjMove_GetY(shot),dirimg~"Sun2.png",[0,0,255,255],PRI_SHOT+1);
	ObjRender_SetBlendType(obj,BLEND_ADD_RGB);
	Manage;
	return obj;
	
	task Manage{
		let c = OR_GetColor(shot);
		let R = c[0]; let G = c[1]; let B = c[2];
		while(!Obj_IsDeleted(shot)){
			let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot);
			ObjRender_SetPosition(obj,x,y,0);
			
			// ObjRender_SetAngleZ(obj,-5*frame);			
			
			let A = OR_GetAlpha(shot)/255  * ( 1 - ((|sin(frame*15)|)^2)/2 );
			ObjRender_SetColor(obj,R*A,G*A,B*A);
			
			let scl = OR_GetScale(shot); //?
			ObjRender_SetScaleXYZ(obj,scl/2,scl/2,1);
			
			let r = 64*scl;
			ObjShot_SetIntersectionCircleA1(shot,r);
			
			yield;
		}
		Obj_Delete(obj);
	}
}



//Extra-advanced sun function for all your crazy movement needs (heavily tweaked version ofan already heavily tweaked version of Frenticpony's)
function CreateSunShot(x, y, speed, angle, type, initScale, sizePerFrame, endScale, texture2, texture, r, g, b){
    let loc_scale = initScale;
    let growToInit = 0;
	let rad = 128 * endScale;
    
    let objShot = ObjShot_Create(OBJ_SHOT);
    ObjShot_Regist(objShot);
    ObjShot_SetSpellResist(objShot, true);
    ObjMove_SetPosition(objShot, x, y);
    ObjMove_SetSpeed(objShot, speed);
    ObjMove_SetAngle(objShot, angle);
	
	//There'll be plenty of other frames to set the hitbox on
	//So probably don't set it on the first frame to avoid it clipping the player before you can disable it
	if(!(type=="GROW" || type == "SHRINK") && Obj_GetValueD(objShot,"IsIntersectionEnable",false)){ObjShot_SetIntersectionCircleA1(objShot, 92 * initScale);}
           
    let objRender = ObjPrim_Create(OBJ_SPRITE_2D);
	let objRender2 = ObjPrim_Create(OBJ_SPRITE_2D);
    if(texture != "NONE"){
    	ObjPrim_SetTexture(objRender, texture);
    	ObjSprite2D_SetSourceRect(objRender, 0, 0, 256, 256);
    	ObjSprite2D_SetDestCenter(objRender);
    	ObjRender_SetScaleXYZ(objRender, growToInit, growToInit, 0);
    	ObjRender_SetBlendType(objRender, BLEND_ADD_ARGB);
    	Obj_SetRenderPriorityI(objRender, 49);
    	ObjRender_SetAngleZ(objRender, ObjMove_GetAngle(objShot));
		if(texture2=="NONE"){ ObjRender_SetColor(objRender, r, g, b); }
    }
	if(texture2 != "NONE"){
		ObjPrim_SetTexture(objRender2, texture2);
		ObjSprite2D_SetSourceRect(objRender2, 0, 0, 256, 256);
		ObjSprite2D_SetDestCenter(objRender2);
		ObjRender_SetColor(objRender2, r, g, b);
		ObjRender_SetScaleXYZ(objRender2, growToInit, growToInit, 0);
		ObjRender_SetBlendType(objRender2, BLEND_ADD_ARGB);
		Obj_SetRenderPriorityI(objRender2, 49);
		ObjRender_SetAngleZ(objRender2, ObjMove_GetAngle(objShot));
	}
	
	Obj_SetValue(objShot,"SunRenderObject",objRender);
	Obj_SetValue(objShot,"GlowRenderObject",objRender2);
	
    renderSunStuff;

    return objShot;

    task renderSunStuff{
    	let z = 0; let alpha1 = Obj_GetValueD(objShot,"Alpha1",255); let alpha2 = Obj_GetValueD(objShot,"Alpha2",64);
    	
		let dScaleSign = 0;
		if(type=="GROW"){
			dScaleSign=1;
		} 
		else if(type=="SHRINK"){
			dScaleSign=-1;
		}
		
		//Render shot
		while(!Obj_IsDeleted(objShot) && !(Obj_IsValueExists(objShot,"Delete") && growToInit>0 ) ){
			if(growToInit < loc_scale){
				growToInit += 0.2;

				if(Obj_GetValueD(objShot,"IsIntersectionEnable",true)){
					ObjShot_SetIntersectionCircleA1(objShot, 91 * growToInit);
				}
				ObjRender_SetScaleXYZ(objRender, growToInit, growToInit, 0);
				ObjRender_SetPosition(objRender, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
				ObjRender_SetAngleZ(objRender, z);

				ObjRender_SetScaleXYZ(objRender2, growToInit, growToInit, 0);
				ObjRender_SetPosition(objRender2, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
				ObjRender_SetAngleZ(objRender2, z);

				ObjRender_SetScaleXYZ(objShot, growToInit, growToInit, 0);
				alpha1 = Obj_GetValueD(objShot,"Alpha1",Obj_GetValueD(objShot,"Alpha",255)); 
				alpha1 = Obj_GetValueD(objShot,"Alpha2",alpha1/4); 
				ObjRender_SetAlpha(objRender,alpha1); ObjRender_SetAlpha(objRender2,alpha2);
				
				z++;
				//yield;   //this makes it look all jittery, not sure why it was here
			}
			if(loc_scale*dScaleSign < endScale*dScaleSign){
				loc_scale += sizePerFrame * dScaleSign;
			}
			if(loc_scale <= 0){
				Obj_Delete(objShot);
				Obj_Delete(objRender);
				Obj_Delete(objRender2);;
			}

			if(Obj_GetValueD(objShot,"IsIntersectionEnable",true)){
				ObjShot_SetIntersectionCircleA1(objShot, 91 * loc_scale);
			}
			ObjRender_SetScaleXYZ(objRender, loc_scale, loc_scale, 0);
			ObjRender_SetPosition(objRender, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
			ObjRender_SetAngleZ(objRender, z);

			ObjRender_SetScaleXYZ(objRender2, loc_scale, loc_scale, 0);
			ObjRender_SetPosition(objRender2, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
			ObjRender_SetAngleZ(objRender2, z);
			
			ObjRender_SetScaleXYZ(objShot, loc_scale, loc_scale, 0);
			alpha1 = Obj_GetValueD(objShot,"Alpha1",Obj_GetValueD(objShot,"Alpha",255)); 
			alpha1 = Obj_GetValueD(objShot,"Alpha2",alpha1/4);
			ObjRender_SetAlpha(objRender,alpha1); ObjRender_SetAlpha(objRender2,alpha2);
			
			z++;
			
			if(x<-1*rad || y<-1*rad || x>sx+rad || y>sy+rad){Obj_Delete(objShot);}
			
			yield;
		}
		
		//Delete shot	
		if(Obj_IsDeleted(objShot)){
			Obj_Delete(objRender);
			Obj_Delete(objRender2);
		}else{
			let type = Obj_GetValue(objShot,"Delete");
			if(type=="Fade" || type=="Expand"){
				let curScale = ObjRender_GetScaleX(objRender);
				let rate = 1+Obj_GetValueD(objShot,"ExpandRate",0.05);
				let time = Obj_GetValueD(objShot,"DeleteTime",60);
				ascent(i in 0..time){
					
					ObjRender_SetAlpha(objRender,alpha1-i*alpha1/time);
					ObjRender_SetAlpha(objRender2,alpha2-i*alpha2/time);
					
					if(type=="Expand"){
						ObjRender_SetScaleXYZ(objRender, curScale*rate, curScale*1.05, 0);
						ObjRender_SetScaleXYZ(objRender2, curScale*rate, curScale*1.05, 0);
						curScale*=rate;
					}
					
					//keep spinning and such
					ObjRender_SetAngleZ(objRender, z);
					ObjRender_SetAngleZ(objRender2, z);
					z++;
					ObjRender_SetPosition(objRender, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
					ObjRender_SetPosition(objRender2, ObjMove_GetX(objShot), ObjMove_GetY(objShot), 0);
					
					yield;
				}
				Obj_Delete(objShot);
				Obj_Delete(objRender);
				Obj_Delete(objRender2);
			}
			else {
				Obj_Delete(objShot);
				Obj_Delete(objRender);
				Obj_Delete(objRender2);
			}
		}
		
    }
}

//Simpler header more consistent with other shot functions
function SunShotA1(x,y,s,a, scl,c,del){
	let path1=dirimg~"Sun.png";
	let path2=dirimg~"Sun2.png";
	let init = 0;
	let end  = scl;
	let per  = (end-init)/del;
	return CreateSunShot(x,y,s,a,"GROW",init,per,end,path2,path1,c[0],c[1],c[2]);
}



//For when you don't want to bother specifying the texture
function CreateSunShotA2(x, y, speed, angle, type, initScale, sizePerFrame, endScale, enableGlow, r, g, b) {
	let path2; if(!enableGlow){path2="NONE";}else{path2=CSD~"../img/Sun2.png";}
	return CreateSunShot(x, y, speed, angle, type, initScale, sizePerFrame, endScale, path2, CSD~"../img/Sun.png", r, g, b);
}
//------------------------------------------------------------
//Utsuho caution cutin.
//Made by AJS
task CautionCutin(render, alpha, yposition, img, rect){
	let rect2=rect; if(length(rect)>4){ rect2 = rect[4..length(rect)]; }
	Tcaution(GetStgFrameWidth/2     , yposition+90, render, alpha, img, rect );
	Tcaution(GetStgFrameWidth/2-250 , yposition+90, render, alpha, img, rect );
	Tcaution(GetStgFrameWidth/2+250 , yposition+90, render, alpha, img, rect );
	
	Tcaution(GetStgFrameWidth/2     , yposition-90, render, alpha, img, rect );
	Tcaution(GetStgFrameWidth/2-250 , yposition-90, render, alpha, img, rect );
	Tcaution(GetStgFrameWidth/2+250 , yposition-90, render, alpha, img, rect );
	
	radiation(GetStgFrameWidth/2    , yposition   , render, alpha, img, rect2 );
	radiation(GetStgFrameWidth/2-250, yposition   , render, alpha, img, rect2 );
	radiation(GetStgFrameWidth/2+250, yposition   , render, alpha, img, rect2 );
	yield;
}

task Tcaution(xpos, ypos, renderpriority, malpha, img, rect){
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let counter = 0;
	let size = 0;
	let alpha = 0;
	
	
	ObjPrim_SetTexture(obj, img);
	if(length(rect)==0){ rect = [0,216,256,256]; }
	ObjSprite2D_SetSourceRect(obj,rect[0], rect[1], rect[2], rect[3]);
	let sclx = 256/(rect[2]-rect[0]);
	let scly =  40/(rect[3]-rect[1]);
	ObjRender_SetScaleXYZ(obj,sclx,scly,0);
	
	Obj_SetRenderPriorityI(obj,renderpriority);
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetBlendType(obj,BLEND_ALPHA);
	ObjRender_SetPosition(obj,xpos,ypos,0);
	ObjRender_SetAngleXYZ(obj,0,0,0);	
	ObjRender_SetAlpha(obj,alpha);
	
	loop(20){		
		counter++;
		alpha+=malpha/20;
		ObjRender_SetAlpha(obj,alpha);
		ObjRender_SetPosition(obj,xpos+(counter),ypos,0);		
		yield;
	}
	loop(120){		
		counter++;
		ObjRender_SetPosition(obj,xpos+(counter),ypos,0);		
		yield;
	}
	loop(20){		
		counter++;
		alpha-=malpha/20;
		ObjRender_SetAlpha(obj,alpha);
		ObjRender_SetPosition(obj,xpos+(counter),ypos,0);		
		yield;
	}
	Obj_Delete(obj);
}
task radiation(xpos, ypos, renderpriority, malpha, img, rect){
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	let counter = 0;
	let size = 0;
	let alpha = 0;
	
	ObjPrim_SetTexture(obj, img);
	if(length(rect)==0){ rect = [0,0,256,128]; }
	ObjSprite2D_SetSourceRect(obj,rect[0], rect[1], rect[2], rect[3]);
	let sclx = 256/(rect[2]-rect[0]);
	let scly = 128/(rect[3]-rect[1]);
	ObjRender_SetScaleXYZ(obj,sclx,scly,0);
	
	Obj_SetRenderPriorityI(obj,renderpriority);
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetBlendType(obj,BLEND_ALPHA);
	ObjRender_SetPosition(obj,xpos,ypos,0);
	ObjRender_SetAngleXYZ(obj,0,0,0);	
	ObjRender_SetAlpha(obj,alpha);
	
	loop(20){		
		counter++;
		alpha+=malpha/20;
		ObjRender_SetAlpha(obj,alpha);
		ObjRender_SetPosition(obj,xpos-(counter),ypos,0);		
		yield;
	}
	loop(120){		
		counter++;
		ObjRender_SetPosition(obj,xpos-(counter),ypos,0);		
		yield;
	}
	loop(20){		
		counter++;
		alpha-=malpha/20;
		ObjRender_SetAlpha(obj,alpha);
		ObjRender_SetPosition(obj,xpos-(counter),ypos,0);		
		yield;
	}
	Obj_Delete(obj);
}
//------------------------------------------------------------




//Create a "box" of lasers sticking out of a circle
//Does NOT move on it's own. Movement needs to be assigned with ObjMove functions
function CreateBoxA1(x, y, dist, ang, dir,dir0, sides, l, w, dt, g, d){
	let boxcontrol = ObjShot_Create(OBJ_SHOT);
	ObjShot_Regist(boxcontrol);
	ObjShot_SetSpellResist(boxcontrol, true);
	ObjShot_SetAutoDelete(boxcontrol,false);

	let boxX = 0;
	let boxY = 0;
	let a = dir0;

	ObjMove_SetPosition(boxcontrol, x, y);

	laserbox;
	return boxcontrol;

	task laserbox{
		loop(sides){
			laser(a);
			a += 360/sides;
		}
		task laser(a2){
			let obj = CreateStraightLaserA1(x, y, a2+ang, l, w, dt, g, d);
			ObjLaser_SetInvalidLength(obj, 0, 0);
			ObjStLaser_SetSource(obj, false);
			ObjShot_SetAutoDelete(obj,false);
			
			Obj_SetValue(boxcontrol,"Lasers",Obj_GetValueD(boxcontrol,"Lasers",[]) ~ [obj]);
			Obj_SetValue(obj,"Controller",boxcontrol);

			while(!Obj_IsDeleted(boxcontrol)){
				boxX = ObjMove_GetX(boxcontrol);
				boxY = ObjMove_GetY(boxcontrol);

				ObjMove_SetPosition(obj, boxX+dist*cos(a2), boxY+dist*sin(a2));
				ObjMove_SetPosition(obj, boxX+dist*cos(a2), boxY+dist*sin(a2));
				ObjStLaser_SetAngle(obj, a2+ang);
				a2 += dir;
				yield;
			}
			ObjShot_FadeDelete(obj);
		}
	}
}

function DelayLaser(x,y,ang,len,wid,dur,graph){
	let las = CreateStraightLaserA1(x,y,ang,len,wid,dur,graph,dur+10);
	ObjStLaser_SetSource(las,false);
	return las;
}
function DelayLaserBetween(x0,y0,x1,y1,wid,dur,graph){
	let ang = getangle(x0,y0,x1,y1); 
	let len = getdist (x0,y0,x1,y1);
	let las = CreateStraightLaserA1(x0,y0,ang,len,wid,dur,graph,dur+10);
	ObjStLaser_SetSource(las,false);
	return las;
}

// function DelayLaser(x, y, ang, l, w, dt, graph, delay){
	// let objlaser = CreateStraightLaserA1(x, y, ang, l, w, dt, graph, delay);
	// TDelayLaser; 
	// return objlaser;
	// task TDelayLaser{
		// wait(delay-1);//So that the graphic never enlarges. 
		// Obj_Delete(objlaser);
	// }
// }

//from Akakyu's Suika
task Mist(x,y,dur){
	let angle = 0;
	let angleR = rand(-2, 2);	
	let up = 1;
	let alpha = 40;
	
	let fog = ObjPrim_Create(OBJ_SPRITE_2D);
	let mist = dirimg~"mist.png";
	ObjPrim_SetTexture(fog, mist);
	ObjSprite2D_SetSourceRect(fog, 0, 0, 128, 128);
	ObjSprite2D_SetDestCenter(fog);
	ObjRender_SetPosition(fog, x, y, 0);
	ObjRender_SetBlendType(fog, BLEND_ADD_ARGB);
	ObjRender_SetScaleXYZ(fog, 1, 1, 0);
	
	loop(dur){
		ObjRender_SetScaleXYZ(fog, up, up, 0);
		ObjRender_SetAlpha(fog, alpha);
		ObjRender_SetAngleZ(fog, angle);
		angle += angleR;
		up -= 0.015;
		alpha -= 40/60;
		yield;
	}
	Obj_Delete(fog);
}


//From Akakyu's Suika
//num = num sides, bside = bullets per side
function ShootShape(spawnX, spawnY, v, angle, num, bside, graphic, delay) {
	let shots = [];
	ascent(i in 0..num) {
		let sx = spawnX+cos(angle+i*360/num);
		let sy = spawnY+sin(angle+i*360/num);
		let sxN = spawnX+cos(angle+(i+1)*360/num);
		let syN = spawnY+sin(angle+(i+1)*360/num);
		shots = shots ~ [CreateShotA1(spawnX, spawnY, v*(((sx-spawnX)^2+(sy-spawnY)^2)^0.5), atan2(sy-spawnY,sx-spawnX), graphic, delay)];
		ascent(j in 0..bside) {
			let toAngle = atan2(syN-sy,sxN-sx);
			let toDist = (((sxN-sx)^2+(syN-sy)^2)^0.5);
			let sx2 = sx+toDist/bside*j*cos(toAngle);
			let sy2 = sy+toDist/bside*j*sin(toAngle);
			shots = shots ~ [ CreateShotA1(spawnX, spawnY, v*(((sx2-spawnX)^2+(sy2-spawnY)^2)^0.5), atan2(sy2-spawnY,sx2-spawnX), graphic, delay) ];
		}
	}
	return shots;
} 

//Get a collection of points forming a shape
//Returns an array with x,y,dist,ang for each point; use i*4+0 for start of each point
function GetShape(x, y, rad, angle, num, bside) {
	let vectors = [];
	ascent(i in 0..num) {
		let sx = x+cos(angle+i*360/num);
		let sy = y+sin(angle+i*360/num);
		let sxN = x+cos(angle+(i+1)*360/num);
		let syN = y+sin(angle+(i+1)*360/num);
		ascent(j in 0..bside) {
			let toAngle = atan2(syN-sy,sxN-sx);
			let toDist = (((sxN-sx)^2+(syN-sy)^2)^0.5);
			let dx = toDist/bside*j*cos(toAngle);
			let dy = toDist/bside*j*sin(toAngle);
			let sx2 = sx+dx;
			let sy2 = sy+dy;
		
			//vectors = vectors ~ [sx2,sy2,toDist,toAngle];
			let ang = atan2(sy2-y,sx2-x);
			vectors = vectors ~ [ sx+dx*rad,  sy+dy*rad,  ((sx2-x)^2+(sy2-y)^2)^0.5, ang ];
		}
	}
	return vectors;
}

//based on formula for equation of an n-gon in polar coordinates
//works going out, but can't get the hang of extending it to spawn at bigger radius
function GetShape2(cx,cy,rad,ang0,sides,pps) {
	let points = []; let tmp = [0,0];
	let ang; let dist; let x; let y;
	let dA = 360/sides/pps;
	ascent(i in 0..sides) {
		ascent(j in 0..pps) {
			ang  = (ang0+dA*pps*i+dA*j)%360;
			dist = cos(180/sides)/cos(ang-360/sides*floor((sides*ang+180)/360));
			x = dist*cos(ang);
			y = dist*sin(ang);
			tmp = rotate(x,y,ang0);
			x=tmp[0];y=tmp[1];
			points = points ~ [x,y,dist,ang+ang0];
		}
	}
	return points;
}





//Drake - Fire wedge of bullets, like Seiran
// let wedge = CreateShotWedgeA1(192, 150, 5, 10, 3, 45, SHOT_RICE_RED, 6, 6);
function CreateShotWedgeA1(x, y, rows, gap, speed, angle, graphic, row_delay, shot_delay){
	let a = [];
	ascent(i in 0..rows){
		ascent(j in 0..(i+1)){
			let shot = ObjShot_Create(OBJ_SHOT);
			ObjMove_SetPosition(shot, x + (j*gap - (i*gap)/2) * cos(angle+90), y + (j*gap - (i*gap)/2) * sin(angle+90));
			ObjMove_SetSpeed(shot, speed);
			ObjMove_SetAngle(shot, angle);
			ObjShot_SetGraphic(shot, graphic);
			ObjShot_SetDelay(shot, shot_delay);

			task run(shot){
				loop(i*row_delay){yield;}
				if(!Obj_IsDeleted(shot)){
					ObjShot_Regist(shot);
				}
			}
			
			run(shot);
			a = a ~ [shot];
		}
	}
	return a;
}









function SquareLaser(x0,y0,x1,y1, del,dur,color, numwarn) {
	let las = CreateStraightLaserA1((x1+x0)/2,y0,90,absolute(x1-x0),y1-y0, dur,  1001, del);
	ObjStLaser_SetSource(las,false);
	ObjRender_SetColor(las,color[0],color[1],color[2]);
	Obj_SetVisible(las,false);
	TDelVis;
	
	let N = numwarn; let M = numwarn;
	let dx = (x1-x0)/(N-1);   let dy = (y1-y0)/(M-1);
	
	//let gap = 10;
	//let dx = x1-x0;  let N = ceil((x1-x0)/gap);
	//let dy = y1-y0;  let M = ceil((y1-y0)/gap);  
	
	let warn; let warnshots = [];
	ascent(i in 0..N){
		warn = CreateStraightLaserA1(x0+dx*i,y0,90,absolute(x1-x0),y1-y0, del-1,  1001, del);
		ObjStLaser_SetSource(warn,false);
		ObjRender_SetColor(warn,color[0],color[1],color[2]);
		ObjShot_SetDeleteFrame(warn,del);
		warnshots = warnshots ~ [warn];
	}
	ascent(i in 0..M){
		warn = CreateStraightLaserA1(x0,y0+dy*i,0,x1-x0,absolute(y1-y0), del-1,  1001, del);
		ObjStLaser_SetSource(warn,false);
		ObjRender_SetColor(warn,color[0],color[1],color[2]);
		ObjShot_SetDeleteFrame(warn,del);
		warnshots = warnshots ~ [warn];
	}
	
	task TDelVis {
		wait(del);
		Obj_SetVisible(las,true);
		loop(length(warnshots)){Obj_Delete(warnshots[0]); warnshots=erase(warnshots,0);}
	}
	
	return las;
}


function TFeathers() {
	let controller = CreateDummyShot(0,0);
	TFeathersA1(0.225,0.275,0.75,1.5,0.5,200,15,controller);
}
task TFeathersA1(minscl,maxscl,minspd,maxspd,maxdriftspd,alpha1,del, controller) {
	Obj_SetValue(controller,"Feathers",[]);
	let feather;
	let feathers = [];
	while(!Obj_IsDeleted(controller)){
		feather = CreateFeather(rand(0,sx), rand(-60,60), rand(-maxdriftspd,maxdriftspd), rand(minspd,maxspd), rand(minscl,maxscl), alpha1);
		Obj_SetValue(feather,"id",length(Obj_GetValue(controller,"Feathers")));
		Obj_SetValue(feather,"Controller",controller);
		feathers = Obj_GetValue(controller,"Feathers");
		Obj_SetValue(controller,"Feathers", feathers ~ [feather]);
		loop(del){yield;}
	}
	
	if(!Obj_IsDeleted(boss)){
		ascent(i in 0..length(feathers)) {
			Obj_SetValue(feathers[i],"FadeTime",30);
			Obj_FadeDelete(feathers[i]);
		}
	}else{
		ascent(i in 0..length(feathers)) {
			Obj_Delete(feathers[i]);
		}
	}
}
function CreateFeather(x0,y0,dx,dy,scale,alpha1) {
	let feather = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(feather,CSD~"../img/Effect/feather.png");
	ObjSprite2D_SetSourceRect(feather, 32,32,224,224);
	ObjSprite2D_SetDestCenter(feather);
	
	ObjRender_SetBlendType(feather,BLEND_ADD_RGB);
	Obj_SetRenderPriority(feather,0.29);
	ObjRender_SetScaleXYZ(feather,scale,scale,1);
	
	let alpha=0;
	let x=x0; let y=y0;
	
	let angX = 0; let angY = 0; let angZ = rand(0,360);
	let spinX = rand(-1,1); let spinY = rand(-1,1); let spinZ = rand(-1,1);
	
	TFeather;
	return feather;
	
	task TFeather{
		while(y<448) {
			if(alpha<alpha1){alpha+=3;}
			ObjRender_SetColor(feather,alpha,alpha,alpha);
			Obj_SetValue(feather,"Color",[alpha,alpha,alpha]);
			
			x+=dx; y+=dy;
			ObjRender_SetPosition(feather,x,y,0);
			
			angX+=spinX; angY+=spinY; angZ+=spinZ;
			ObjRender_SetAngleXYZ(feather,angX,angY,angZ);
			
			yield;
		}
		while(alpha>0){
			alpha-=3;
			ObjRender_SetColor(feather,alpha,alpha,alpha);
			Obj_SetValue(feather,"Color",[alpha,alpha,alpha]);
			yield;
		}
		if(Obj_IsValueExists(feather,"Controller") && length(Obj_GetValueD(Obj_IsValueExists(feather,"Controller"),"Feathers",[]))>0) {
			let controller = Obj_GetValue(feather,"Controller");
			Obj_SetValue(controller,"Feathers",erase(Obj_GetValueD(controller,"Feathers",[0]),Obj_GetValueD(feather,"id",0)));
		}
		Obj_Delete(feather);
	}
}









task SetFullScreen(enable,time){
	if(GetCommonData("Fullscreen",false) == enable){ return; }
	SetCommonData("Fullscreen",enable);
	
	let L;  let T;  let R;  let B;
	let L1; let T1; let R1; let B1;
	let pMin; let pMax;

	L = 0+GetStgFrameLeft;   T = 0+GetStgFrameTop;
	R = L+GetStgFrameWidth;  B = T+GetStgFrameHeight;
	pMin = GetStgFrameRenderPriorityMinI; pMax = GetStgFrameRenderPriorityMaxI;
	
	if(enable){
		SetCommonData("StageFrame",[L,T,R,B,pMin,pMax]);
		L1 = 0; T1 = 0; R1 = GetScreenWidth; B1 = GetScreenHeight;
	}else{
		let a = GetCommonData("StageFrame",[32,16,416,464,20,80]);
		L1=a[0]; T1=a[1]; R1=a[2]; B1=a[3]; pMin=a[4]; pMax=a[5];
	}
	
	//distance of player clip from each edge
	let clip = GetPlayerClip();
	let oL=clip[0]-L; let oT=clip[1]-T; let oR=clip[2]-R; let oB=clip[3]-B;
	
	if(time > 0){
		let dL = (L1-L);   let dT = (T1-T);   let dR = (R1-R);   let dB = (B1-B);
		ascent(i in 0..time){
			let t = i/time;
			SetStgFrame(L+dL*t, T+dT*t, R+dR*t, B+dB*t, pMin,pMax);
			SetPlayerClip(L+dL*t+oL, T+dT*t+oT, R+dR*t+oR, B+dB*t+oB);
			let p_px = GetPlayerX/sx; let p_py = GetPlayerY/sy;
			sx = R+dR*t - L+dL*t;   cx = sx/2; 
			sy = B+dB*t - T+dT*t;   cy = sy/2;
			if(GetShotCount(TARGET_ENEMY)==0){
				ObjRender_SetPosition(GetPlayerObjectID,p_px*sx,p_py*sy,0);
			}
			yield;
		}
	}
	SetStgFrame(L1,T1,R1,B1,pMin,pMax);
	SetPlayerClip(L1+oL,T1+oT,R1+oR,B1+oB);
	sx = R1-L1;   cx = sx/2;
	sy = B1-T1;   cy = sy/2;
}

//if at end of script
task SetFullScreen_Notify(enable,time){
	Notify(SCRIPT_SYSTEM,EV_SET_FULLSCREEN,[ToString(enable),ToString(time)]);
}






// task widescreen{
	// let left = 32;
	// let top = 16;
	// let right = 416;
	// let bottom = 464;
	
	// loop{
		// if(left>0){left-=0.51;}
		// if(top>0){top-=0.25;}
		// if(right<GetScreenWidth){right+=4;}
		// if(bottom<GetScreenHeight){bottom+=0.26;}
		// SetStgFrame(left,top,right,bottom,20,80);
		// SetPlayerClip(left,top,right,bottom);
		
		// yield;
	// }
// }



// function DeleteEnemyAll {
	// let enemies = GetAllEnemyID;
	// ascent(i in 0..length(enemies)) {
		// if(enemies[i]!=boss){TDelete(enemies[i]);}
	// }
	
	// task TDelete(fam) {
		// let a0 = Obj_GetValueD(fam,"Alpha",255);
		// ascent(i in 0..60){
			// ObjRender_SetAlpha(fam,a0-(a0/60)*i);
		// }
		// Obj_Delete(fam);
	// }
// }


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//BELOW THIS LINE: 
//ASSORTED BULLSHIT I HAVEN'T REALLY MESSED WITH YET
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////




// function StageStart(img){ //It's a function so that it stops the script while it's executed
	// let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	// ObjPrim_SetTexture(obj, img);
	// ObjSprite2D_SetSourceRect(obj, 0, 0, 256, 96);
	// ObjSprite2D_SetDestCenter(obj);
	// Obj_SetRenderPriority(obj, 0.79);

	// ObjRender_SetPosition(obj, GetStgFrameWidth/2, GetStgFrameHeight/2, 0);
	// wait(60);
	// ObjPrim_SetTexture(obj, GetCurrentScriptDirectory ~ "./../IMG/go.png");
	// ObjSprite2D_SetSourceRect(obj, 0, 0, 128, 128);
	// ObjSprite2D_SetDestCenter(obj);
	// wait(60);
	// Obj_Delete(obj);
// }
// function StageClear{ //It's a function so that it stops the script while it's executed
	// let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	// ObjPrim_SetTexture(obj, GetCurrentScriptDirectory ~ "./../IMG/clear.png");
	// ObjSprite2D_SetSourceRect(obj, 0, 0, 256, 64);
	// ObjSprite2D_SetDestCenter(obj);
	// Obj_SetRenderPriority(obj, 0.79);

	// ObjRender_SetPosition(obj, GetStgFrameWidth/2, GetStgFrameHeight/2, 0);
	// ObjRender_SetAlpha(obj, 0);
	// let alpha = 0;
	// while(alpha < 255){
		// ObjRender_SetAlpha(obj, alpha);
		// alpha += 5;
		// yield;
	// }
	// wait(60);
	// while(alpha > 0){
		// ObjRender_SetAlpha(obj, alpha);
		// alpha -= 5;
		// yield;
	// }
	// wait(10);
	// Obj_Delete(obj);
// }
// function SetStaticBackground(img, r1, r2, r3, r4, s){
	// let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	// ObjPrim_SetTexture(obj, img);
	// ObjSprite2D_SetSourceRect(obj, r1, r2, r3, r4);
	// ObjSprite2D_SetDestCenter(obj);
	// Obj_SetRenderPriority(obj, 0.2);
	// ObjRender_SetPosition(obj, GetStgFrameWidth/2, GetStgFrameHeight/2, 0);
	// ObjRender_SetScaleXYZ(obj, s, s, s);
// }
// task FadeToBlack(i){
	// let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	// ObjPrim_SetTexture(obj, GetCurrentScriptDirectory ~ "./../IMG/black.png");
	// ObjSprite2D_SetSourceRect(obj, 0, 0, 100, 100);
	// ObjSprite2D_SetDestCenter(obj);
	// Obj_SetRenderPriority(obj, 1.0);
	// ObjRender_SetAlpha(obj, 0);

	// ObjRender_SetPosition(obj, GetCenterX, GetCenterY, 0);
	// ObjRender_SetScaleXYZ(obj, 8, 8, 0);
	// let a = 0;
	// while(a < 255){
		// ObjRender_SetAlpha(obj, a);
		// a += 2;
		// yield;
	// }
	// wait(i);
	// Obj_Delete(obj);
// }




// //modified from TalosMistake's Yuyuko script
// function CallFan(type,expand) {
	// let obj=ObjPrim_Create(OBJ_SPRITE_2D);
	// let img;
	// let count = 0;
	// img = CSD~"../img/ougi.png";
	// LoadTexture(img);
	// ObjPrim_SetTexture(obj,img);
	// ObjSprite2D_SetSourceRect(obj, 0, 0, 512, 256+32);
	// ObjSprite2D_SetDestCenter(obj);
	// ObjRender_SetBlendType(obj,BLEND_ADD_ARGB);
	// Obj_SetRenderPriorityI(obj,22);
	// SetScale;
	
	// let typenum=0;
	// if(type=="Bright"){typenum=1;}else if(type=="Player"){typenum=2;}
	
	// TFan;
	// return obj;
	
	// task TFan {
		// while(!Obj_IsDeleted(obj)){
			// alternative(typenum)
			// case(0) {
				// ObjRender_SetPosition(obj,ex-32-8,ey,0);
				// ObjRender_SetColor(obj,128,128,128);
			// }
			// case(1) {
				// ObjRender_SetPosition(obj,ex-32-8,ey,0);
				// ObjRender_SetColor(obj,255,255,255);
			// }
			// case(2) {
				// ObjRender_SetPosition(obj,GetPlayerX-32-8,GetPlayerY,0);
				// ObjRender_SetColor(obj,128,128,128);
			// }
			
			// count++;
			// if(count>120 && GetCommonData("IsFan",false)==false){
				// Obj_Delete(obj);
			// }
			// yield;
		// }
	// }
	
	// task SetScale {
		// if(expand==1){
			// ascent(i in 0..45){
				// ObjRender_SetScaleXYZ(obj,1,0.1*sin(i*2),1);
				// yield;
			// }
			// ascent(i in 0..45){
				// ObjRender_SetScaleXYZ(obj,1,0.1+0.9*sin(i*2),1);
				// yield;
			// }
			// SetCommonData("IsFan",true);
		// }
		// else if(expand==0){
			// ObjRender_SetScaleXYZ(obj,1,1,1);
			// SetCommonData("IsFan",true);
		// }
		// else if(expand==-1){
			// SetCommonData("IsFan",false);
			// ObjRender_SetScaleXYZ(obj,0,0,0);
			// yield;
			// descent(i in 0..45) {
				// ObjRender_SetScaleXYZ(obj,1,sin(i*2),1);
				// yield;
			// }
			// Obj_Delete(obj);
		// }
		// else if(expand==-2){
			// Obj_Delete(obj);
		// }
	// }
// }





///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//BELOW THIS LINE: 
//ASSORTED BULLSHIT THAT JUST PLAIN SUCKS/DOESN'T WORK
//I DON'T KNOW WHY I STILL KEEP ANY OF THIS AROUND
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

// //Move all shots within a circle the specified number of degrees around the center
// //Changes only position, not angle
// //Freezes bullets during delay - speed is preserved afterwards, but not acceleration or angular velocity, because there are no getters for those
// task rotateShots(cx,cy,radius,degrees,delay) {
	// let shots = GetShotIdInCircleA2(cx,cy,radius,TARGET_ENEMY);
	// let speeds = [];
	// ascent(i in 0..length(shots)) {
		// let shot = shots[i];
		// speeds = speeds ~ [ ObjMove_GetSpeed(shot) ];
		// ObjMove_SetSpeed(shot,0);
		// ObjMove_SetAcceleration(shot,0); ObjMove_SetAngularVelocity(shot,0);
	// //	ObjRender_SetColor(shot,150,150,150);
		
		// let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot); let ang = ObjMove_GetAngle(shot);
		// let a = angleBetween(cx,cy,x,y) + degrees;
		// let dist = Distance(cx,cy,x,y);
		// let tx = cx+dist*cos(a); let ty = cy+dist*sin(a);
		// let type = ObjShot_GetImageID(shot);
		// WarnShotA1(x,y,-1,0);
		// WarnShotA2(tx,ty,type,ang,[255,255,255],10,delay);
	// }
	// wait(delay);
	// ascent(i in 0..length(shots)) {
		// let shot = shots[i];
		// let x = ObjMove_GetX(shot); let y = ObjMove_GetY(shot); 
		// let a = angleBetween(cx,cy,x,y) + degrees;
		// let dist = Distance(cx,cy,x,y);
		// let tx = cx+dist*cos(a); let ty = cy+dist*sin(a);
		// ObjMove_SetPosition(shot, tx, ty);
		// ObjMove_SetSpeed(shot,speeds[i]);
	// //	ObjRender_SetColor(shot,255,255,255);
		// WarnShotA1(tx,ty,-1,0);
	// }
// }



// let ward = true;
// task BulletWard(ward,rad,c) {
	// let seobj = ObjSound_Create;
	// let r=c[0]; let g=c[1]; let b=c[2];
	
	// let shots; let shot; let arc;
	// let x; let y;
	// let wx; let wy;
	// let arcDir;
	
	// let spd0; let ang0;
	
	// while(!Obj_IsDeleted(ward)) {
		// if(ward) {
			// wx = ObjMove_GetX(ward); wy = ObjMove_GetY(ward);
			// shots = GetShotIdInCircleA2(wx,wy,rad,TARGET_PLAYER);
			// ascent(i in 0..length(shots)) {
				// shot = shots[i];
				// y = ObjMove_GetY(shot);
				// if(y > wy) {
					// x = ObjMove_GetX(shot);
					// if(x>wx){arcDir=1;}else{arcDir=-1;}
					// arc = bulletArc(x, y, x, wy-(y-wy), 20, randSign(), arcDir, 533, 55, [r,g,b], 0,10, 1); //533
					// ObjMove_SetY(shot,wy-(y-wy));
					
					// spd0 = ObjMove_GetSpeed(shot);
					// ang0 = ObjMove_GetAngle(shot);
					
					// ObjMove_AddPatternA2(shot,0,0,NO_CHANGE,0.1,0,spd0);
					// SE_PlayA2(nodamage,50,seobj,10);
					
					// //shot = CreateShotA2(x,y,0,ang0+180, 0.1,spd0, 709, 0);
					// //shot = CreateShotA1(x,y,spd0,ang0+180, 709, 0);
				// }
			// }
		// }
		// yield;
	// }
// }


// //supposed to make bullets kind of drift towards player
// //shitty and doesn't work very well, use TurnToPoint instead
// task BearDown(shot,mangv,arc,angScale){
	// let aShot; let aPlayer; let dir;
	// let angvscl;
	// while(!Obj_IsDeleted(shot)){
		// aShot = GetAngleTo(boss, shot);
		// aPlayer = GetAngleTo(boss, GetPlayerObjectID);
		// dir = sign(GetArcAngle(aShot,aPlayer));
		// angvscl = 1 + angScale*absolute(GetArcAngle(aShot,aPlayer) )/arc;
		// //if( absolute(ObjMove_GetAngle(shot)-aShot) > arc ) { ObjMove_SetAngularVelocity(shot,0); }
		// if( absolute(GetArcAngle(ObjMove_GetAngle(shot),aShot)) > arc) { ObjMove_SetAngularVelocity(shot,0); }
		// else{ ObjMove_SetAngularVelocity(shot,mangv*dir*angvscl); }
		// yield;
	// }
// }





// //returns the SMALLER angle instead of deciding to fuck up across random lines
// //use GetAngularDistance instead
// function GetArcAngle(ang0,ang1) {
	// //return tern(absolute(ang0-ang1)<absolute(ang1-ang0), ang0-ang1, ang1-ang0);
	// // difference between 'dir' and 'angle'
	// let diff = ang0 - ang1;
	// while(diff >= 180) { diff -= 360; }    // adjust the range
	// while(diff < -180) { diff += 360; }
	// return diff;
// }



// //experimental, doesn't work all that well
// function ShapedLaser(verticesIn,del,dur, color) {
	// //Dummy bullet to attach hitboxes to
	// let dummy = CreateDummyShot(0,0);
	// let countVertex = length(verticesIn);
	// let vert; //temp to hold a vertex, nothing to do with leanbox
	
	// let objRender = ObjPrim_Create(OBJ_PRIMITIVE_2D);
	// ObjPrim_SetPrimitiveType(objRender,PRIMITIVE_TRIANGLESTRIP);
	// ObjPrim_SetTexture(objRender,CSD~"../img/white.png");
	// ObjRender_SetBlendType(objRender,BLEND_ADD_ARGB);
	// ObjRender_SetColor(objRender, color[0], color[1], color[2]);
	// if(length(color)>3){ObjRender_SetAlpha(objRender, color[3]);}
	
	// ObjPrim_SetVertexCount(objRender,countVertex);
	// ascent(i in 0..countVertex) {
		// vert = verticesIn[i];
		// ObjPrim_SetVertexUV(objRender, i, i%2, i%2);
		// ObjPrim_SetVertexPosition(objRender,i,vert[0],vert[1],0);
	// }
	
	// TShapedLaser;
	// Obj_SetValue(objRender,"HitboxDummy",dummy); //in case you want it for something
	// return objRender;
	
	// task TShapedLaser {
		// while(!Obj_IsDeleted(objRender)) {
			// if(IsTouchPolyEdges(GetPlayerObjectID,verticesIn,countVertex)){ // || IsIntersected_Obj_Polygon(GetPlayerObjectID,verticesIn,countVertex,objRender)) {
				// ObjShot_SetIntersectionCircleA2(dummy,px,py,15);
// SE_Play(nyaa,100);
			// }
			// yield;
		// }
		// Obj_Delete(dummy);
	// }
	
// }

// function IsTouchPolyEdges(obj,vertices,countVertex) {
	// let vert1; let vert2;
	// ascent(i in 0..countVertex-1){
		// vert1 = vertices[i]; vert2 = vertices[i+1];
		// if(CrossLineA3(px,py, vert1[0],vert1[1],vert2[0],vert2[1], 3	)){
			// return true;
		// }
	// }
	// return false;
// }


// function IsIntersected_Obj_Polygon(obj,vertices,countVertex,dummy) {
	// let x = ObjMove_GetX(obj); 
	// let y = ObjMove_GetY(obj);
// //	let countVertex = length(vertices); //I don't understand why this throws an exception 
	// let vert; let vert2;
	
	// //First check if it's outside if we treat it as a rectangle
	// let xmax = 0; let xmin = sy; let ymax = 0; let ymin = sy;
	// //Check if we found the bounding rectangle for this polygon already
	// //I recommend just passing in the polygon's render object or something for simplicity
	// if(!Obj_IsDeleted(dummy) && Obj_IsValueExists(dummy,"Bounds")) {
		// let bounds = Obj_GetValue(dummy,"Bounds");
		// xmin=bounds[0]; ymin=bounds[1]; xmax=bounds[2]; ymax=bounds[3];
	// }
	// //Otherwise loop through and find them
	// else {
		// ascent(i in 0..countVertex){
			// vert = vertices[i];
			// if(vert[0]>xmax){xmax=vert[0];}
			// if(vert[0]<xmin){xmin=vert[0];}
			// if(vert[1]>ymax){ymax=vert[1];}
			// if(vert[1]<ymin){ymin=vert[1];}
		// }
	// }
	// //If we somehow wound up with stupid bounds, recheck them
	// if(xmin>xmax || ymin>ymax) {
	// //	WriteLog("~~~~~~~Bounding rectangle is stupid " ~ IntToString(xmin) ~ ",  " ~ IntToString(ymin) ~ ",  " ~ IntToString(xmax) ~ ",  " ~ IntToString(ymax));
		// xmax=0;xmin=sy;ymax=0;ymin=sy;
		// ascent(i in 0..countVertex){vert = vertices[i];if(vert[0]>xmax){xmax=vert[0];}if(vert[0]<xmin){xmin=vert[0];}if(vert[1]>ymax){ymax=vert[1];}if(vert[1]<xmin){ymin=vert[1];}}
	// //	WriteLog("~~~~~~~Rechecked bounding rectangle " ~ IntToString(xmin) ~ ",  " ~ IntToString(ymin) ~ ",  " ~ IntToString(xmax) ~ ",  " ~ IntToString(ymax));
	// }
	// //Save them for next time
	// Obj_SetValue(dummy,"Bounds",[xmin,ymin,xmax,ymax]);
	
	// //Now do the check
	// //If it's not in that rectangle, it can't be in the polygon
	// if(x<xmin || x>xmax || y<ymin || y>ymax){
	// //	WriteLog("~~~~~~~Not in bounding rectangle " ~ IntToString(xmin) ~ ",  " ~ IntToString(ymin) ~ ",  " ~ IntToString(xmax) ~ ",  " ~ IntToString(ymax) ~ "        " ~ IntToString(px) ~ ",  " ~ IntToString(py) );
		// return false;
	// }
	
	// //Alright, the point is inside the bounding rectangle, now we get serious.
	// //It's time for some RAY CASTING which as it turns out is actually pretty simple.
	// //We're gonna trace a line through the point and see how many edges it crosses.
	// //If it hits an odd number of edges, it's inside. Even, it's outside.
	// let intersections = 0;
	// vert=vertices[0]; let length; let side;
	// ascent(i in 0..countVertex-1) {
		// vert2=vertices[i+1];
		// //Here's where we check if they intersect
		// if(IsIntersected_Line_Line(-10,-10,x,y,     vert[0],vert[1],vert2[0],vert2[1])) {
			// intersections++;
			// WriteLog("~~~~~~~Found intersection, current count " ~ IntToString(intersections) ~ "  (" ~ ToString(intersections%2==1) ~ ")" );
		// }
		// vert=vert2; //reuse i+1 as the next i so we don't have to get it from the array again
	// }
	
	// //The moment of truth
	// if(intersections%2==0){	return false;	}
	// else{					return true;	}
// }



// //Use rotation matrix to rotate around the x, y, and z axes
// //Doesn't really work yet
// function rotate3D(x,y,z, ox,oy,oz, angx,angy,angz) {
	// let temp;
	// x-=ox; y-=oy; z-=oz;
	
	// //rotate around x axis
	// if(angx!=0){
		// temp=y;
		// //x=x;
		// y=y*cos(angx)-z*sin(angx);
		// z=temp*sin(angx)+z*cos(angx);
	// }
	// //rotate around y axis
	// if(angy!=0){
		// temp=x;
		// x=x*cos(angy)+z*sin(angy);
		// //y=y;
		// z=-temp*sin(angy)+z*cos(angy);
	// }
	// //rotate around z axis
	// if(angz!=0){
		// temp=x;
		// x=x*cos(angz)-y*sin(angz);
		// y=temp*sin(angz)-y*cos(angz);
		// //z=z;
	// }
	
	// return [ox+x,oy+y,oz+z];
	
	
// }	


// //adapted from TalosMistake
// function GetSpherePoint(lat,lon,rad){
	// let x=rad*sin(lat)*cos(lon);
	// let y=rad*sin(lat)*sin(lon);
	// let z=rad*cos(lat);
	// return [x,y,z];
// }








// function GetEllipsePoint(x,y,angle1,angle2,radius1,width){
	// let ex = x + ( radius1 * ( width * cos(angle1) * cos(angle2) - 2 * sin(angle1) * sin(angle2)) );
	// let ey = y + ( radius1 * ( width * cos(angle1) * sin(angle2) + 2 * sin(angle1) * cos(angle2)) );	
	// return [ex,ey]
// }

// function GetStar(cx,cy,pts,rad,N,a0){
	// let arr=[]; let subarr; let pos; let parts = 1;
	// let type = 2-pts%2;
	// while(pts%2==0 && pts>2){
		// if(pts%3==0){type=1;}
		// if(pts==3 || pts==5){ type=1; break; }
		// else if(pts==4){type=2;break;}
		// else { pts/=2; parts++; }
	// }
	// let istri = (pts%3==0); //triangles are weird for no reason
	// let dA;
	// alternative(type)
		// case(1){dA = 360/pts * 2;}
		// case(2){dA = 90 *pts/4;}
	// let x0; let y0; let x1; let y1; let a1; let ang;
	// loop(parts){
		// ascent(i in 0..pts){
			// subarr=[];
			// a1 = a0 + dA;
			// x0 = cx + rad*cos(a0); y0 = cy + rad*sin(a0);
			// x1 = cx + rad*cos(a1); y1 = cy + rad*sin(a1);
			// ascent(j in 0..N){
				// alternative(istri)
				// case(false){ang=lerp(a0,a1,j/N);}
				// case(true ){ang=getangle(cx,cy,lerp(x0,x1,j/N),lerp(y0,y1,j/N));}
				// pos = [lerp(x0,x1,j/N),lerp(y0,y1,j/N),ang];
				// subarr = subarr ~ [pos];
			// }
			// arr = arr ~ [subarr];
			// a0 = a1;
		// }
		// alternative(type)
			// case(1){a0 += dA/(2*parts); }
			// case(2){a0 += 45*pts/4; }
	// }
	// return arr;
// }


// function spiral(cx,cy,a0,rt,t){
	// //let rt = a*t;
	// let x = rt*cos(a0+t);
	// let	y = rt*sin(a0+t);
	// return [x+cx,y+cy];
// }

// function offsetpoint(point,s,a){
	// return [point[0]+s*cos(a),point[1]+s*sin(a)];
// }








function CreateSprite2 ( let texture, let priorityInt, let rects, let center ) {
	// rects = 1-dimensional, size 4
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(obj, texture);
	Obj_SetRenderPriorityI(obj, priorityInt);
	ObjSprite2D_SetSourceRect(obj, rects[0], rects[1], rects[2], rects[3]);
	ObjSprite2D_SetDestRect(obj, -center[0], -center[1], rects[2]-rects[0]-center[0], rects[3]-rects[1]-center[1]);
	return obj;
}
