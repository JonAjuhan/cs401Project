
let dirCurrent = GetCurrentScriptDirectory();
#include "./../Index.txt"
// #include "./../Library/selibrary.txt"
// #include "./../Library/MiscConstants.txt"
// #include "./../Library/Resources.txt"
// #include "./../Library/ExtendedDNF.txt"
// #include "./../Library/EventList.txt"
// #include "./../Library/DirPaths.txt"
// #include "./../Library/Difficulty.txt"
// #include "./ItemConst.txt"
#include "./../Library/LoadEverything.txt"
// #include "./../Library/Music.txt"

@Loading{
	LoadEverything();
}

@Initialize{
	SetScriptID(SCRIPT_SYSTEM);
	
	SetPauseScriptPath(dirCurrent~"Pause.txt");
	SetEndSceneScriptPath(dirCurrent~"EndScene.txt");
	SetReplaySaveSceneScriptPath(dirCurrent~"Default_ReplaySaveScene.dnh");
	
	if(noPackage && IsCloseScript(GetScriptID(SCRIPT_MUSIC)) ){
		let path = dirlib~"Music.txt";
		StartScript(LoadScriptInThread(path));
	}
	
	StartItemScript(dirCurrent~"Item.txt");
	StartShotScript(dirCurrent~"ShotScript.dnh");
	
	InstallFonts();
	GetConfig();
	LoadScript(dirCurrent~"Pause.txt");
	// StartScript(LoadScriptInThread(dirlib~"LoadEverything.dnh"));
	
	
	//Set up frame/UI
	InitFrame();
	TScore();
	TPlayerLife();	
	TPlayerSpell();	
	TPlayerPower();
	TGraze();
	TPointValue();
	
	//Other UI
	TBossLife();
	TBossTimer();
	TCurrentFps();
	TReplayFps();
	TEnemyMarker();
	TTimerTick();
	
	//
	
	if(noPackage){SetDifficultyD(DEFAULT_DIFFICULTY);}
	DifficultyDisplay;
	
	TProjection;
	
	//Screenshot manager
	TScreenshot;
	
	//Debug
	// SetCommonData("CheatEnable",true);
	// SetAreaCommonData("CONFIG","CheatEnable",true);
	// SetCommonData("CheatEnable",noPackage);
	PlaytestInvincibility;
	TDrawHitboxes;
	TDebugText;
	TMiscCheatKeys;
	TDPS;
}

@MainLoop{
	yield;
}

@Event{
	alternative(GetEventType())
	case(EV_START_BOSS_SPELL){
		let path = dirsys~"MagicCircle.dnh";
		// let id = LoadScript(path);
		let id = LoadScriptInThread(path); //not sure if this makes a difference
		StartScript(id);
	}
	case(EV_END_BOSS_STEP){
		let objScene = GetEnemyBossSceneObjectID();
		if(ObjEnemyBossScene_GetInfo(objScene,INFO_IS_SPELL)){
			SpellShatter([]);
		}
	}
	case(EV_GAIN_SPELL){
		let objScene = GetEnemyBossSceneObjectID();
		let score = ObjEnemyBossScene_GetInfo(objScene, INFO_SPELL_SCORE);
		score = trunc(score/10)*10;
		if(score!=0){ //since this seems fucky
			TGainSpell(score);
			AddScore(score);
		}else{
			TFailSpell();
		}
		SpellShatter([]);
	}
	case(EV_FAIL_SPELL) {
		TFailSpell();
		SpellShatter([]);
	}
	case(EV_PLAYER_SHOOTDOWN){
		if(GetCommonData("UsePlayerPower",true) && GetPlayerLife >= 0){
			let px = GetPlayerX; let py = GetPlayerY;
			SetPlayerPower( max(0,min(400,GetPlayerPower-100)) );
			let a = atan2(0-GetPlayerY,GetStgFrameWidth/2-GetPlayerX);
			ascent(i in -3..4){
				let type;
				alternative(i)
				case(0){
					if(GetPlayerLife >= 1){
						type = I_POWER_L;
					}else{
						type = I_POWER_F;
					}
				}
				others { type = I_POWER; }
				NotifyEvent(GetCommonData("ItemScriptID",NULL),EV_SPAWN_ITEM,
				  [type,GetPlayerX,GetPlayerY,GetPlayerX+200*cos(a+20*i),GetPlayerY+200*sin(a+20*i),0] );
			}
		}
	}
	case(EV_SHATTER_SCREEN){
		let args = GetEventArgument(0);
		SpellShatter(args);
	}
	case(EV_SET_FULLSCREEN){
		let args = GetEventArgument(0);
		SetFullScreen(args[0]=="true", atoi(args[1]) );
	}
	case(EV_PLAY_SOUND){
		let args = GetEventArgument(0);
		SE_Play(args[0],ator(args[1]));
	}
	
}

// function wait(w) { loop(w) { yield; } } 


sub InstallFonts{
	WriteLog("Installing fonts");
	//These ones can be used with the same name as the filename
	InstallFont(dirCurrent~"font/Helvetica.otf"); //.otf for One True Font
	InstallFont(dirCurrent~"font/Cirno.ttf");     //"Standard" Touhou font for dialogue, etc. Fairly compact.
	InstallFont(dirCurrent~"font/Gyosho.ttf");    //Good for titles and such
	InstallFont(dirCurrent~"font/THSpatial.ttf"); //monospace
	InstallFont(dirCurrent~"font/Russell Square Regular.ttf");
	//Other fonts
	InstallFont(dirCurrent~"font/spincycle_ot.otf"); //kinda like the Pokemon title font. "SpinCycleOT"
	// InstallFont(dirCurrent~"font/wlmaru2044u.ttf"); //Japanese mono - "WadaLabMaruGo20044"
	// InstallFont(dirCurrent~"font/more/Akashi.ttf"); //squareish titles. "Akashi"
	// InstallFont(dirCurrent~"font/more/Legionv3.ttf"); //very square. "Legion"
	// InstallFont(dirCurrent~"font/more/galax.ttf"); //kinda weird and pixely. "Galaxy Monkey"
	WriteLog("Done installing fonts");
}

function GetConfig{
	let isconfig = LoadCommonDataAreaA2("CONFIG",dirdat~"config.dat");
	if(!isconfig){
		CreateCommonDataArea("CONFIG");
		SetAreaCommonData("CONFIG","Difficulty",NORMAL);
		SaveCommonDataAreaA2("CONFIG",dirdat~"config.dat");
	}
}


//----------------------------------------------------
//枠外の背景表示
//----------------------------------------------------
function InitFrame(){
	let path = GetCurrentScriptDirectory() ~ "img/SystemBackground.png";
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(obj, path);
	Obj_SetRenderPriority(obj, 0);
	ObjSprite2D_SetSourceRect(obj, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
	ObjSprite2D_SetDestRect(obj, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
}





//////////////////////////////////////////////////////
//----------------------------------------------------
//ONGOING TASKS
//----------------------------------------------------
//////////////////////////////////////////////////////



//----------------------------------------------------
//スコア表示
//----------------------------------------------------
task TScore(){
	//Score文字列
	let objScore = ObjText_Create();
	ObjText_SetText(objScore, "Score");
	ObjText_SetFontSize(objScore, 12); //20
	ObjText_SetFontType(objScore, "THSpatial"); 
	ObjText_SetFontBold(objScore, true);
	ObjText_SetFontColorTop(objScore, 196, 155, 255);
	ObjText_SetFontColorBottom(objScore, 128, 128, 200);
	// ObjText_SetFontBorderType(objScore, BORDER_FULL);
	// ObjText_SetFontBorderColor(objScore,128, 128, 128);
	// ObjText_SetFontBorderWidth(objScore, 2);
	Obj_SetRenderPriority(objScore, 0.01);
	ObjRender_SetAlpha(objScore,200);
	ObjRender_SetX(objScore, 580); //440 ,428
	ObjRender_SetY(objScore, 64); //48

	//得点
	let pathDigit = GetCurrentScriptDirectory() ~ "img/Default_SystemDigit.png";
	let count = 12;

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, pathDigit);
	ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	// ObjRender_SetColor(obj,200,200,255);
	ObjRender_SetColor(obj,180,180,200);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 72);
	
	let score=-1; let prev; let magnitude=-1;
	while(true){
		prev = score;
		score = min(GetScore, 999999999999);
		alternative(prev!=score)
		case(true){			
			ObjSpriteList2D_ClearVertexCount(obj);
			let digitList = DigitToArray(score, count);
			magnitude = trunc(log10(score));
			ascent(i in 0..count){
				let num = digitList[i];
				ObjRender_SetX(obj, 440 + i * 14);
			
				alternative(count-(i+1) <= magnitude)case(true){
					ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
					// ObjRender_SetColor(obj,200,200,255);
				}case(false){
					ObjSpriteList2D_SetSourceRect(obj, num * 36, 32, (num + 1) * 36, 64);
				}
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
				
				ObjSpriteList2D_AddVertex(obj);
			}
		}case(false){}
		yield;
	}
}

//----------------------------------------------------
//Graze表示
//----------------------------------------------------
task TGraze(){
	//Graze文字列
	
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Graze");
	ObjText_SetFontType(objText, "THSpatial");
	ObjText_SetFontSize(objText, 16); //14
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText,   120, 155, 100);  //120, 150, 100
	ObjText_SetFontColorBottom(objText, 55, 155,  55);  // 55, 128,  55	
	Obj_SetRenderPriority(objText, 0.01);
	ObjRender_SetX(objText, 440); //428
	ObjRender_SetY(objText, 260); //252

	//得点
	let pathDigit = GetCurrentScriptDirectory() ~ "img/Default_SystemDigit.png";
	let count = 5;

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, pathDigit);
	ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	ObjRender_SetColor(obj,100,155,100);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 276);
	
	

	loop{
		let graze = GetGraze();
		graze = min(graze, 99999);
		
		let listNum = DigitToArray(graze, count);

		ObjSpriteList2D_ClearVertexCount(obj);
		ascent(iObj in 0 .. count){
			let num = listNum[iObj];
			ObjRender_SetX(obj, 440 + iObj * 14);
			ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}

task TPlayerLife{	
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Player");
	ObjText_SetFontType(objText, "THSpatial");
	ObjText_SetFontSize(objText, 11); //12
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText, 200, 100, 160); //200, 100, 160
	ObjText_SetFontColorBottom(objText, 155, 55, 155); //155, 55, 155	
	Obj_SetRenderPriority(objText, 0.01);
	ObjRender_SetX(objText, 440); //428
	ObjRender_SetY(objText, 111); //107
	
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, GetCurrentScriptDirectory~"img/Default_System.png");
	// ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	ObjRender_SetBlendType(obj, BLEND_ADD_ARGB);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 122);
	
	let total=-1; let whole; let pieces;
	let x; let n;
	let prev; let incrcounter=0;
	
	while(true) {
		prev = total;
		total = min(GetPlayerLife(),9);
		
		//don't redraw the sprites EVERY FRAME unlike the default
		alternative(prev!=total)
		case(true){
			whole  = trunc(total);
			pieces = round(5*(total%1));

			ObjSpriteList2D_ClearVertexCount(obj);
			ascent(i in 0..9){
				// n = i-whole; //this is just sign(i-whole)
				// alternative( floor(n/((|n|)+1)) - floor(-n/((|-n|)+1)) )
				// case(-1){ x = 5;      ObjRender_SetAlpha(obj,255); }
				// case( 0){ x = pieces; ObjRender_SetAlpha(obj,96);  }
				// case( 1){ x = 0;      ObjRender_SetAlpha(obj,96);  }
				if(i<whole)      { x=5;      ObjRender_SetAlpha(obj,255); }
				else if(i>whole) { x=0;      ObjRender_SetAlpha(obj,128); }
				else             { x=pieces; ObjRender_SetAlpha(obj,128); }

				ObjRender_SetX(obj, 440 + i * 20);
				ObjSpriteList2D_SetSourceRect(obj, 2+x*16, 172, 2+(x+1)*16-1, 187);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 20, 20);
				ObjSpriteList2D_AddVertex(obj);
			}
			
			if(whole > floor(prev)){
				if(incrcounter > 1){ SE_Play(se_extend,100); }
				incrcounter++; //stops it from playing when initializing
			}
			// if(whole==-1){ TGameOver(); }
		}
		case(false){}
		yield;
	}
}
task TPlayerSpell{
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Spell");
	ObjText_SetFontType(objText, "THSpatial");
	ObjText_SetFontSize(objText, 11); //11
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText,   120, 150, 100);  //120, 150, 100
	ObjText_SetFontColorBottom(objText, 55, 128,  55);  // 55, 128,  55	
	Obj_SetRenderPriority(objText, 0.01);
	ObjRender_SetX(objText, 440); //428
	ObjRender_SetY(objText, 143); //143
	
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, GetCurrentScriptDirectory~"img/Default_System.png");
	// ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	ObjRender_SetBlendType(obj, BLEND_ADD_ARGB);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 152);

	let total=-1; let whole; let pieces;
	let x; let n;
	let prev; 
	
	while(true) {
		prev = total;
		total = min(GetPlayerSpell(),9);
		
		//don't redraw the sprites EVERY FRAME unlike the default
		alternative(prev!=total)
		case(true){
			whole  = trunc(total);
			pieces = round(5*(total%1));

			ObjSpriteList2D_ClearVertexCount(obj);
			ascent(i in 0..9){
				// n = i-whole; //this is just sign(i-whole)
				// alternative( floor(n/((|n|)+1)) - floor(-n/((|-n|)+1)) )
				// case(-1){ x = 5; }
				// case( 0){ x = pieces; }
				// case( 1){ x = 0; }
				if(i<whole)      { x=5;      ObjRender_SetAlpha(obj,255); }
				else if(i>whole) { x=0;      ObjRender_SetAlpha(obj,128); }
				else             { x=pieces; ObjRender_SetAlpha(obj,128); }

				ObjRender_SetX(obj, 440 + i * 20);
				ObjSpriteList2D_SetSourceRect(obj, 2+x*16, 192, 2+(x+1)*16-1, 207);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 20, 20);
				ObjSpriteList2D_AddVertex(obj);
			}
		}
		case(false){}
		yield;
	}
}


task TPlayerPower{
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Power");
	ObjText_SetFontType(objText, "THSpatial");
	ObjText_SetFontSize(objText, 16); //14
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText,    200, 64, 100); //255, 64, 100
	ObjText_SetFontColorBottom(objText, 155, 55, 55);  //255, 55, 55
	Obj_SetRenderPriority(objText, 0.01);
	ObjRender_SetX(objText, 440); //428
	ObjRender_SetY(objText, 202); //202

	
	let meter = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(meter,dirCurrent~"img/Default_System.png");
	ObjSprite2D_SetSourceRect(meter,0,232,63,243);
	ObjRender_SetBlendType(meter, BLEND_ALPHA);
	ObjRender_SetColor(meter,64,0,0);
	ObjRender_SetAlpha(meter,128);
	Obj_SetRenderPriority(meter, 0.1);
	ObjRender_SetX(meter,440);
	ObjRender_SetY(meter,216);
	ObjSprite2D_SetDestRect(meter,0,0,130,26);
	
	let gauge = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(gauge,dirCurrent~"img/Default_System.png");
	ObjSprite2D_SetSourceRect(gauge,0,216,63,227);
	ObjRender_SetBlendType(gauge, BLEND_ADD_ARGB);
	ObjRender_SetColor(gauge,200,64,64);
	ObjRender_SetAlpha(gauge,64);
	Obj_SetRenderPriority(gauge, 0.1);
	ObjRender_SetX(gauge,440);
	ObjRender_SetY(gauge,216);
	ObjSprite2D_SetDestRect(gauge,0,0,130,26);
	
	let pathDigit = dirCurrent~"img/Default_SystemDigit.png";
	let count = 3;
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, pathDigit);
	ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	ObjRender_SetColor(obj,235,200,180);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 216); //226
	


	let point=-1; let prev;
	while(true){
		prev = point;
		point = GetPlayerPower;
		
		alternative(prev!=point)
		case(true){
			let listNum = DigitToArray(point, count);
			ObjSpriteList2D_ClearVertexCount(obj);
			//Ones place
			let num = listNum[0];
			ObjRender_SetX(obj, 440);
			ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
			ObjSpriteList2D_AddVertex(obj);
			//Decimal point
			ObjRender_SetX(obj, 454);
			ObjSpriteList2D_SetSourceRect(obj, 360, 0, 396, 32);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
			ObjSpriteList2D_AddVertex(obj);
			//Tenths and hundredths places
			ascent(iObj in 1 .. count){
				num = listNum[iObj];
				ObjRender_SetX(obj, 454 + iObj * 14);
				ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
				ObjSpriteList2D_AddVertex(obj);
			}
			ObjSprite2D_SetDestRect(gauge,0,0,130*point/400,26);
			
			
			alternative(trunc(prev/100)!=trunc(point/100))case(true){
				
			}case(false){}
			
			
		}case(false){}
		yield;
	}
}


task TPointValue{
	
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Value");
	ObjText_SetFontType(objText, "THSpatial");
	ObjText_SetFontSize(objText, 11); //14
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText,   120, 155, 155);  //120, 150, 100
	ObjText_SetFontColorBottom(objText, 55, 128, 155);  // 55, 128,  55	
	Obj_SetRenderPriority(objText, 0.01);
	ObjRender_SetX(objText, 440+100); //428
	ObjRender_SetY(objText, 264); //252
	
	let pathDigit = dirCurrent~"img/Default_SystemDigit.png";
	let count = 12;

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, pathDigit);
	ObjRender_SetBlendType(obj, BLEND_ADD_ARGB);
	ObjRender_SetColor(obj, 55,155,155);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 272);
	ObjRender_SetScaleXYZ(obj,0.75,0.75,1);
	ObjRender_SetAlpha(obj,200);
	
	let last = -1;

	loop{
		let value = GetCommonData("PointValue", 10000+10*GetGraze);
		value = min(value, GetCommonData("MaxPointValue", 250000));
		
		if(value!=last){
			last = value;
			count = trunc(1+log10(value));
			let listNum = DigitToArray(value, count);

			ObjSpriteList2D_ClearVertexCount(obj);
			ascent(iObj in 0 .. count){
				let num = listNum[iObj];
				ObjRender_SetX(obj, 440+100 + iObj * 10); //*14
				// ObjSpriteList2D_SetSourceRect(obj, num * 16, 0, (num + 1) * 16, 20);
				ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
				// ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 20);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
				ObjSpriteList2D_AddVertex(obj);
			}
		}
		yield;
	}
	
}






//----------------------------------------------------
//ボスのライフ表示
//----------------------------------------------------
task TBossLife{
	let path = GetCurrentScriptDirectory() ~ "img/Default_System.png";
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, path);
	Obj_SetRenderPriority(obj, 0.71);

	let lastRemStep = -1;
	let lifeRateRender = 0;

	let objScene = ID_INVALID;
	loop{
		objScene = GetEnemyBossSceneObjectID();
		ObjSpriteList2D_ClearVertexCount(obj);
		if(objScene != ID_INVALID){
			RenderLife();
		}
		yield;
	}


	function RenderLife(){
		//残りステップ
		let countRemStep = ObjEnemyBossScene_GetInfo(objScene, INFO_REMAIN_STEP_COUNT);
		if(lastRemStep != countRemStep){
			//ステップが変化
			lifeRateRender = 0;
		}

		//ライフ表示
		let lifeTotalMax = ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_TOTAL_MAX_LIFE);
		let lifeTotal = ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_TOTAL_LIFE);
		let lifeRate = min(lifeTotal / lifeTotalMax, lifeRateRender);
		ObjSpriteList2D_SetSourceRect(obj, 1, 1, 127, 11);
		ObjSpriteList2D_SetDestRect(obj, 72, 8, 72 + 270 * lifeRate, 12);
		ObjSpriteList2D_AddVertex(obj);

		//ライフの区切り表示
		ObjSpriteList2D_SetSourceRect(obj, 132, 1, 137, 11);
		let listLifeDiv = [0] ~ ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_LIFE_RATE_LIST);
		ascent(iDiv in 0 .. length(listLifeDiv)){
			let rate = listLifeDiv[iDiv];
			let x = 72 + 270 * (1-rate);
			ObjSpriteList2D_SetDestRect(obj, x-1, 4, x + 1, 14);
			ObjSpriteList2D_AddVertex(obj);
		}

		//残りステップ表示
		ObjSpriteList2D_SetSourceRect(obj, 1, 1, 127, 11);
		ascent(iStep in 0 .. countRemStep){
			let remStepRate = 58 / countRemStep;
			ObjSpriteList2D_SetDestRect(obj, 4 + iStep * remStepRate + 2, 8,
				4 + (iStep + 1) * remStepRate, 12);
			ObjSpriteList2D_AddVertex(obj);
		}

		lifeRateRender += 0.01;
		lifeRateRender = min(lifeRateRender, 1);
		lastRemStep = countRemStep;
	}
}

//----------------------------------------------------
//タイマー表示
//----------------------------------------------------
task TBossTimer{
	let pathDigit = GetCurrentScriptDirectory() ~ "img/Default_SystemDigit.png";

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, pathDigit);
	ObjRender_SetBlendType(obj, BLEND_ADD_RGB);
	// Obj_SetRenderPriority(obj, 0.75);
	Obj_SetRenderPriorityI(obj, PRI_TIMER); //75
	ObjRender_SetY(obj, 0);
	let count = 2;

	let objScene = ID_INVALID;
	loop{
		// objScene = GetEnemyBossSceneObjectID();
		ObjSpriteList2D_ClearVertexCount(obj);
		if(objScene != ID_INVALID && ObjEnemyBossScene_GetInfo(objScene, INFO_IS_SPELL)){
			RenderTimer();
		}else{
			objScene = GetEnemyBossSceneObjectID();
		}
		yield;
	}

	function RenderTimer(){
		let timer = ObjEnemyBossScene_GetInfo(objScene, INFO_TIMER);
		timer = min(timer, 99);
		let listNum = DigitToArray(timer, count);

		// ObjSpriteList2D_ClearVertexCount(obj);
		ascent(iObj in 0 .. count){
			let num = listNum[iObj];
			ObjRender_SetX(obj, 352 + iObj * 14);
			ObjSpriteList2D_SetSourceRect(obj, num * 36, 0, (num + 1) * 36, 32);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 24);
			ObjSpriteList2D_AddVertex(obj);
		}
	}
	yield;
}

//----------------------------------------------------
//スペルカード取得表示
//----------------------------------------------------
task TGainSpell(score){
	SetCommonData("SpellsCaptured",GetCommonData("SpellsCaptured",0)+1);
	
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Spell Card Bonus!");
	ObjText_SetFontType(objText,"Gyosho");
	ObjText_SetFontSize(objText, 32);
	ObjText_SetFontBold(objText, true);
	// ObjText_SetFontColorTop(objText, 255, 255, 255);
	ObjText_SetFontColorTop(objText, 255, 128, 128);
	ObjText_SetFontColorBottom(objText, 128, 128, 255);
	ObjText_SetFontBorderType(objText, BORDER_FULL);
	// ObjText_SetFontBorderColor(objText,255, 255, 255);
	ObjText_SetFontBorderColor(objText,0, 0, 0);
	ObjText_SetFontBorderWidth(objText, 1);
	// Obj_SetRenderPriority(objText, 0.6);
	Obj_SetRenderPriorityI(objText, PRI_OVER);
	ObjText_SetMaxWidth(objText,sx);
	ObjText_SetHorizontalAlignment(objText,ALIGNMENT_CENTER);
	// ObjRender_SetX(objText, 32);
	ObjRender_SetY(objText, 98);

	let strScore = "+" ~ IntToString(score);
	let objScore = ObjText_Create();
	ObjText_SetText(objScore, strScore);
	// ObjText_SetFontSize(objScore, 32);
	ObjText_SetFontSize(objScore, 20);
	ObjText_SetFontType(objScore,"THSpatial");
	ObjText_SetFontBold(objScore, true);
	// ObjText_SetFontColorTop(objScore, 255, 255, 255);
	ObjText_SetFontColorTop(objScore, 255, 128, 128);
	ObjText_SetFontColorBottom(objScore, 128, 128, 255);
	ObjText_SetFontBorderType(objScore, BORDER_FULL);
	// ObjText_SetFontBorderColor(objScore,255, 255, 255);
	ObjText_SetFontBorderColor(objScore,0, 0, 0);
	
	ObjText_SetFontBorderWidth(objScore, 1);
	// Obj_SetRenderPriority(objScore, 0.6);
	Obj_SetRenderPriorityI(objScore, PRI_OVER);
	ObjText_SetMaxWidth(objScore,sx);
	ObjText_SetHorizontalAlignment(objScore,ALIGNMENT_CENTER);
	// ObjRender_SetX(objScore, 180);
	// ObjRender_SetY(objScore, 140);
	ObjRender_SetY(objScore, 128);

	loop(120){
		yield;
	}
	descent(i in 0..30){
		ObjRender_SetAlpha(objText ,255*i/30);
		ObjRender_SetAlpha(objScore,255*i/30);
		yield;
	}
	Obj_Delete(objText);
	Obj_Delete(objScore);
}

task TFailSpell(){
	let objText = ObjText_Create();
	ObjText_SetText(objText, "Bonus Failed");
	ObjText_SetFontType(objText,"Gyosho");
	ObjText_SetFontSize(objText, 32);
	ObjText_SetFontBold(objText, true);
	// ObjText_SetFontColorTop(objText, 255, 255, 255);
	ObjText_SetFontColorTop(objText, 255, 128, 128);
	ObjText_SetFontColorBottom(objText, 128, 128, 255);
	ObjText_SetFontBorderType(objText, BORDER_FULL);
	// ObjText_SetFontBorderColor(objText,255, 255, 255);
	ObjText_SetFontBorderColor(objText,0, 0, 0);
	ObjText_SetFontBorderWidth(objText, 1);
	// Obj_SetRenderPriority(objText, 0.6);
	Obj_SetRenderPriorityI(objText, PRI_OVER);
	ObjText_SetMaxWidth(objText,sx);
	ObjText_SetHorizontalAlignment(objText,ALIGNMENT_CENTER);
	// ObjRender_SetX(objText, 64);
	ObjRender_SetY(objText, 98);
	loop(120){
		yield;
	}
	descent(i in 0..30){
		ObjRender_SetAlpha(objText ,255*i/30);
		yield;
	}
	Obj_Delete(objText);
}

//----------------------------------------------------
//FPS表示
//----------------------------------------------------
task TCurrentFps(){
	let objText = ObjText_Create();
	ObjText_SetFontSize(objText, 14);
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText, 160, 160, 255);
	ObjText_SetFontColorBottom(objText, 64, 64, 255);
	ObjText_SetFontBorderType(objText, BORDER_FULL);
	ObjText_SetFontBorderColor(objText,255, 255, 255);
	ObjText_SetFontBorderWidth(objText, 2);
	ObjText_SetHorizontalAlignment(objText, ALIGNMENT_RIGHT);
	ObjText_SetMaxWidth(objText, GetScreenWidth() - 8);
	// Obj_SetRenderPriority(objText, 1.0);
	Obj_SetRenderPriorityI(objText, 99);
	ObjRender_SetX(objText, 0);
	// ObjRender_SetY(objText, GetScreenHeight() - 20  -17*3);
	ObjRender_SetY(objText, GetScreenHeight() - 20);

	loop{
		let fps = GetCurrentFps();
		let text = vtos("1.2f", fps) ~ "fps";
		ObjText_SetText(objText, text);
		yield; //i++; 
	}
	
}

task TReplayFps(){
	if(!IsReplay()){return;}

	let objText = ObjText_Create();
	ObjText_SetFontSize(objText, 12);
	ObjText_SetFontBold(objText, true);
	ObjText_SetFontColorTop(objText, 128, 128, 255);
	ObjText_SetFontColorBottom(objText, 64, 64, 255);
	ObjText_SetFontBorderType(objText, BORDER_FULL);
	ObjText_SetFontBorderColor(objText,255, 255, 255);
	ObjText_SetFontBorderWidth(objText, 1);
	Obj_SetRenderPriority(objText, 1.0);

	let px = GetStgFrameLeft() + GetStgFrameWidth() - 18;
	let py = GetStgFrameTop() + GetScreenHeight() - 14;
	ObjRender_SetX(objText, px);
	ObjRender_SetY(objText, py);

	loop
	{
		let fps = GetReplayFps();
		let text = vtos("02d", fps);
		ObjText_SetText(objText, text);
		yield;
	}
}

//----------------------------------------------------
//ユーティリティ
//----------------------------------------------------
// function DigitToArray(let digit,let count){
	// let res = [];
	// digit = truncate(digit);
	// loop{
		// let tnum = truncate(digit % 10);
		// digit /= 10;
		// res = [tnum] ~ res;
		// if(truncate(digit) == 0){break;}
	// }
	// loop(max(0, count - length(res))){
		// res = [0] ~ res;
	// }
	// return res;
// }







task TEnemyMarker() {
	let stgBottom = GetStgFrameHeight()+GetStgFrameTop; //+25
	let stgLeft = GetStgFrameLeft;
	
	let path = dirsys~"img/enemymarker.png";
	let blend = BLEND_ALPHA;
	let malpha = 200;
	let fadetime = 33;
	//BLEND_ALPHA,200,33
	
	let scene; let boss;
	loop{
		//	 Wait to enter a boss scene
		scene = ID_INVALID;
		while(scene==ID_INVALID){yield;scene=GetEnemyBossSceneObjectID;}
		//	 Wait for boss to be created
		boss = ID_INVALID;
		while(boss==ID_INVALID){yield;boss=GetEnemyBossObjectID[0];}
		//	 Run a marker task for each boss
		let bosses = GetAllBossID;
		ascent(i in 0..length(bosses)){ Manage(bosses[i]); }
		//	 Wait for "real" boss to be deleted
		while(!Obj_IsDeleted(boss)){ yield; }
		//	 Wait just in case
		loop(5){yield};
	}
	
	task Manage(boss){
		let x;
		let hidecount = 0;
		let dalpha = malpha/fadetime;
		let marker = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(marker,path);
		ObjSprite2D_SetSourceRect(marker, 0, 0, 64, 16); 
		ObjSprite2D_SetDestCenter(marker);
		// Obj_SetRenderPriority(marker, 0.95);
		Obj_SetRenderPriorityI(marker, 19);
		ObjRender_SetBlendType(marker,blend);
		// ObjRender_SetAlpha(marker,0);
		ObjRender_SetPosition(marker,0,stgBottom+8,0);
		ObjRender_SetAlpha(marker,malpha);
		
		// ObjRender_SetColor(marker,255,128,150);
		ObjRender_SetColor(marker,255,196,196);
		
		while(!Obj_IsDeleted(boss)) {
			x = ObjMove_GetX(boss);
			ObjRender_SetX(marker,stgLeft+x); //+35
			
			if(!Obj_IsVisible(boss) || (x<0||x>sx) ){
				hidecount++;
			}else{
				hidecount--;
			}
			hidecount = max(0,min(hidecount,fadetime));
			ObjRender_SetAlpha(marker,malpha-hidecount*dalpha);
			
			
			//"hitting boss" noises (why is this in *here* again?)
			if(ObjEnemy_GetInfo(boss,INFO_SHOT_HIT_COUNT)>0) {
				if(ObjEnemy_GetInfo(boss,INFO_DAMAGE_RATE_SHOT)!=0) {
					if(ObjEnemy_GetInfo(boss,INFO_LIFE) > 0.1*ObjEnemyBossScene_GetInfo(scene,INFO_CURRENT_LIFE_MAX)) {
						SE_Play(se_damage1,50);
					} else {
						SE_Play(se_damage2,75);
					}
				}
				else {
					SE_Play(se_nodamage,40); //50
				}
			}
			
			yield;
			
		}
		Obj_Delete(marker);
	}
	
}







task TScoreExtend { //TODO: check only when score is gained
	//	20,40,80,150 million points
	// let target = 10000000; //added another digit bc pretty sure that's how it's supposed to be. rebalance by adding more scoring opportunities
	let targets = [20000000,40000000,80000000,150000000];
	let i = 0;
	let target = targets[i];
	while(true) {
		if(GetScore() >= target) {
			SetPlayerLife(GetPlayerLife()+1);
			SE_Play(se_extend,100);
			// target*=2;
			i++;
			if(i > length(targets)-1){target*=10;}
			else{ target = targets[i]; }
		}		
		yield;
	}
}

task TTimerTick {
	let seobj = ObjSound_Create();
	let objScene = ID_INVALID;
	while(objScene==ID_INVALID){yield;objScene=GetEnemyBossSceneObjectID;}
	while(ObjEnemyBossScene_GetInfo(objScene, INFO_TIMER)>11){wait(60);}
	loop{
		loop(60){yield;}
		while(ObjEnemyBossScene_GetInfo(objScene, INFO_TIMERF)%60!=0){yield;}
		TimerTick();
	}
	function TimerTick() {
		//Timer sounds for last 10 seconds of spellcards
		let timer = ObjEnemyBossScene_GetInfo(objScene, INFO_TIMER);
		if(timer<=10 && timer>0 && GetCommonData("TimeFlowing",true)) { 
			if(timer>3) { SE_PlayA2(se_time1,100,seobj,45); }
			else {        SE_PlayA2(se_time2,100,seobj,45); }
		}
	}
}






//"Projection" system
task TProjection{
	let g0 = GetGraze; //total graze on previous frame
	let g  = GetGraze; //total graze on current frame
	let dg = 0;        //how much graze changed this frame - 0 if no shots were grazed
	
	let gauge = 0.0;     //value of gauge - 0 to 1
	SetCommonData("ThirdEyeGauge",gauge);
	let idle = 0;        //frames since graze last increased
	//Multipliers for speed of gauge incr/decr
	let incrScaleUp = 1;
	let incrScaleDn = 1;
	
	let isactive = false;
	let isfull = false;
	let wasfull = false;
	
	let isLegacy = GetCommonData("IsLegacyMode",false);
	
	let bar; let back; let glow; let label;
	InitializeBar;
	let glowcounter = 0; //counter variable for glow pulsing
	
	AddVirtualKey(VK_USER1,KEY_C,KEY_INVALID);
	let gx; let gy; //ghost coords
	
	
	//Main update loop
	loop{
		g0 = g;
		g = GetGraze;
		dg = g - g0;
		
		
		if(dg > 0 || gauge!=GetCommonData("ThirdEyeGauge",gauge)){
			gauge = GetCommonData("ThirdEyeGauge",gauge);
			gauge += 0.025*dg *incrScaleUp;	//0.02
			idle = 0;
			gauge = min(gauge,1.1); //allow to go a bit over 100% for purpose of staying full
			AddScore(round(10*min(gauge,1.0))*100*dg);	//leave ones place alone, by convention
		}
		else{
			idle++;
			if(idle > (75+15*gauge)*(1/incrScaleDn)){
				gauge -= 0.0001*((idle)^0.5)*((1/min(1,gauge))^0.5) *incrScaleDn;
				gauge = max(gauge,0.0);
			}
		}
		
		SetCommonData("ThirdEyeGauge",gauge);
		
		wasfull = isfull;
		isfull = (gauge >= 0.95);
		
		//Update display
		// ObjSprite2D_SetDestRect(bar,0,-20,100*gauge,0);
		// ObjSprite2D_SetDestRect(glow,-2,-22,100*gauge+2,2);
		let dispgauge = min(gauge,1);
		ObjSprite2D_SetDestRect(bar,0,-16,100*dispgauge,0);
		ObjSprite2D_SetDestRect(glow,-2,-18,100*dispgauge+2,2);
		alternative(isactive)
		case(false){
			ObjRender_SetColor(bar,128+255*dispgauge,128+128*dispgauge,255-200*dispgauge);
		}case(true){
			ObjRender_SetColor(bar,255,255-128*dispgauge,200*dispgauge);
		}
		
		//When gauge is full
		if(isfull || isactive){	
			AddScore(10); //shouldn't be too broken			
			ObjRender_SetAlpha(glow,128+64*sin(10*glowcounter)*cos(10*glowcounter));
			// CollectAllItems;
		}else{
			ObjRender_SetAlpha(glow,128*gauge);
		}
		glowcounter++;
		
		alternative(isLegacy)
		case(false){ //Psionic Mode			
			//If player presses the key to trigger activated effect	
			if( ( isfull || isactive ) 
			  && ( GetVirtualKeyState(VK_USER1)==KEY_PUSH && !IsPlayerSpellActive 
			  && (GetPlayerState==STATE_NORMAL || GetPlayerState==STATE_HIT ))){
				Activate;
			}
			
			if(isfull && !isactive){
				ObjText_SetText(label,"Third Eye Open");
			}else if(!isactive){
				ObjText_SetText(label,"Third Eye");
			}else{
				ObjText_SetText(label,"Astral Projection Active!");
			}
		}
		case(true){ //Legacy Mode
			if( isfull ){
				ObjText_SetText(label,"Third Eye Sealed");
				SetPlayerRebirthFrame(GetCommonData("BorderOfLifeAndDeathExtended",15));
			}else{
				ObjText_SetText(label,"Third Eye Sealed");
				SetPlayerRebirthFrame(GetCommonData("BorderOfLifeAndDeath",6));
			}
		}
		
		yield;
	}
	//End of main update loop
	
	
	
	task Activate{
		alternative(isactive)
		//Creating projection
		case(false){
			EmptyGauge(0.5);
			isactive = true;
			incrScaleDn = 2; incrScaleUp = 2;
			DeleteShotInCircle(TYPE_SHOT,TYPE_ITEM,GetPlayerX,GetPlayerY,100);
			SE_Play(dirCurrent~"../se/exattack.wav",100);
			
			// ObjText_SetText(label, "Astral Projection Active!");
			
			TGhost;
			
			
			while(gauge>0){
				if(IsPlayerLastSpellWait){ //if player is counter-bombing
					EmptyGauge(0); isactive = false;
					while(IsPlayerLastSpellWait){yield;}
					break;
				}
				yield;
			}
			
			
			isactive = false;
			incrScaleDn = 1; incrScaleUp = 1;
			return;
		}
		
		//Warping to projection
		case(true){
			isactive = false;
			EmptyGauge(0);
			ObjMove_SetPosition(GetPlayerObjectID,gx,gy);
			SE_Play(dirCurrent~"../se/se_warp_n.wav",100);
			SetPlayerInvincibilityFrame(30);
		}
		
	}
	
	task TGhost{
		//Main render object
		let ghost = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(ghost,dirCurrent~"../img/ZUN_Effect.png");
		ObjSprite2D_SetSourceRect(ghost,0,16,63,79);
		ObjSprite2D_SetDestCenter(ghost);
		Obj_SetRenderPriorityI(ghost,PRI_HITBOX);
		//One that rotates the other way
		let gmirr = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(gmirr,dirCurrent~"../img/ZUN_Effect.png");
		ObjSprite2D_SetSourceRect(gmirr,0,16,63,79);
		ObjSprite2D_SetDestCenter(gmirr);
		Obj_SetRenderPriorityI(gmirr,PRI_HITBOX);
		
		//Screen effect to make it clear when active
		let scr = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(scr,dirCurrent~"img/swirlwhite.png");
		ObjSprite2D_SetSourceRect(scr,0,0,255,255);
		ObjSprite2D_SetDestCenter(scr);
		Obj_SetRenderPriorityI(scr,PRI_OVERLAY); //was 73
		ObjRender_SetPosition(scr,GetStgFrameWidth/2,GetStgFrameHeight/2,0);
		ObjRender_SetScaleXYZ(scr,2.5,2.5,1);
		ObjRender_SetBlendType(scr,BLEND_ADD_ARGB);

		
		let playerspeed = GetPlayerSpeed;
		let unf = playerspeed[0];
		let foc = playerspeed[1];
		SetPlayerSpeed(0,foc);
		
		//Border of life and death is extended while active
		// let BoLaD = GetPlayerRebirthFrame;
		// SetPlayerRebirthFrame(60); //(number of frames player can counter-bomb)
		let bolad = GetCommonData("BorderOfLifeAndDeathVeryExtended",60);
		SetCommonData("BorderOfLifeAndDeath",bolad);
		SetPlayerRebirthFrame(bolad);
		
		gx = GetPlayerX;
		gy = GetPlayerY;
		let a=0; let da=5;
		
		let lastdeflectdir = 1;
		
		//Main update loop for ghost
		while(isactive && gauge>0){
			
			if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD){
				
				if(GetVirtualKeyState(VK_LEFT)!=KEY_FREE && GetVirtualKeyState(VK_LEFT)!=KEY_PULL){
					gx-=unf;
				}
				if(GetVirtualKeyState(VK_RIGHT)!=KEY_FREE && GetVirtualKeyState(VK_RIGHT)!=KEY_PULL){
					gx+=unf;
				}
				if(GetVirtualKeyState(VK_UP)!=KEY_FREE && GetVirtualKeyState(VK_UP)!=KEY_PULL){
					gy-=unf;
				}
				if(GetVirtualKeyState(VK_DOWN)!=KEY_FREE && GetVirtualKeyState(VK_DOWN)!=KEY_PULL){
					gy+=unf;
				}
				
				if(gx<0){gx=GetStgFrameWidth;}
				else if(gx>GetStgFrameWidth){gx=0;}
				if(gy<0){gy=GetStgFrameHeight;}
				else if(gy>GetStgFrameHeight){gy=0;}
				
				
				
				
				
				da   = min(da+0.5, 5);
				DeflectShots(64);
			}else{
				da = max(da-0.5,-2);  
				DeflectShots(32);
			}
			
			CollectItemsInCircle(gx,gy,45);
			
			
			
			
			
			
			
			a+=da*gauge;
			
			ObjRender_SetX(ghost,gx);
			ObjRender_SetY(ghost,gy);
			ObjRender_SetAngleZ(ghost,a);
		
			ObjRender_SetX(gmirr,gx);
			ObjRender_SetY(gmirr,gy);
			ObjRender_SetAngleZ(gmirr,-a);
			
			ObjRender_SetAngleZ(scr,-a);
			ObjRender_SetAlpha(scr, (128+32*da/5)*gauge^0.5);
			
			//Red and blue based on whether focus is held -> whether moving player or projection
			//Green pulses based on whether gauge is full -> whether can warp to projection
			ObjRender_SetColor(scr, 255-128*da,      
			                        100*(gauge^4)+155*((max(gauge,0.95)-0.95)*20/3)*sin(glowcounter*10),
									255+128*da/2);
			
			// ObjPlayer_ClearIntersection(GetPlayerObjectID);
			// ObjPlayer_AddIntersectionCircleA1(GetPlayerObjectID,-GetPlayerX + gx,-GetPlayerY + gy,1,20);
			
			//Cancel
			// if(GetVirtualKeyState(VK_USER1)==KEY_PUSH && gauge < 0.95){
				// SE_Play(dirCurrent~"../se/eleburst.wav",100);
				// // isactive = false;
				// // break;
			// }
			yield;
		}
		//End of main ghost update loop
		
		// SetPlayerSpeed(unf,foc);
		let spd = GetCommonData("PlayerSpeed",[unf,foc]);
		SetPlayerSpeed(spd[0],spd[1]);
		// SetPlayerRebirthFrame(BoLaD);
		bolad = GetCommonData("BorderOfLifeAndDeathNormal",6);
		SetCommonData("BorderOfLifeAndDeath",bolad);
		SetPlayerRebirthFrame(bolad);
		
		Obj_Delete(ghost);
		Obj_Delete(gmirr);
		Obj_Delete(scr);
		
	}
	
	
	//Helper functions
	task EmptyGauge(level){
		let incr = (gauge-level)/30;
		loop(30){
			gauge-=incr;
			yield;
		}
	}
	
	
	function InitializeBar{
		//Main bar showing value of gauge
		bar = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(bar, GetCurrentScriptDirectory() ~ "img/Default_System.png");
		Obj_SetRenderPriorityI(bar, PRI_OVERLAY+1);
		ObjSprite2D_SetSourceRect(bar,0,0,127,11);
		ObjRender_SetY(bar,443); ObjRender_SetX(bar,5);
		ObjSprite2D_SetDestRect(bar,0,-16,100,0);
		//"Empty" bar behind it
		back = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(back, GetCurrentScriptDirectory() ~ "img/Default_System.png");
		Obj_SetRenderPriorityI(back, PRI_OVERLAY+1);
		ObjSprite2D_SetSourceRect(back,184,205,255,255);
		ObjRender_SetY(back,443); ObjRender_SetX(back,5);
		ObjSprite2D_SetDestRect(back,-1,-16,101,1);
		ObjRender_SetAlpha(back,64);
		//Glow when gauge full
		glow = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(glow, GetCurrentScriptDirectory() ~ "img/Default_System.png");
		Obj_SetRenderPriority(glow, 0.71);
		ObjSprite2D_SetSourceRect(glow,0,0,127,11);
		ObjRender_SetY(glow,443); ObjRender_SetX(glow,5);
		ObjSprite2D_SetDestRect(glow,0,-16,0,0);
		ObjRender_SetBlendType(glow,BLEND_ADD_ARGB);
		ObjRender_SetAlpha(glow,0);
		
		//Text label
		label = ObjText_Create();
		ObjText_SetText(label, "Third Eye");
		ObjText_SetFontType(label, "Gyosho");
		ObjText_SetFontSize(label, 12); //11
		ObjText_SetFontColorTop(label, 160, 100, 200); //200, 100, 160
		ObjText_SetFontColorBottom(label, 155, 55, 155); //155, 55, 155	
		Obj_SetRenderPriorityI(label, PRI_OVERLAY+1);
		ObjRender_SetX(label, 10);  //10, 15 
		ObjRender_SetY(label, 419); //420, 430
		ObjText_SetFontBorderColor(label,0,255,255);
	}
	
	
	
}
//End of "projection" system



function DeflectShots(r){
	//Push shots away (should be only while unfocused)
	let gauge = GetCommonData("ThirdEyeGauge",0.0);
	let shots = GetShotIdInCircleA2(GetPlayerX,GetPlayerY,r,TARGET_ENEMY);
	ascent(i in 0..length(shots)){
		let shot = shots[i];
		let x = ObjMove_GetX(shot);
		let y = ObjMove_GetY(shot);
		// let a = getangle(px,py,x,y);
		// let a = atan2(y-GetPlayerY,x-GetPlayerX);
		let a = atan2(GetPlayerY-y,GetPlayerX-x);
		let dir = ObjMove_GetAngle(shot);
		let da = GetAngularDistance(a,dir);
		if((|da<25|)){		 //25		
			let dist = (((GetPlayerX-x)^2+(GetPlayerY-y)^2)^0.5);
			let spd = ObjMove_GetSpeed(shot);
			let d = 1 - dist/r;
			let s = 0.5 * min(gauge,1)*d*spd;
			// let deflectdir = tononzeroD(sign(da),lastdeflectdir);
			// lastdeflectdir = deflectdir;
			let deflectdir = tononzeroD(sign(da),sign(GetPlayerX-(x+dist*cos(dir))));
			// a = a - (15-(|da|))*deflectdir;
			// a = a - (45-(|da|))*deflectdir; //lol
			// let adj = -((15*s)-(|da|))*deflectdir;
			// let adj = -((15+15*d)-(|da|))*deflectdir; //invincible lol
			// let adj = -((15+15*d+spd*(1-(|da/25|)))-(|da|))*deflectdir; //also invincible lol

			// let adj = -((15*s)-(|da|))*deflectdir;
			let adj = ((15+15*d+s/d/(25-(|da|)))+(|da|))*deflectdir; //good but not OP

			ObjMove_SetPosition(shot,x-s*cos(a-adj),y-s*sin(a-adj));
			
			gauge -= 0.025 * s; //0.0001 * s
		}
	}
	SetCommonData("ThirdEyeGauge",gauge);
}







/////////////////////////////////////////////////////
//Conarnar
task SpellShatter(args){
	//offset
	let xO = -GetStgFrameLeft;
	let yO = -GetStgFrameTop;
	
	let s_pri = [20,69]; //[20,69]
	let d_pri = PRI_EFFECT; //41, prev 20
	
	
	
	let T = 60; let T2 = 120; let T3 = 180;
	
	let spinX=1; let spinY=1; let spinZ=1;
	let Dx = 3; let Dy = 3;
	
	//point which shards move away from
	let cx = GetStgFrameWidth/2; let cy = GetStgFrameHeight/2; 
	
	if(length(args)>0){
		ascent(i in 0..length(args)){
			let arg = SplitString(args[i],":");
			let k = arg[0]; let v; if(length(arg)>1){ v = arg[1]; }
			alternative(k)
			case("cx"){cx=ator(v);}
			case("cy"){cy=ator(v);}
			case("time"){T2=atoi(v); T=T2/2; T3=3*T; }
			case("spin"){ spinX=ator(v); spinY=spinX; spinZ=spinX; }
			case("spinX"){spinX=ator(v);}
			case("spinY"){spinY=ator(v);}
			case("spinZ"){spinZ=ator(v);}
			case("dx"){Dx=ator(v);}
			case("dy"){Dy=ator(v);}
			case("pri"){ let arr = SplitString(v,"[,]"); s_pri = [ ator(arr[0]), ator(arr[1]) ]; }
			case("destpri"){d_pri=ator(v);}
			
		}
	}
	
	// let s_pri = [0,100];
	// let d_pri = 100;
	
	
	CreateRenderTarget("SpellBG");
	RenderToTextureA1("SpellBG", s_pri[0], s_pri[1], true);

	// let aMax = 17;
	// let bMax = 14;
	// let aMax = 18; //18 //orig 17
	// let bMax = 15; //15 //orig 14
	ascent(a in -2..18) { //-2
		ascent(b in 0..15) {
			shard(a, b, true);
			shard(a, b, false);
		}
	}
	//Handle other effects
	SE_Play(se_spellbreak,100);
	ascent(i in 0..15){
		DeleteShotInCircle(TYPE_ALL, TYPE_ITEM, ex,ey, 800*(i/15)^2);
		yield;
	}
	

	task shard(a, b, ddd) {

		b = b-0.001*(b%2); //Prevents errors with confusing the top and bottom rows
		
		//  . . . . . .
		//   . . . . . .
		//  . . . . . .
		//   . . . . . .
		//Get a point on a triangular grid (similar to above) 
		function GetPt(c,r){ 
			let W=40; let H=40;
			let x = xO + W*c + W/2*(r%2);
			let y = yO + H*r;
			return [x,y];
		}
		//Assemble points of triangle
		function GetTri(r,c){
			let X = [ [   0,   1,   0] , [  -1,   0,   0] ][ddd];
			let Y = [ [   0,   0,   1] , [   1,   0,   1] ][ddd];
			
			let A = GetPt(r+X[0],  c+Y[0]);
			let B = GetPt(r+X[1],  c+Y[1]);
			let C = GetPt(r+X[2],  c+Y[2]);
			let tri = [ A[0],A[1], B[0],B[1], C[0],C[1] ];
			return tri;
		}
		//Calculate destination tri from difference between source pts and center pt
		function GetDest(T){
			let cx = (T[0]+T[2]+T[4])/3;
			let cy = (T[1]+T[3]+T[5])/3;
			let dest = [ T[0]-cx,T[1]-cy, T[2]-cx,T[3]-cy, T[4]-cx,T[5]-cy, cx,cy ];
			return dest;
		}
		
		///////////////////////////////////////////////////////////////////////
		

		let obj = ObjPrim_Create(OBJ_PRIMITIVE_2D);
		ObjPrim_SetPrimitiveType(obj, PRIMITIVE_TRIANGLELIST);
		ObjPrim_SetVertexCount(obj, 3);
		ObjPrim_SetTexture(obj, "SpellBG");
		Obj_SetRenderPriorityI(obj, d_pri);
	
	
	
		let tri = GetTri(a,b);
		let d_tri = GetDest(tri);
		let x=d_tri[6]; let y=d_tri[7];
		x+=xO; y+=yO;
		ObjRender_SetPosition(obj, x, y, 0);
		
		ObjPrim_SetVertexUVT(obj,      0,     tri[0],     tri[1]);
		ObjPrim_SetVertexUVT(obj,      1,     tri[2],     tri[3]);
		ObjPrim_SetVertexUVT(obj,      2,     tri[4],     tri[5]);
		ObjPrim_SetVertexPosition(obj, 0,   d_tri[0],   d_tri[1], 0);
		ObjPrim_SetVertexPosition(obj, 1,   d_tri[2],   d_tri[3], 0);
		ObjPrim_SetVertexPosition(obj, 2,   d_tri[4],   d_tri[5], 0);
		
		// Obj_SetRenderPriorityI(obj, d_pri);


		
		let dax = rand(-2, 2) * spinX; //*3
		let day = rand(-2, 2) * spinY;
		let daz = rand(-2, 2) * spinZ;
		
		let dx = (x - cx)/320 * 3; //*3
		let dy = (y - cy)/240 * 3;
		// let s = ( (dx)^2+(dy)^2 )^0.5;
		let ang = atan2(dy,dx);
		let s = rand(1,6);
		dx = ( dx + s*cos(ang) )/2;
		dy = ( dy + s*sin(ang) )/2;
		
		// Hold still for study
		// dx*=0; dy*=0; dax*=0;day*=0;daz*=0;
		// ObjRender_SetScaleXYZ(obj,0.95,0.95,1);
		
		
		

		ascent(i in 0..T) {
			let t = (i/T)^0.75 * T;
			ObjRender_SetPosition(obj, x+dx*t, y+dy*t, 0);
			ObjRender_SetAngleXYZ(obj, dax * t, day * t, daz * t);
			ObjRender_SetScaleXYZ(obj, (T3 - i)/T3, (T3 - i)/T3, 0);
			yield;
		}
		// ascent(i in 61..120) {
		ascent(i in T..T2) {
			let t = (i/T)^0.75 * T;
			ObjRender_SetPosition(obj, x+dx*t, y+dy*t, 0);
			ObjRender_SetAngleXYZ(obj, dax * t, day * t, daz * t);
			ObjRender_SetAlpha(obj, (T2 - i)/T * 255);
			yield;
		}

		Obj_Delete(obj);
	}
}
/////////////////////////////////////////////////////




















/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////  DEBUG TASKS ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////






let VK_CHEAT = VK_USER2;

task PlaytestInvincibility {
	// if(!GetCommonData("CheatEnable",false)){return;}
	if(!GetAreaCommonData("CONFIG","CheatEnable",false)){return;}
	AddVirtualKey(VK_CHEAT,KEY_SPACE,KEY_INVALID);
	let holdtime = 0; let last="life";
	loop {
		if(GetVirtualKeyState(VK_USER2)==KEY_HOLD) {
			if(holdtime > 30){
				if(GetPlayerLife<9){
					if(last!="life"){holdtime=0; last="life";}else{
					SetPlayerLife(min(9,GetPlayerLife+1/5));      
					if(GetPlayerLife%1==0){ holdtime=25; }        }
				}else if(GetPlayerSpell<9){
					if(last!="spell"){holdtime=20; last="spell";}else{
					SetPlayerSpell(GetPlayerSpell+1/5);              }
				}else if(GetPlayerPower<400){
					if(last!="power"){holdtime=0; last="power";}else{
					SetPlayerPower(min(400,GetPlayerPower+5));      }
				}else{
					SetCommonData("ThirdEyeGauge",min(1.1,GetCommonData("ThirdEyeGauge",0)+0.025));
				}
				
			}
			holdtime++;
			SetPlayerInvincibilityFrame(30);
		}else if(GetVirtualKeyState(VK_CHEAT)==KEY_PUSH){
			SetCommonData("Debug",true);
		}
		else{
			holdtime=0;
		}
		
		
		
		yield;
	}	
}




task TMiscCheatKeys{
	if(!GetAreaCommonData("CONFIG","CheatEnable",false)){return;}
	
	let slow=false;
	loop{
		let objScene = GetEnemyBossSceneObjectID;
		if(GetKeyState(KEY_O)==KEY_PUSH && GetVirtualKeyState(VK_CHEAT)==KEY_HOLD) {
			SetCommonData("Cheat_OverdriveShot",!GetCommonData("Cheat_OverdriveShot",false));
			let p = GetPlayerPower;SetPlayerPower(1000);yield;SetPlayerPower(p);
		}
		if(GetKeyState(KEY_W)==KEY_PUSH){
			if(!slow){
				StartSlow(TARGET_ALL, 12);
			}else{
				StopSlow(TARGET_ALL);
			}
			slow=!slow;
		}
		if(objScene!=ID_INVALID){
			if(GetKeyState(KEY_T)==KEY_HOLD){
				let timer = ObjEnemyBossScene_GetInfo(objScene,INFO_TIMERF);
				if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD){
					ObjEnemyBossScene_SetSpellTimer(objScene,max(15,timer-19));
				}else{
					ObjEnemyBossScene_SetSpellTimer(objScene,min(60*99,timer+21));
				}
			}
			if(GetKeyState(KEY_K)==KEY_HOLD && length(GetEnemyBossObjectID)>0){
				let mlife = ObjEnemyBossScene_GetInfo(objScene,INFO_CURRENT_LIFE_MAX);
				let clife = ObjEnemyBossScene_GetInfo(objScene,INFO_CURRENT_LIFE);
				let boss = GetEnemyBossObjectID[0];
				if(GetVirtualKeyState(VK_SLOWMOVE)!=KEY_HOLD){
					ObjEnemy_SetLife(boss, max(0, clife - mlife/100) );					
				}else{
					ObjEnemy_SetLife(boss, min(mlife, clife + mlife/100) );
				}
			}
		}
		yield;
	}
}








let VK_SCREENSHOT = VK_USER1+10;
task TScreenshot{
	AddVirtualKey(VK_SCREENSHOT,KEY_F2,KEY_INVALID);
	loop{
		// if(GetVirtualKeyState(VK_SCREENSHOT)==KEY_PUSH){
		if(GetKeyState(KEY_F2)==KEY_PUSH){
			SaveSnapShotA1(dirscreenshot~"Screenshot_"~GetCurrentDateTimeS~".png");
			SE_Play(se_select,100); //placeholder
			// AddScore(1);
		}
		yield;
	}
}








task TDrawHitboxes(){ //by Drake - toggle drawing shot hitboxes with h key
	if(!GetAreaCommonData("CONFIG","CheatEnable",false)){return;}
	let path = dirimg~"circle.png";
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, path);
	ObjSpriteList2D_SetSourceRect(obj, 0, 0, 256, 256);
	Obj_SetRenderPriorityI(obj, 51);
	ObjRender_SetPosition(obj, 0, 0, 0);
	// ObjRender_SetColor(obj, 255, 0, 0);
	// ObjRender_SetColor(obj, 64, 64, 64);
	ObjRender_SetBlendType(obj, BLEND_ALPHA);
	// ObjRender_SetBlendType(obj, BLEND_SUBTRACT);
	// ObjRender_SetBlendType(obj, BLEND_MULTIPLY);

	// let cx = GetStgFrameWidth() / 2;
	// let cy = GetStgFrameHeight() / 2;

	let toggle = false;

	loop{
		ObjSpriteList2D_ClearVertexCount(obj);
		if(GetKeyState(KEY_H) == KEY_PUSH){ toggle = !toggle; }
		if(toggle){ RenderHitboxes(); }
		yield;
	}

	function RenderHitboxes(){
		let shots = GetShotIdInCircleA2(cx, cy, cy*2, TARGET_ENEMY);

		ascent(i in 0..length(shots)){
			let shot = shots[i];
			let c_angle = ObjMove_GetAngle(shot);
			let c_speed = ObjMove_GetSpeed(shot);
			let origin = [ ObjMove_GetX(shot) + c_speed * cos(c_angle),
			               ObjMove_GetY(shot) + c_speed * sin(c_angle) ];
			let t = ObjMove_GetAngle(shot) - 90; // 90 offset to match with drawing angle
			let id = ObjShot_GetImageID(shot);
			
			ObjRender_SetColor(obj,0,0,0); //black outline
			let c = OS_GetDelayColor(shot);
			let R = c[0]; let G = c[1]; let B = c[2];
			
			let scl = Obj_GetValueD(shot,COL_SCALE,1);
			
			let col = [];
			// if(id!=0 && Obj_GetValueD(shot,FLAG_INTERSECTION,true)){
			if(Obj_GetValueD(shot,FLAG_INTERSECTION,true)){
				col = GetShotDataInfoA1(id, TARGET_ENEMY, INFO_COLLISION_LIST);
			}
			else if(Obj_IsValueExists(shot,"CollisionObject")){
				let colobj = Obj_GetValue(shot,"CollisionObject");
				col = [ [OC_GetIntersectionRadius(obj)],[0],[0] ];
			}
			descent(k in 0..2){
				ascent(j in 0..length(col)) {
					let pos = origin;
					let r = col[j][0]*scl + k;

					if(col[j][1] != 0 || col[j][2] != 0){
						pos = pos + [col[j][1]*cos(t) - col[j][2]*sin(t), col[j][1]*sin(t) + col[j][2]*cos(t)];
					}

					ObjSpriteList2D_SetDestRect(obj, pos[0]-r, pos[1]-r, pos[0]+r, pos[1]+r);
					ObjSpriteList2D_AddVertex(obj);
				}
				
				// ObjRender_SetColor(obj, c[0],c[1],c[2] );
				ObjRender_SetColor(obj, 2*(255-R),2*(255-G),2*(255-B) ); //stands out better
			}
			
		}
		
		
		let enems = GetAllEnemyID();
		
	}
}

task TDPS{
	if(!GetAreaCommonData("CONFIG","CheatEnable",false)){return;}
	let dpf;
	let dps = 0;
	let toggle = false;
	TToggle;
	
	let damages = MakeArray(60,0);
	let cnt = 1;

	let Fdps = 0;
	let Udps = 0;
	let Fcnt = 1;
	let Ucnt = 1;
	
	loop{
		if(toggle){
			dpf = SumDamages();
			if(dpf!=0){
				
				
				damages[cnt%30]=dpf; let sum = 0;
				ascent(i in 0..60){ sum+=damages[i]; }
		
				if(GetVirtualKeyState(VK_SLOWMOVE)==KEY_HOLD){
					Fdps = (Fdps*Fcnt + dpf)/(Fcnt+1); Fcnt++;
				}else{
					Udps = (Udps*Ucnt + dpf)/(Ucnt+1); Ucnt++;
				}
				dps = (dps*cnt + dpf)/(cnt+1);
				
				Debug(0,"1fr   "~itoa(dpf*60));
				Debug(1,"60f   "~itoa(sum));                //Rumia      Mokou
				Debug(2,"avg   "~itoa(floor(dps*6)*10));    //640 550    500
				Debug(3,"unf   "~itoa(floor(Udps*6)*10));   //350 520
				Debug(4,"foc   "~itoa(floor(Fdps*6)*10));   //680 550
				
				cnt++;
			}
		}
		yield;
	}
	task TToggle{
		loop{
			if(GetKeyState(KEY_D)==KEY_PUSH){ toggle=!toggle; SE_Play(se_select,100); }
			yield;
		}
	}
	function SumDamages{
		let shots = GetShotIdInCircleA2(cx,cy,800,TARGET_PLAYER);
		let sum = 0;
		ascent(i in 0..length(shots)){
			sum += GetHitDamage(shots[i]);
		}
		return sum;
	}
	function GetHitDamage(shot){
		if(ObjCol_IsIntersected(shot)){
			return ObjShot_GetDamage(shot);
		}else{
			return 0;
		}
	}
}








task TDebugText(){
	CreateCommonDataArea("DEBUG");
	CreateCommonDataArea("DEBUG_TEXT");
	let debugobj = ObjText_Create();
	ObjText_SetText(debugobj, "");
	ObjText_SetFontSize(debugobj, 12);
	ObjText_SetFontType(debugobj, "THSpatial");
	ObjText_SetMaxWidth(debugobj, GetStgFrameWidth() - 4);
	ObjRender_SetPosition(debugobj, 4, 28, 0);
	Obj_SetRenderPriorityI(debugobj,80);
	
	ObjText_SetFontBorderColor(debugobj,0,0,0);
	ObjText_SetFontBorderType(debugobj,BORDER_FULL);
	ObjText_SetFontBorderWidth(debugobj,1);

	let debugstr = "";
	loop{
		if(GetAreaCommonData("DEBUG", "DEBUG_TEXT_CHANGED", false)){
			SetAreaCommonData("DEBUG", "DEBUG_TEXT_CHANGED", false);
			let lines = GetCommonDataValueKeyList("DEBUG_TEXT");
			debugstr = "";
			ascent(i in 0..length(lines)){
				debugstr = debugstr ~ GetAreaCommonData("DEBUG_TEXT", lines[i], "") ~ "[r]";
			}
			ObjText_SetText(debugobj, debugstr);
		}
		yield;
	}
	Obj_Delete(debugobj);
}














//threw this down here just because
// // Example th_dnh.def
// package.script.main = script/path/to/package.dnh
// window.title = some title
// screen.width = 640
